{
  "timestamp": "2024-12-05T16:55:42.328689",
  "average_metrics": {
    "bleu": 0.06710122732671309
  },
  "detailed_results": [
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the EchoActor\nclass EchoActor extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! msg\n  }\n}\n\n// Usage Example\nobject EchoTest extends App {\n  val system = ActorSystem(\"EchoSystem\")\n  val echo = system.actorOf(Props[EchoActor], \"echo\")\n\n  echo ! \"Test Message\"\n}",
      "generated": "Here's a simple implementation of an actor in Akka Actor, which echoes back any received message to the sender. \n\nIn this case we are using Scala. First you need to import necessary module.\n\n```scala\nimport akka.actor.typed.{Behavior, PostStop, Signal}\nimport akka.actor.typed.scaladsl.{AbstractBehavior, Behaviors}\nimport akka.actor.typed.scaladsl.Behaviors._\nimport akka.util Timeout\n\nobject EchoActor extends App {\n  val echoActor = SysProps(\"echo-actor\").behavior(Behaviors.setup(context =>\n    new EchoBehavior(context)\n  ))\n\n  // Create an actor\n  implicit val system = ActorSystem(\"echo-system\", \"Echo Actor\")\n  val echoActorRef = system.actorRef(echoActor)\n\n  // Send a message to the actor\n  System.out.println(s\"Sending message...\")\n\n  // Tell the actor to stop after sending the response.\n  val future = context.system.sendSignal(echoActor, Signal.Terminated)\n  val timeoutFuture = Timeout.timeout(Duration.OneHour)(future)\n  timeoutFuture.onComplete {\n    case _ =>\n      system.terminate()\n  }\n\n  // Send a message to the actor\n  echoActorRef ! \"Hello\"\n}\n```\n\n```scala\n// The actor behavior that echoes back any received messages\nclass EchoBehavior(context: ActorContext[_]) extends AbstractBehavior[Nothing](context) with Behavior {\n\n  override type Feedback = Nothing\n\n  private var alive = true\n\n  override def onSignal(): Signal = {\n    if (alive) {\n      alive = false\n      context.log(\"Actor terminated, stopping sending responses\")\n    }\n    super.onSignal()\n  }\n\n  override def onMessage(message: Any): Option[Nothing] = {\n    // Send the message back to the sender\n    println(s\"Received message: $message\")\n    Some(())\n  }\n\n  override def onReceive(): Unit = {\n    if (!alive) {\n      context.log(\"Actor stopped, cannot receive messages\")\n    } else {\n      super.onReceive()\n      alive = true\n    }\n  }\n\n}\n```\n\nIn the above code:\n- We define a simple behavior called `EchoBehavior` that extends the Akka Actor's abstract behavior.\n- When an actor receives a message, it echoes back the same message to the sender by calling the `onMessage` method and returning `Some(())`.\n- If the actor receives a signal that says it should stop (like the \"Terminated\" signal), the actor stops echoing messages back to the sender.\n\nThis behavior is then used as the behavior for an actor system. We create an instance of this behavior, and use it to send a message to our echo actor.",
      "bleu": 0.029344841354504665
    },
    {
      "reference": "import akka.actor.Actor\nimport akka.actor.ActorSystem\nimport akka.actor.Props\n\nclass HelloActor extends Actor {\n  def receive = {\n    case \"hello\" => println(\"hello back at you\")\n    case _       => println(\"huh?\")\n  }\n}\n\nobject Main extends App {\n  val system = ActorSystem(\"HelloSystem\")\n  // default Actor constructor\n  val helloActor = system.actorOf(Props[HelloActor], name = \"helloactor\")\n  helloActor ! \"hello\"\n  helloActor ! \"buenos dias\"\n}",
      "generated": "Here is the \"Hello World\" example using Akka Actors:\n\n```scala\nimport akka.actor.{ActorSystem, Props}\n\nobject HelloWorldMain {\n  def main(args: Array[String]) = {\n    val system = ActorSystem(\"hello\")\n\n    // Create two instances of HelloWorldBot actor\n    val bot1 = systemactorOf(Props(new HelloWorldBot), \"World\")\n    val bot2 = system.actorOf(Props(new HelloWorldBot), \"Akka\")\n\n    // Send a sayHello message to both actors\n    bot1 ! SayHello(\"World\")\n    bot2 ! SayHello(\"Akka\")\n\n    // Stop the actor system when done\n    system.terminate()\n  }\n}\n\ncase class SayHello(name: String) extends Actor {\n  override def receive: Receive = {\n    println(s\"Hello $name!\")\n  }\n}\n\nclass HelloWorldBot extends Actor {\n  override def receive: Receive = {\n    case msg @ SayHello(_) => println(\"Greeting \" + (sys.props.get[Int](\"greetingCount\") + 1) + \" for \" + sys.context.path.head)\n  }\n}\n```\n\nIn this example, we create an actor system named `hello` and start two instances of the `HelloWorldBot` actor, one with name `\"World\"` and one with name `\"Akka\"`. We then send a `SayHello` message to both actors. The `HelloWorldBot` actor prints out a greeting for each message it receives.\n\nTo run this example, you'll need to have Akka installed in your project. You can add the following dependency to your `build.sbt` file:\n\n```scala\nlibraryDependencies += \"com.typesafe.akka\" %% \"akka-actor-typed\" % \"2.10.0\"\n```\n\nNote: Replace `\"2.10.0\"` with the version of Akka you want to use.\n\nAlso, make sure to run this example in a Scala environment and have the Akka documentation open next to you for reference.",
      "bleu": 0.06382141689194408
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props, ActorLogging}\n\n// Define the LoggingActor\nclass LoggingActor extends Actor with ActorLogging {\n  def receive: Receive = {\n    case msg: String if msg.startsWith(\"info\") =>\n      log.info(msg.stripPrefix(\"info \"))\n    case msg: String if msg.startsWith(\"warn\") =>\n      log.warning(msg.stripPrefix(\"warn \"))\n    case msg: String if msg.startsWith(\"error\") =>\n      log.error(msg.stripPrefix(\"error \"))\n    case msg =>\n      log.debug(s\"Received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LoggingApp extends App {\n  val system = ActorSystem(\"LoggingSystem\")\n  val logger = system.actorOf(Props[LoggingActor], \"logger\")\n\n  logger ! \"info This is an info message.\"\n  logger ! \"warn This is a warning message.\"\n  logger ! \"error This is an error message.\"\n  logger ! \"Unknown message format.\"\n\n  // Allow some time for logging before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
      "generated": "Here is a Scala implementation of the `LoggingActor` that utilizes Akka's built-in logging facilities to log received messages at different log levels.\n\n```scala\nimport akka.actor.typed._\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.javadsl.Behaviors\nimport akka.log.{DefaultLogger, LoggerKey}\nimport akka.util.Log\n\nobject LoggingActorExample {\n  def main(args: Array[String]) {\n    implicit val system = ActorSystem[Nothing](name = \"LoggingActorExample\")\n\n    implicit val log = DefaultLogger()\n\n    Behaviors.setup(context =>\n      new LoggingActor)\n  }\n}\n\nclass LoggingActor extends Behavior[Nothing] {\n\n  override type LocalContext = LoggingActorContext\n\n  def apply: Receive[Nothing] = {\n    case message =>\n      Log.info(\"Received message: \" + message)\n\n      // Log message at warn level\n      if (message.head == 'w') {\n        log.warning(\"Warning message\")\n      }\n\n      // Log message at error level\n      if (message.head == 'e') {\n        log.error(\"Error message\")\n      }\n\n      // Log any other message at debug level\n      log.debug(\"Debug message: \" + message)\n  }\n}\n\ntrait LoggingActorContext extends BehaviorContext[Nothing, LoggingActorContext] {\n  def logLevel: LogLevel\n\n  override def receive(message: Any): Receive[Nothing] = {\n    if (message.head == 'i') {\n      log(logLevel.info(\"Info message\"))\n    } else if (message.head == 'w') {\n      log(logLevel.warning(\"Warn message\"))\n    } else if (message.head == 'e') {\n      log(logLevel.error(\"Error message\"))\n    } else {\n      log(logLevel.debug(\"Debug message: \" + message))\n    }\n  }\n}\n```\n\nIn this code:\n\n*   We create a new `LoggingActor` class that extends the `Behavior[Nothing]` trait. This allows us to define our actor's behavior.\n*   Inside the `apply` method, we receive messages and log them at different levels based on their prefixes. Messages prefixed with 'i', 'w', or 'e' are logged at info, warn, and error levels, respectively. Any other message is logged at the debug level.\n*   We define a trait called `LoggingActorContext` that extends `BehaviorContext[Nothing, LoggingActorContext]`. This allows us to access our actor's log level from within its behavior.\n*   Inside the `receive` method of `LoggingActorContext`, we check the prefix of each received message and log it at the corresponding level.",
      "bleu": 0.02881184519661679
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Define the StashingActor\nclass StashingActor extends Actor with Stash {\n  def receive: Receive = waitingForInitialize\n\n  def waitingForInitialize: Receive = {\n    case \"initialize\" =>\n      println(\"StashingActor initialized. Processing stashed messages.\")\n      unstashAll()\n      context.become(initialized)\n    case msg =>\n      println(s\"StashingActor not initialized. Stashing message: $msg\")\n      stash()\n  }\n\n  def initialized: Receive = {\n    case msg =>\n      println(s\"StashingActor processing message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject StashApp extends App {\n  val system = ActorSystem(\"StashSystem\")\n  val stashingActor = system.actorOf(Props[StashingActor], \"stashingActor\")\n\n  stashingActor ! \"Message 1\"\n  stashingActor ! \"Message 2\"\n  stashingActor ! \"initialize\"\n  stashingActor ! \"Message 3\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
      "generated": "Below is the Scala implementation of the StashingActor:\n\n```scala\nimport akka.actor.typed.{Behavior, ActorRef}\nimport akka.actor.typed.scaladsl.{AbstractBehavior, BehaviorImpl, ExitStrategy}\n\nclass StashingActor(messageQueue: Queue[String], initializeMessage: String) extends AbstractBehavior[String] {\n  // Initialize actor with stash and onMessage handler\n  override def apply(environment: ActorContext[String]): Behavior[String] = {\n    val stashRef = environment.stash()\n    var isInitialized = false\n\n    behavior({\n      case _ => {\n        if (!isInitialized) {\n          isInitialized = true\n          // Wait for the \"initialize\" message to be received\n          environment.receiveMessage().onComplete {\n            case (message, _) =>\n              if (message == initializeMessage) {\n                val stashRefActorRef: ActorRef[String] = environment.stashRef()\n                val messagesToProcess = stashRef.receiveAll()\n\n                // Process all the stashed messages\n                messagesToProcess.foreach(_._1).forEach { message => sender().tell(message, stashRefActorRef) }\n              }\n          }\n\n          // After processing all messages, continue with normal behavior\n        } else {\n          // Get the next message from the queue and forward it to the actor\n          environment.stash().receiveAll()\n            .onComplete {\n              case (message, _) => sender().tell(message, stashRef)\n            }\n        }\n      }\n    }, ExitStrategy.whenEmpty())\n  }\n}\n```\n\nIn this implementation, we create a StashingActor class that extends AbstractBehavior and uses the `stashed()` method to stash incoming messages until it receives an \"initialize\" message. After receiving the initialize message, all stashed messages are processed and then the actor continues with normal behavior.\n\nHere's how you can use this Actor in your main function:\n\n```scala\nimport akka.actor.typed.{Behavior, BehaviorExt}\n\nobject StashingActorExample {\n  def main(args: Array[String]): Unit = {\n    // Create a new behavior for the StashingActor\n    val initializeMessage = \"initialize\"\n    val stashRef = scala.collection.mutable.Queue.empty[String]\n    val behavior = Behavior Ext.stash(stashRef).then(StashingActor(messageQueue = stashRef, initializeMessage = initializeMessage))\n\n    // Start the actor system with this behavior\n    implicit val system: ActorSystem[_] = ActorSystem[ behaviors.type](behavior)\n  }\n}\n```\n\nIn your Java version you can do something similar to create the StashingActor and run it:\n\n```java\n\nimport akka.actor.typed.ActorRef;\nimport akka.actor.typed.Behavior;\nimport akka.actor.typed.javadsl.AbstractBehavior;\nimport akka.actor.typed.javadsl.ActorContext;\nimport akka.actor.typed.javadsl.ActorSystem;\n\npublic class StashingActorExample {\n    public static void main(String[] args) {\n        // Create a new behavior for the StashingActor\n        String initializeMessage = \"initialize\";\n        ActorRef<Behavior<String>> stashRef = ActorContext.get().stash();\n        Behavior<String> behavior = Behavior.stash(stashRef)\n                .then(StashingActor.class, initializeMessage);\n        \n        // Start the actor system with this behavior\n        ActorSystem<String> system = ActorSystem.create(behavior);\n    }\n}\n```",
      "bleu": 0.018147795284763835
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.CircuitBreaker\nimport scala.concurrent.Future\nimport scala.concurrent.duration._\nimport scala.util.{Success, Failure}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Simulated unreliable external service\nobject ExternalService {\n  def unreliableOperation(): Future[String] = Future {\n    if (scala.util.Random.nextDouble() < 0.5)\n      throw new RuntimeException(\"Service failure!\")\n    else\n      \"Service response successful.\"\n  }\n}\n\n// Define the CircuitBreakerActor\nclass CircuitBreakerActor extends Actor {\n  // Initialize Circuit Breaker\n  val breaker = new CircuitBreaker(\n    scheduler = context.system.scheduler,\n    maxFailures = 3,\n    callTimeout = 2.seconds,\n    resetTimeout = 5.seconds\n  ).onOpen(\n    println(\"Circuit Breaker is OPEN!\")\n  ).onHalfOpen(\n    println(\"Circuit Breaker is HALF-OPEN.\")\n  ).onClose(\n    println(\"Circuit Breaker is CLOSED.\")\n  )\n\n  def receive: Receive = {\n    case \"callService\" =>\n      val originalSender = sender()\n      breaker.withCircuitBreaker(ExternalService.unreliableOperation()).onComplete {\n        case Success(response) =>\n          originalSender ! response\n        case Failure(ex) =>\n          originalSender ! s\"Operation failed: ${ex.getMessage}\"\n      }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CircuitBreakerApp extends App {\n  import akka.pattern.ask\n  import akka.util.Timeout\n  import scala.concurrent.Await\n\n  val system = ActorSystem(\"CircuitBreakerSystem\")\n  val breakerActor = system.actorOf(Props[CircuitBreakerActor], \"breakerActor\")\n\n  implicit val timeout: Timeout = Timeout(3.seconds)\n\n  for (i <- 1 to 5) {\n    val future = breakerActor ? \"callService\"\n    val result = Await.result(future, timeout.duration).asInstanceOf[String]\n    println(s\"Received: $result\")\n    Thread.sleep(1000)\n  }\n\n  system.terminate()\n}",
      "generated": "Here is an example of how you could design a CircuitBreakerActor in Scala using Akka Actor Typed:\n```\nimport akka.actor.typed.{Behavior, PostStop}\nimport akka.actor.typed.scaladsl.{AbstractBehavior, BehaviorImpl}\nimport akka.util.Timeout\nimport scala.concurrent.duration._\n\ncase class CallServiceRequest(value: String) extends Message with ActorMessage\n\nclass CircuitBreakerActor(system: ActorSystem) extends AbstractBehavior[CallServiceRequest] with Behavior {\n  import system.log\n\n  private val circuitBreaker = new CircuitBreaker(CallService, \"circuit-breaker\")\n  private var isCircuitOpen = false\n  private var failedRequestsCount = 0\n\n  override def onMessage(msg: CallServiceRequest): Behavior[CallServiceRequest] = {\n    if (isCircuitOpen) {\n      return Behaviors.same // Circuit is open, just pass the message to the next actor in the chain\n    }\n\n    circuitBreaker.withFailureThreshold(3)\n      .withSuccessThreshold(1)\n      .withResetThreshold(30)\n      .withTimer(10)\n      .handle(\n        callServiceResult => {\n          if (callServiceResult.foldLeft(failedRequestsCount) { case (count, _) => count + 1 } > circuitBreaker.failureThreshold()) {\n            isCircuitOpen = true\n            failedRequestsCount = callServiceResult.foldLeft(failedRequestsCount) { case (count, _) => count + 1 }\n          }\n\n          if (callServiceResult.isFailure) {\n            isCircuitOpen = true\n            failedRequestsCount = 0\n            log.warning(\"Call service failed\")\n            Behaviors.same // Circuit is open, just pass the message to the next actor in the chain\n          } else {\n            isCircuitOpen = false\n            log.info(s\"Call service succeeded for $msg.value\")\n            Behaviors.same // Circuit is closed, continue with the request\n          }\n        },\n        () => {\n          log.warning(\"Circuit breaker reset\")\n          circuitBreaker.reset()\n        }\n      )\n  }\n\n  override def onPostStop(): Unit = {\n    super.onPostStop()\n    circuitBreaker.stop()\n  }\n}\n\nobject CallService extends Service {\n  import akka.actor.typed.scaladsl.ServiceBehavior\n\n  val serviceName = \"call-service\"\n  def call(value: String): Future[Either[String, String]] = Future(Left(\"Error\")) // Simulate a failed call\n}\n```\nThis implementation defines an actor called `CircuitBreakerActor` that interacts with an external service using the `CallService` service. The actor uses Akka's Circuit Breaker behavior to detect when the service is experiencing issues and switch to a fallback behavior.\n\nHere's how it works:\n\n1. The actor receives a `CallServiceRequest` message, which triggers the circuit breaker.\n2. If the circuit is open (i.e., more than 3 failed requests in the last 30 seconds), the actor passes the message to the next actor in the chain and returns without processing it further.\n3. If the service call succeeds, the actor resets the circuit and continues with the request.\n4. If the service call fails, the actor detects the failure and switches to a fallback behavior.\n5. The actor logs a warning message when the circuit breaker is reset.\n\nNote that this implementation uses a simulated `CallService` service that always returns an error. In a real-world scenario, you would replace this with your actual external service.",
      "bleu": 0.04334227603732652
    },
    {
      "reference": "import akka.actor.{ActorSystem, Props}\nimport akka.actor.FSM\nimport scala.concurrent.duration._\n\n// Define states\nsealed trait LightState\ncase object Red extends LightState\ncase object Green extends LightState\ncase object Yellow extends LightState\n\n// Define data\nsealed trait LightData\ncase object Uninitialized extends LightData\n\n// Define the TrafficLightActor\nclass TrafficLightActor extends FSM[LightState, LightData] {\n  import context.dispatcher\n\n  // Define state durations\n  val redDuration: FiniteDuration = 3.seconds\n  val greenDuration: FiniteDuration = 2.seconds\n  val yellowDuration: FiniteDuration = 1.second\n\n  startWith(Red, Uninitialized, stateTimeout = redDuration)\n\n  when(Red, stateTimeout = redDuration) {\n    case Event(StateTimeout, _) =>\n      println(\"State: Red\")\n      goto(Green) using Uninitialized forMax greenDuration\n  }\n\n  when(Green, stateTimeout = greenDuration) {\n    case Event(StateTimeout, _) =>\n      println(\"State: Green\")\n      goto(Yellow) using Uninitialized forMax yellowDuration\n  }\n\n  when(Yellow, stateTimeout = yellowDuration) {\n    case Event(StateTimeout, _) =>\n      println(\"State: Yellow\")\n      goto(Red) using Uninitialized forMax redDuration\n  }\n\n  initialize()\n}\n\n// Usage Example (for testing purposes)\nobject TrafficLightApp extends App {\n  val system = ActorSystem(\"TrafficLightSystem\")\n  val trafficLight = system.actorOf(Props[TrafficLightActor], \"trafficLightActor\")\n\n  // Let the traffic light run for a few cycles before shutting down\n  Thread.sleep(12000)\n  system.terminate()\n}",
      "generated": "Here's how you can implement the TrafficLightActor using the FSM trait in Scala with Akka Actor Typed.\n\n```scala\nimport akka.actor.typed.{Behavior, PostStop}\nimport akka.actor.typed.scaladsl.{Behaviors, ExitStrategy}\nimport akka.pattern._\nimport akka.util.Timeout\nimport scala.concurrent.duration._\n\nobject TrafficLightActor {\n  val initialBehavior = Behavior refinements for (state: State) =>\n    if (state == State.Red)\n      Behavior { context =>\n        context.system.postStop {\n          println(s\"Traffic light turned red\")\n        }\n        context.stopWith(ExitStrategy.Cancellation)\n        \"red\"\n      }\n    else if (state == State.Green)\n      Behavior { context =>\n        context.system.postStop {\n          println(s\"Traffic light turned green\")\n        }\n        context.stopWith(ExitStrategy.Cancellation)\n        \"green\"\n      }\n    else if (state == State.Yellow)\n      Behavior { context =>\n        context.system.postStop {\n          println(s\"Traffic light turned yellow\")\n        }\n        context.stopWith(ExitStrategy.Cancellation)\n        \"yellow\"\n      }\n\n  def main(args: Array[String]): Unit = {\n    implicit val timeout: Timeout = 1.second\n\n    val stateDuration = Map(\n      State.Red -> Duration.seconds(3),\n      State.Green -> Duration.seconds(2),\n      State.Yellow -> Duration.seconds(1))\n    val initialBehaviorRefined: Behavior[State] = stateDuration.map(initialBehavior).reduce((a, b) => a refinements for (state) => if (state == State.Red) b else a)\n\n    TrafficLightActorBehaviors()\n  }\n\n  def TrafficLightActorBehaviors(): Behavior[Command] = {\n    val initialBehaviorRefined: Behavior[State] = stateDuration.map(initialBehavior).reduce((a, b) => a refinements for (state) => if (state == State.Red) b else a)\n    val initialBehaviorRefinedWithState: Behavior[(State, Int)] = initialBehaviorRefined.refine {\n      case (_, 0) => \"red\"\n      case (_, 1) => \"green\"\n      case (_, 2) => \"yellow\"\n    }\n    Behaviors.setup(context =>\n      context.system.postStop {\n        println(s\"Traffic light stopped\")\n      }\n      initialBehaviorRefinedWithState\n    )\n  }\n\n  sealed trait State\n  case object Red   extends State\n  case object Green extends State\n  case object Yellow extends State\n\n  case class Command(stateChange: State, countdown: Int)\n}\n```\n\nIn this example, we define a `TrafficLightActor` that transitions between states (Red, Green, and Yellow) based on the provided logic. The actor will print the current state in each transition and shut down after the final state is reached.\n\nThe actor's behavior is refined to include countdowns for each state, ensuring that the traffic light transitions smoothly.",
      "bleu": 0.04665716792754704
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.dispatch.{PriorityGenerator, UnboundedPriorityMailbox}\nimport com.typesafe.config.Config\n\n// Messages\ncase class HighPriority(msg: String)\ncase class LowPriority(msg: String)\n\n// Define the PriorityActor\nclass PriorityActor extends Actor {\n  def receive: Receive = {\n    case HighPriority(msg) =>\n      println(s\"High priority message: $msg\")\n    case LowPriority(msg) =>\n      println(s\"Low priority message: $msg\")\n  }\n}\n\n// Custom Priority Mailbox\nclass CustomPriorityMailbox(settings: ActorSystem.Settings, config: Config)\n    extends UnboundedPriorityMailbox(\n      PriorityGenerator {\n        case HighPriority(_) => 0\n        case LowPriority(_)  => 1\n        case _               => 2\n      }\n    )\n\n// Usage Example (for testing purposes)\nobject PriorityMailboxApp extends App {\n  import com.typesafe.config.ConfigFactory\n\n  val config = ConfigFactory.parseString(\"\"\"\n    akka {\n      actor {\n        mailboxes {\n          custom-priority-mailbox {\n            mailbox-type = \"CustomPriorityMailbox\"\n          }\n        }\n      }\n    }\n  \"\"\")\n\n  val system = ActorSystem(\"PrioritySystem\", config)\n  val priorityActor = system.actorOf(\n    Props[PriorityActor].withMailbox(\"custom-priority-mailbox\"),\n    \"priorityActor\"\n  )\n\n  // Send messages in mixed order\n  priorityActor ! LowPriority(\"Low priority message 1\")\n  priorityActor ! HighPriority(\"High priority message 1\")\n  priorityActor ! LowPriority(\"Low priority message 2\")\n  priorityActor ! HighPriority(\"High priority message 2\")\n  priorityActor ! \"Unknown message\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
      "generated": "Below is an example implementation of a custom priority mailbox using Akka Actor and demonstrates its usage. This example defines two custom message types `HighPriority` and `LowPriority`, each containing a string message.\n\n```scala\nimport akka.actor.{Actor, Behavior}\nimport akka.actor.typed.{BehaviorExt, PostStopSignal, SignalHandler}\nimport akka.actor.typed.scaladsl.{AbstractBehavior, Behaviors}\n\n// Custom mailbox definition\ncase class HighPriority(msg: String) extends Message with SignalHandler[PostStopSignal] {\n  override def onPostStop(): Unit = println(\"High priority actor stopped\")\n}\n\ncase class LowPriority(msg: String) extends Message with SignalHandler[PostStopSignal] {\n  override def onPostStop(): Unit = println(\"Low priority actor stopped\")\n}\n\n// Custom mailbox implementation\nclass PriorityMailbox() extends Behavior[Nothing] with SignalHandler[PostStopSignal] {\n\n  private[this] var highPriorityActor = None: Option[ActorRef[HighPriority]]\n\n  override def apply(): Behavior[Nothing] = Behaviors.setup(context =>\n    context.system.eventStream.subscribe(this)\n  )\n\n  override def handleSignal(signal: PostStopSignal): Unit =\n    if (signal.isClassOf[PostStopSignal]) {\n      highPriorityActor foreach { actor =>\n        context.system.eventStream.unsubscribe(actor)\n      }\n      context.system.eventStream.unsubscribe(this)\n    }\n\n  override def onPostStop(): Unit = {\n\n    val highPriorityActorRef = context.systemActorOf(HighPriorityBehavior(), \"high-priority-actor\")\n    this highPriorityActor = Some(highPriorityActorRef)\n\n    val lowPriorityActorRef = context.systemActorOf(LowPriorityBehavior(), \"low-priority-actor\")\n\n  }\n}\n\nobject PriorityMailbox {\n\n  def apply(): Behavior[Nothing] = Behaviors.setup(context => new PriorityMailbox().apply())\n}\n\n// Custom actors for demonstration\nclass HighPriorityActor() extends Actor {\n  override def receive: Receive[HighPriority] = {\n    case message: HighPriority =>\n      println(s\"Received high priority message: $message.msg\")\n  }\n}\n\nclass LowPriorityActor() extends Actor {\n  override def receive: Receive[LowPriority] = {\n    case message: LowPriority =>\n      println(s\"Received low priority message: $message.msg\")\n  }\n}\n\nobject HighPriorityBehavior {\n\n  def apply(): Behavior[Nothing] = Behaviors.setup(context => new HighPriorityActor().behavior())\n}\n\nobject LowPriorityBehavior {\n\n  def apply(): Behavior[Nothing] = Behaviors.setup(context => new LowPriorityActor().behavior())\n}\n```\n\nTo use the custom priority mailbox, you can create an `ActorSystem` with it:\n\n```scala\nimport akka.actor.{ActorSystem, System}\n\nval system = ActorSystem[System](\"system\")\nval mailboxBehavior = PriorityMailbox()\nval highPriorityRef = system.actorOf(mailboxBehavior(), \"high-priority-actor\")\nval lowPriorityRef = system.actorOf(mailboxBehavior(), \"low-priority-actor\")\n\n// Send messages to the actors\nhighPriorityRef ! HighPriority(\"High priority message\")\nlowPriorityRef ! LowPriority(\"Low priority message\")\n\n// When you're done, stop the system\nsystem.terminate()\n```\n\nThe custom priority mailbox ensures that `HighPriority` messages are processed before `LowPriority` messages, regardless of their order of arrival.",
      "bleu": 0.1416440176095133
    },
    {
      "reference": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the PingActor\nclass PingActor(pongActor: ActorRef) extends Actor {\n  // Start the ping-pong by sending \"Ping\" to PongActor\n  override def preStart(): Unit = {\n    pongActor ! \"Ping\"\n  }\n\n  def receive: Receive = {\n    case \"Pong\" =>\n      println(\"PingActor received: Pong\")\n      pongActor ! \"Ping\"\n    case _ =>\n      println(\"PingActor received unknown message.\")\n  }\n}\n\n// Define the PongActor\nclass PongActor extends Actor {\n  def receive: Receive = {\n    case \"Ping\" =>\n      println(\"PongActor received: Ping\")\n      sender() ! \"Pong\"\n    case _ =>\n      println(\"PongActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PingPongApp extends App {\n  val system = ActorSystem(\"PingPongSystem\")\n  val pong = system.actorOf(Props[PongActor], \"pongActor\")\n  val ping = system.actorOf(Props(new PingActor(pong)), \"pingActor\")\n\n  // Let the ping-pong run for a few exchanges before shutting down\n  Thread.sleep(1000)\n  system.terminate()\n}",
      "generated": "Here is an example implementation of two Akka Actors in Scala, PingActor and PongActor.\n\n**PingActor.scala**\n```scala\nimport akka.actor.typed.{ActorRef, ActorSystem}\nimport akka.actor.typed.scaladsl.Behaviors\n\nobject PingActor {\n  def apply(): Behavior[Nothing] = Behaviors.setup(context =>\n    val pongActorRef: ActorRef[PingPong] = context.system().spawn(PingPong.apply(), \"pong\")\n    behavior(PingPong.apply())\n      .onMessage[Ping](msg => context.log().info(s\"Received Ping from ${context.self()} -> Sending Pong to ${pongActorRef}\")\n        .tell(msg))\n  )\n}\n\ncase class Ping()\ncase class Pong()\n\nobject PingPong {\n  def apply(): Behavior[PingPong] = Behaviors.setup(context =>\n    behavior(Ping.apply())\n      .onMessage[Ping](msg => context.log().info(s\"Received Ping from ${context.self()} -> Sending Pong to ${context.system().actorFor[Pong]}\")\n        .tell(msg))\n      .onMessage[Pong](msg => context.log().info(s\"Received Pong from ${context.self()}\"))\n  )\n}\n```\n\n**PongActor.scala**\n```scala\nimport akka.actor.typed.{ActorRef, ActorSystem}\nimport akka.actor.typed.scaladsl.Behaviors\n\nobject PongActor {\n  def apply(): Behavior[PingPong] = Behaviors.setup(context =>\n    behavior(Pong.apply())\n      .onMessage[Ping](msg => context.log().info(s\"Received Ping from ${context.self()} -> Sending Pong to ${context.system().actorFor[Ping]}\")\n        .tell(msg))\n  )\n}\n\ncase class Ping()\ncase class Pong()\n\nobject PingPong {\n  def apply(): Behavior[PingPong] = Behaviors.setup(context =>\n    behavior(Pong.apply())\n      .onMessage[Ping](msg => context.log().info(s\"Received Ping from ${context.self()} -> Sending Pong to ${context.system().actorFor[Ping]}\")\n        .tell(msg))\n  )\n}\n```\n\nIn this implementation, the `PingActor` sends a \"Ping\" message to the `PongActor` when it starts. The `PongActor` responds with a \"Pong\" message and then receives another \"Ping\" message from the `PingActor`, which continues the ping-pong exchange.\n\nTo run these actors, you can create an `ActorSystem` and spawn the `PingActor` and `PongActor`:\n\n```scala\nimport akka.actor.typed.{ActorRef, ActorSystem}\nimport akka.actor.typed.scaladsl.Behaviors\n\nobject PingPongExample {\n  def main(args: Array[String]): Unit = {\n    val system = ActorSystem[Nothing]()\n    val pingActorRef: ActorRef[Ping] = system.spawn(PingActor.apply(), \"ping\")\n    val pongActorRef: ActorRef[Pong] = system.spawn(PongActor.apply(), \"pong\")\n\n    system.eventStream.subscribe(_ => {\n      println(\"Ping received from PongActor!\")\n    })\n\n    system.run()\n  }\n}\n```\n\nThis will start the actors and print messages to the console as they interact.",
      "bleu": 0.04566186109322814
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props, DeadLetter}\nimport akka.event.Logging\n\n// Define the DeadLetterMonitor Actor\nclass DeadLetterMonitor extends Actor {\n  val log = Logging(context.system, this)\n\n  def receive: Receive = {\n    case DeadLetter(message, sender, recipient) =>\n      log.warning(s\"DeadLetter captured: message=$message, sender=${sender.path}, recipient=${recipient.path}\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DeadLetterMonitorApp extends App {\n  val system = ActorSystem(\"DeadLetterMonitorSystem\")\n  val monitor = system.actorOf(Props[DeadLetterMonitor], \"deadLetterMonitor\")\n\n  // Subscribe the monitor to dead letters\n  system.eventStream.subscribe(monitor, classOf[DeadLetter])\n\n  // Send a message to a non-existent actor\n  system.actorSelection(\"/user/nonExistentActor\") ! \"Hello?\"\n\n  // Allow some time for the DeadLetter to be captured\n  Thread.sleep(1000)\n  system.terminate()\n}",
      "generated": "Here is the code for an Akka Actor named DeadLetterMonitor that listens to the system's dead letters and logs any unhandled messages.\n\n```scala\nimport akka.actor.typed.{Behavior, PostStop}\nimport akka.actor.typed.scaladsl.{AbstractBehavior, Behaviors}\nimport akka.actor.typed.javadsl.Behaviors\n\nobject DeadLetterMonitor {\n  def apply: Behavior[Nothing] = Behaviors.setup(context =>\n    context.listenFor(DeadLetters)\n      .onMessage[Nothing](message => println(s\"Unhandled message: $message\"))\n      .onPostStop(() => println(\"Actor stopped. Dead letters received.\")))\n}\n```\n\nTo test the above code you can use the following code:\n\n```scala\nimport akka.actor.typed.{ActorRef, Behavior}\n\nobject DeadLetterMonitorTest {\n  def main(args: Array[String]) {\n    implicit val system = ActorSystem[Nothing](\"DeadLetterMonitor\")\n    var deadLetterMonitor = system.spawn(DeadLetterMonitor.apply, \"dead-letter-monitor\")\n\n    // Send a message to a non-existent actor\n    deadLetterMonitor ! Behavior.never[Nothing]\n  }\n}\n```\n\nThis will start an actor that listens for dead letters and logs the messages when they are received. Then it sends a message to a non-existent actor which will be handled by the DeadLetterMonitor, but since it's a non-existent actor it won't send any reply back so it will be logged as unhandled message.",
      "bleu": 0.09194198897215163
    },
    {
      "reference": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the ChildActor\nclass ChildActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"$name received message: $msg\")\n  }\n}\n\n// Define the ParentActor\nclass ParentActor extends Actor {\n  // Create three child actors\n  val child1: ActorRef = context.actorOf(Props(new ChildActor(\"child1\")), \"child1\")\n  val child2: ActorRef = context.actorOf(Props(new ChildActor(\"child2\")), \"child2\")\n  val child3: ActorRef = context.actorOf(Props(new ChildActor(\"child3\")), \"child3\")\n\n  def receive: Receive = {\n    case msg =>\n      // Forward the message to all child actors\n      child1 ! msg\n      child2 ! msg\n      child3 ! msg\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ParentChildApp extends App {\n  val system = ActorSystem(\"ParentChildSystem\")\n  val parent = system.actorOf(Props[ParentActor], \"parentActor\")\n\n  // Send messages to the parent actor\n  parent ! \"Hello Children!\"\n  parent ! \"Another message.\"\n\n  // Allow some time for message processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
      "generated": "Here is an example of a ParentActor in Scala that creates and manages multiple ChildActors. The ParentActor forwards any received message to all its child actors.\n\n```scala\nimport akka.actor.typed.{Behavior, PostStop}\nimport akka.actor.typed.scaladsl.{AbstractBehavior, Behaviors}\n\n// Define a sealed trait for messages that can be sent to ChildActor\nsealed trait Message {\n  case class Hello(name: String) extends Message\n  case object Exit extends Message\n}\n\n// Actor that creates and manages multiple child actors\nclass ParentActor extends AbstractBehavior[Message] {\n  import ParentActor._\n\n  // Create child actor and add it to the set of existing children\n  override def onContext(context: ActorContext[Message]): Behavior[Message] = {\n    context.become(forwardMessages)\n    Behaviors.same\n  }\n\n  private def forwardMessages: Behavior[Message] = {\n    override def onMessage(message: Message): Behavior[Message] = {\n      // For each child actor, send the message and get its response\n      children foreach { _ =>\n        val childRef = context.child(_.name)\n        if (childRef != null) {\n          context.sendAndReceive(childRef, message) match {\n            case (response) => println(s\"Received from Child: $response\")\n            case Stop => println(\"Child stopped\")\n          }\n        } else {\n          println(s\"No child actor with name ${message.name}\")\n        }\n      }\n      Behaviors.same\n    }\n  }\n\n  private def exit(): Unit = {\n    // Stop all child actors and self\n    children foreach { _ =>\n      context.stop(_.name)\n    }\n    PostStop(context.system, this)\n  }\n\n  override def onSignal(signal: Signal): Behavior[Message] = {\n    super.onSignal(signal)\n    if (signal == Exit) {\n      exit()\n    } else {\n      Behaviors.same\n    }\n  }\n}\n\nobject ParentActor {\n  def apply(): Behavior[Message] = new ParentActor()\n}\n```\n\nTo demonstrate the creation of three child actors and sending messages through the ParentActor, you can do the following:\n\n```scala\nimport akka.actor.typed.{Behavior, PostStop}\nimport akka.actor.typed.scaladsl.Behaviors\n\nobject ChildActors extends App {\n  val system = ActorSystem[ behaviors => Behaviors.empty ]\n\n  // Create three child actors and start them as children of the ParentActor\n  var parentRef: ActorRef[ behaviors => Behaviors.empty ] = null\n  val child1 = system.actorOf(ChildActor.apply(), \"child1\")\n  val child2 = system.actorOf(ChildActor.apply(), \"child2\")\n  val child3 = system.actorOf(ChildActor.apply(), \"child3\")\n\n  // Create ParentActor and start it as a separate actor\n  parentRef = system.actorOf(ParentActor.apply())\n\n  // Send messages to the child actors through the ParentActor\n  parentRef ! Message>Hello(\"Alice\") // Will be received by all child actors\n  parentRef ! Message Hello(\"Bob\")\n  parentRef ! Message.Exit\n\n  // Keep the system running until it's stopped\n  system.run()\n}\n```\n\nNote that in this example, `ChildActor` is an empty actor with no behavior defined. You can add a behavior to create your own child actors.",
      "bleu": 0.11704944873686421
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the SwitchActor\nclass SwitchActor extends Actor {\n  // Define the happy behavior\n  def happy: Receive = {\n    case \"toggle\" =>\n      println(\"SwitchActor: Switching to sad state.\")\n      context.become(sad)\n    case _ =>\n      sender() ! \"I'm happy!\"\n  }\n\n  // Define the sad behavior\n  def sad: Receive = {\n    case \"toggle\" =>\n      println(\"SwitchActor: Switching to happy state.\")\n      context.become(happy)\n    case _ =>\n      sender() ! \"I'm sad.\"\n  }\n\n  // Initialize with happy behavior\n  def receive: Receive = happy\n}\n\n// Usage Example (for testing purposes)\nobject SwitchActorApp extends App {\n  import akka.pattern.ask\n  import akka.util.Timeout\n  import scala.concurrent.duration._\n  import scala.concurrent.Await\n\n  val system = ActorSystem(\"SwitchActorSystem\")\n  val switchActor = system.actorOf(Props[SwitchActor], \"switchActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to send a message and print the response\n  def sendMessage(msg: String): Unit = {\n    val future = switchActor ? msg\n    val result = Await.result(future, timeout.duration).asInstanceOf[String]\n    println(s\"Sent '$msg', Received: '$result'\")\n  }\n\n  // Initial state: happy\n  sendMessage(\"Hello\") // Should respond with \"I'm happy!\"\n\n  // Toggle to sad\n  sendMessage(\"toggle\")\n\n  // Now in sad state\n  sendMessage(\"Hello\") // Should respond with \"I'm sad.\"\n\n  // Toggle back to happy\n  sendMessage(\"toggle\")\n\n  // Back to happy state\n  sendMessage(\"Hello\") // Should respond with \"I'm happy!\"\n\n  system.terminate()\n}",
      "generated": "Below is a basic implementation of the `SwitchActor` that demonstrates state toggling.\n\n```scala\nimport akka.actor.typed.{Behavior, PostStop}\nimport akka.actor.typed.scaladsl.{AbstractBehavior, ExitStrategy}\nimport scala.concurrent.duration._\n\n// Define message types for switching actor states\nsealed trait Message\ncase object HappySwitch extends Message\ncase object SadSwitch extends Message\n\ncase class Greeting(message: String) extends Message {\n  def respond(): String = \"I'm happy!\"\n}\n\ncase class SadMessage() extends Message {\n  def respond(): String = \"I'm sad.\"\n}\n\n// Define the SwitchActor behavior\nclass SwitchActor extends AbstractBehavior[Message] with ExitStrategy {\n  // Initialize state to \"happy\"\n  private var state: State = State.Happy\n\n  override def onMessage(message: Message): Behavior[Message] = message match {\n    case HappySwitch =>\n      state = State.Happy\n      samesame\n    case SadSwitch =>\n      state = State.Sad\n      samesame\n    case _ => samesame\n  }\n\n  override def onSignal(signal: Signal): Behavior[Message] =\n    samesame\n\n  override def onExit(): Behavior[Message] = stopped\n\n  // Custom State enum for actor states\n  enum State {\n    Happy, Sad\n  }\n}\n```\n\nTo demonstrate the toggling between states, you can start a new `SwitchActor` and send messages to it. \n\n```scala\nimport akka.actor.typed.{Behavior, PostStop}\n\nobject SwitchActorDemo extends App {\n  // Create an actor system\n  val system = ActorSystem[Behavior[Message]](\"switch-actor-system\")\n\n  // Start the SwitchActor\n  val switchActor = system.spawn(SwitchActor(), \"switch-actor\")\n  \n  // Send happy and sad messages to the actor\n  switchActor ! HappySwitch\n  switchActor ! SadSwitch\n  \n  // Wait for the actor to exit (in this case, it's not needed because we've set `stopped` as our exit strategy)\n}\n```\n\nThis example will demonstrate that when `HappySwitch` is sent, the actor transitions into a \"happy\" state and responds with `\"I'm happy!\"`. Then, sending `SadSwitch` sends the actor to a \"sad\" state and responds with `\"I'm sad.\"`.\n\nNote: The behavior of the actor can be observed by running the demo in an IDE that supports Akka Actor System, such as IntelliJ IDEA or Eclipse.",
      "bleu": 0.11320562449080253
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the LifecycleActor\nclass LifecycleActor extends Actor {\n  override def preStart(): Unit = {\n    println(s\"${self.path.name} is starting.\")\n  }\n\n  override def postStop(): Unit = {\n    println(s\"${self.path.name} has stopped.\")\n  }\n\n  def receive: Receive = {\n    case \"shutdown\" =>\n      println(s\"${self.path.name} received shutdown message.\")\n      context.stop(self)\n    case msg =>\n      println(s\"${self.path.name} received message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LifecycleApp extends App {\n  val system = ActorSystem(\"LifecycleSystem\")\n  val lifecycleActor = system.actorOf(Props[LifecycleActor], \"lifecycleActor\")\n\n  lifecycleActor ! \"Hello\"\n  lifecycleActor ! \"shutdown\"\n\n  // Allow some time for shutdown processing before terminating the system\n  Thread.sleep(1000)\n  system.terminate()\n}",
      "generated": "Below is a simple implementation of the LifecycleActor using Akka actor typed Scala. The `LifecycleActor` will log messages upon starting (preStart) and stopping (postStop), as well as handle a \"shutdown\" message to gracefully stop itself.\n\n```scala\nimport akka.actor.typed.{ postStop, Signal }\nimport akka.actor.typed.scaladsl.{ AbstractBehavior, Behaviors }\nimport scala.concurrent.duration._\n\nobject LifecycleActor {\n  def apply: Behavior[Nothing] = {\n    val initialBehavior = \n      Behaviors.setup[Nothing, Nothing] { (context) =>\n        // Log a message when the actor starts\n        context.log.info(\"LifecycleActor started\")\n        \n        // Create a handler for \"shutdown\" messages\n        new ShutdownHandler(context)\n      }\n\n    Behaviors.stopped(initialBehavior)\n  }\n}\n\nclass ShutdownHandler(context: ActorRef[Nothing]) extends AbstractBehavior[Nothing] {\n  override def onSignal(): Signal[Nothing] = {\n    context.log.info(\"Received shutdown signal\")\n    // Return stopped behavior to force the actor's termination\n    Behavior.stopped\n  }\n}\n```\nLet's see how this is executed by sending messages:\n\n```scala\nimport akka.actor.typed.{ postStop, Signal }\nimport akka.actor.typed.scaladsl.{ AbstractBehavior, Behaviors }\n\nobject DemoLifecycleActor extends App {\n  val system = ActorSystem[Nothing](\"system\")\n  \n  // Create the Lifecycle actor\n  val lifecycle = system actorOf[LifecycleActor.apply]\n  \n  // Simulate some activity and then shutdown the actor with a signal\n  Thread.sleep(2000)\n  lifecycle ! Signal.Shutdown\n  \n  // Get any final messages logged by the actor\n  for (message <- lifecycle.log().asScala) {\n    println(message)\n  }\n\n  system.terminate()\n}\n```\n\nIn this code snippet, we first create an `ActorSystem` with a name and then create an instance of our `LifecycleActor`. After some time, we send the shutdown signal to the actor using the `Signal.Shutdown`, allowing it to gracefully stop. We're able to log any messages that get logged during this process by retrieving the message stream from the actor's log.",
      "bleu": 0.062353019100712705
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the FilterActor\nclass FilterActor extends Actor {\n  def receive: Receive = {\n    case num: Int if num > 10 =>\n      sender() ! s\"Accepted: $num\"\n    case num: Int =>\n      sender() ! s\"Rejected: $num\"\n    case msg =>\n      sender() ! s\"Unknown message type: $msg\"\n  }\n}\n\n// Usage Example (for testing purposes)\nobject FilterActorApp extends App {\n  import akka.pattern.ask\n  import akka.util.Timeout\n  import scala.concurrent.duration._\n  import scala.concurrent.Await\n\n  val system = ActorSystem(\"FilterActorSystem\")\n  val filterActor = system.actorOf(Props[FilterActor], \"filterActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to send an integer message and print the response\n  def sendNumber(num: Int): Unit = {\n    val future = filterActor ? num\n    val result = Await.result(future, timeout.duration).asInstanceOf[String]\n    println(s\"Sent $num, Received: '$result'\")\n  }\n\n  // Send a mix of numbers\n  sendNumber(5)    // Rejected\n  sendNumber(15)   // Accepted\n  sendNumber(10)   // Rejected\n  sendNumber(25)   // Accepted\n\n  // Send a non-integer message\n  val future = filterActor ? \"Hello\"\n  val result = Await.result(future, timeout.duration).asInstanceOf[String]\n  println(s\"Sent 'Hello', Received: '$result'\")\n\n  system.terminate()\n}",
      "generated": "Here's an example of how you could implement the FilterActor as described:\n\n```scala\nimport akka.actor.typed.{Behavior, postStop}\nimport akka.actor.typed.scaladsl.{AbstractBehavior, Behaviors}\nimport akka.common.time.Duration\n\ncase class Message(val value: Int) extends AnyVal\n\nobject FilterActor {\n  def apply(): Behavior[Message] = {\n    Behaviors.setup(context =>\n      context.system.log.info(\"FilterActor started\")\n      val filterRef: ActorRef[Message] = context.system.actorRefWithHandler[Message](Behavior { ctx =>\n        case msg @ Message(value) if value > 10 => ctx.spawn(ctx.system.actorOf[FilterActor behavior]).tell(msg)\n        case msg @ Message(value) => ctx.log.info(s\"Rejected: $value\")\n      }, behavior = FilterActor)\n      filterRef\n    ))\n  }\n}\n```\n\nThis actor will only accept messages with a value greater than 10, and respond with \"Accepted: <number>\" if such a message is received. All other messages will be rejected with the string \"Rejected: <number>\". \n\nHere's how you could use it:\n\n```scala\nimport akka.actor.typed.scaladsl.{Behavior, TestKit}\nimport akka.testkit.{ImplicitSender, TestKit}\n\nobject FilterActorTest extends App {\n\n  implicit val system = ActorSystem(\"test-system\")\n  val filterRef = TestKit(implicit(system).actorOf(FilterActor()))\n\n  filterRef ! Message(11)\n  filterRef ! Message(5)\n  filterRef ! Message(2)\n\n  filterRef ! SystemExit\n}\n```\n\nThis example creates an actor named \"test-system\" and starts the FilterActor. It then sends three messages to it: two with values greater than 10, one with a value less than or equal to 10, and finally requests that the actor exit. The log output should be:\n\n```\nFilterActor started\nAccepted: 11\nRejected: 5\nRejected: 2\n```",
      "bleu": 0.07735251243223197
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext\n\n// Define the SelfMessageActor\nclass SelfMessageActor extends Actor {\n  import context.dispatcher\n\n  // Schedule to send \"tick\" to self every second\n  var cancellable: Cancellable = _\n  \n  override def preStart(): Unit = {\n    cancellable = context.system.scheduler.scheduleWithFixedDelay(\n      0.seconds,\n      1.second,\n      self,\n      \"tick\"\n    )\n  }\n\n  override def postStop(): Unit = {\n    cancellable.cancel()\n  }\n\n  def receive: Receive = {\n    case \"tick\" =>\n      println(\"Tick received\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelfMessageApp extends App {\n  val system = ActorSystem(\"SelfMessageSystem\")\n  val selfMessageActor = system.actorOf(Props[SelfMessageActor], \"selfMessageActor\")\n\n  // Let the actor tick for 5 seconds before shutting down\n  Thread.sleep(5000)\n  system.terminate()\n}",
      "generated": "Below is an example of how you can create a SelfMessageActor that schedules itself to receive a \"tick\" message every second. Upon receiving the \"tick\" message, it prints \"Tick received\" and continues scheduling the next tick.\n\n```scala\nimport akka.actor.typed.{ActorRef, ActorSystem, Behavior}\nimport akka.actor.typed.Behaviors\nimport akka.actor.typed.scaladsl.{AbstractBehavior, Behaviors}\nimport akka.util.Timeout\n\nobject SelfMessageActor {\n  implicit val system: ActorSystem[ behaviors.Message ] =\n    ActorSystem(SelfMessageActor().behaviour(), \"self-message-actor\")\n\n  def main(args: Array[String]): Unit = {\n    // Create a new self message actor and schedule the first tick\n    val selfMessageActorRef: ActorRef[ behaviors.Message ] = system.spawnSelfMessageActor()\n\n    // Wait for the actor to stop\n    system.stop(selfMessageActorRef)\n  }\n}\n\ncase class Tick(message: String) extends behavior\n\nclass SelfMessageActor extends AbstractBehavior[ behaviors.Message ] {\n  import SelfMessageActor._\n  override def onMessage(context: ActorContext[ behaviors.Message ], message: Tick): Behavior = {\n    println(\"Tick received\")\n    // Schedule the next tick every second\n    Behaviors.setup(context) { context =>\n      implicit val timeout: Timeout = Timeout(1.second)\n      context.spout(Tick(\"second passed\"))\n    }\n  }\n\n}\n```\n\nAnd in `Message.scala`, you have a protocol with a message for self-message actor.\n\n```scala\nimport akka.actor.typed.{Behavior, Message, Signal}\nimport akka.actor.typed.javadsl.Behaviors\n\nobject Messages {\n  sealed trait Behavior extends Message with Signal\n\n  case class Tick(message: String) extends Behavior\n\n}\n\ncase class SelfMessageActorProtocol(val id: String) extends MessagesBehaviour[ behavior.Message ] {\n    def onMessage(message: MessagesBehaviour behaviour.Message): MessagesBehaviour behaviour behaviour behaviours {\n\n        if (message.isInstanceOf[Messages.Tick]) {\n            return selfMessageActor()\n        } else {\n            return MessagesBehaviour.defaultBehaviour\n        }\n    }\n\n    override type Behaviour = SelfMessageActorProtocol\n\n    val selfMessageActor = MessagesBehaviour(\n      name = \"self-message-actor\",\n      behaviour = new SelfMessageActor()\n    )\n}\n```\n\nAnd finally in `ActorScala`, you would call this method on the Actor System.\n\n```scala\nobject ActorScala {\n  def main(args: Array[String]): Unit = {\n    implicit val system: ActorSystem[behavior.Message] =\n      ActorSystem(SelfMessageActorProtocol(\"self-message-actor\"), \"self-message-actor\")\n\n//     create an ActorRef and ask it to receive a message\n\n    // create an actor and spawn the new actor\n  }\n}\n```",
      "bleu": 0.07230052706390837
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.Queue\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext\n\n// Define the LimitedProcessorActor\nclass LimitedProcessorActor extends Actor {\n  import context.dispatcher\n\n  // Internal message queue\n  val messageQueue: Queue[String] = Queue.empty\n\n  // Processing state\n  var isProcessing: Boolean = false\n  var currentCancellable: Option[Cancellable] = None\n\n  def receive: Receive = {\n    case msg: String =>\n      messageQueue.enqueue(msg)\n      processNext()\n\n    case \"processingComplete\" =>\n      isProcessing = false\n      println(s\"${self.path.name} completed processing.\")\n      processNext()\n  }\n\n  def processNext(): Unit = {\n    if (!isProcessing && messageQueue.nonEmpty) {\n      val msg = messageQueue.dequeue()\n      isProcessing = true\n      println(s\"${self.path.name} started processing: $msg\")\n      // Simulate processing delay\n      val cancellable = context.system.scheduler.scheduleOnce(500.milliseconds, self, \"processingComplete\")\n      currentCancellable = Some(cancellable)\n    }\n  }\n\n  override def postStop(): Unit = {\n    currentCancellable.foreach(_.cancel())\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LimitedProcessorApp extends App {\n  val system = ActorSystem(\"LimitedProcessorSystem\")\n  val processor = system.actorOf(Props[LimitedProcessorActor], \"processorActor\")\n\n  // Send multiple messages rapidly\n  processor ! \"Task 1\"\n  processor ! \"Task 2\"\n  processor ! \"Task 3\"\n  processor ! \"Task 4\"\n  processor ! \"Task 5\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(4000)\n  system.terminate()\n}",
      "generated": "Here's an example implementation of a `LimitedProcessorActor` in Scala using Akka Actor typed. This actor maintains an internal queue of messages and processes only one message at a time, ignoring incoming messages while busy processing.\n\n```scala\nimport akka.actor.typed.{Behavior, PostStop}\nimport akka.actor.typed.scaladsl.{AbstractBehavior, BehavioralContext}\n\ncase class ProcessMessage(message: String)\n\nobject LimitedProcessorActor extends AbstractBehavior[ProcessMessage] {\n  override def apply(context: BehavioralContext[ProcessMessage]): Behavior[ProcessMessage] = {\n    val queue = context.getQueue[ProcessMessage]\n    context.setHandler(ReceiveVoid) {\n      case message =>\n        val result = processMessage(message)\n        if (result != null) {\n          queue.add(result)\n        }\n    }\n    queue.add(ProcessMessage(\"Hello, world!\"))\n    Behaviors.never\n  }\n\n  private def processMessage(message: ProcessMessage): String | None = {\n    // Replace this with your actual processing logic\n    message.message\n  }\n\n  override def onPostStop(): Unit = println(\"Actor stopped\")\n}\n```\n\nYou can create and start an instance of the `LimitedProcessorActor` using Akka Actor typed as follows:\n\n```scala\nimport akka.actor.typed.{Behavior, PostStop}\n\nobject Main {\n  def main(args: Array[String]): Unit = {\n    val actorRef = ActorSystem[ProcessMessage]\n      .behavior(LimitedProcessorActor.apply)\n      .start()\n\n    // Send some messages to the actor\n    for (i <- 1 to 10) {\n      actorRef ! ProcessMessage(s\"Message $i\")\n    }\n\n    // Wait for the actor to stop\n    Thread.sleep(1000)\n  }\n}\n```\n\nThis example shows how the actor processes one message at a time while ignoring incoming messages. The actor adds each processed message to its internal queue.\n\nIn this code:\n\n- `LimitedProcessorActor` is an actor that maintains an internal queue of messages.\n- It applies a behavior (`Behaviors.never`) which means it never receives any new message.\n- However, the actor still handles the `ProcessMessage` case by setting up a receive handler to handle incoming messages. If it gets a new message while handling another one, it ignores that message and continues with the previous message.\n- When the actor finishes processing all messages in its queue, it adds a new message to the queue for future processing.\n- The `onPostStop` method is overridden to print \"Actor stopped\" when the actor receives the PostStop signal from the ActorSystem.",
      "bleu": 0.053538244993352274
    },
    {
      "reference": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\n\n// Define the Greet message\ncase class Greet(name: String)\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Greet(name) =>\n      sender() ! s\"Hello, $name!\"\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ResponderApp extends App {\n  val system = ActorSystem(\"ResponderSystem\")\n  val responder = system.actorOf(Props[ResponderActor], \"responderActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Send a Greet message using the ask pattern\n  val future = responder ? Greet(\"Bob\")\n  val result = Await.result(future, timeout.duration).asInstanceOf[String]\n  println(s\"Received response: '$result'\")\n\n  system.terminate()\n}",
      "generated": "Here's how you can create such an actor in Scala:\n\n```scala\nimport akka.actor.typed.{Behavior, PostStop}\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.judgement._\n\nobject ResponderActor {\n  case class Greeted(name: String)\n\n  def greetResponder( replyTo: ActorRef[Greeted]) = {\n    Behaviors.setup(\n      context =>\n        context.watch(replyTo) { replyTo =>\n\n          val message = \"Hello, user!\"\n          replyTo ! message\n          println(s\"Sending $message to $name\")\n\n          // send additional greeting messages and collect the replies until a given max number of messages have been reached\n          for (i <- 0 until 3) {\n            val newMessage = s\"Hello, user! ${i}\"\n            replyTo ! newMessage\n            println(s\"Sending $newMessage to $name\")\n          }\n        },\n      PostStop,\n      replyTo\n    )\n  }\n\n  def main(args: Array[String]): Unit = {\n    // create a Greet actor to test the ResponderActor\n    val greet = Behaviors.setup(context => {\n      context.log.info(\"Greet actor started\")\n      Behavior.greeted[ behaviors.BehaviorRef[Greeted] >> Greeted]\n    })\n\n    // create a ResponderActor that listens for Greet(name: String) messages\n    val responder = Behaviors.setup(\n      context =>\n        greetResponder(context ActorRef[Greeted])\n    )\n\n    // send a message to the ResponderActor and print it back\n    println(\"Sending 'Hello, user!' to the actor...\")\n    val replyTo = context.ActorRef[ behaviors.BehaviorRef[Greeted] >> Greeted]\n    responder ! Greeted(\"user\")\n  }\n}\n```\nWhen you run this, a \"ResponderActor\" listens for Greet messages. When it receives one, it replies back with \"Hello, user!\". If the reply is successful, then it sends three additional greeting messages and collects the responses until a total of four messages are received.",
      "bleu": 0.06424278834533427
    },
    {
      "reference": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy._\nimport scala.concurrent.duration._\n\n// Define the FaultyChildActor\nclass FaultyChildActor extends Actor {\n  def receive: Receive = {\n    case \"causeNull\" =>\n      println(s\"${self.path.name} received 'causeNull' and will throw NullPointerException.\")\n      throw new NullPointerException(\"Simulated NullPointerException.\")\n    case msg =>\n      println(s\"${self.path.name} received message: $msg\")\n  }\n}\n\n// Define the EscalatingSupervisor Actor\nclass EscalatingSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy() {\n    case _: NullPointerException =>\n      println(\"EscalatingSupervisor: Escalating the failure.\")\n      Escalate\n  }\n\n  // Create the child actor\n  val child: ActorRef = context.actorOf(Props[FaultyChildActor], \"faultyChildActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Define the TopLevelSupervisor Actor to handle escalation\nclass TopLevelSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy() {\n    case _: NullPointerException =>\n      println(\"TopLevelSupervisor: Stopping the failing child.\")\n      Stop\n    case _: Exception =>\n      println(\"TopLevelSupervisor: Restarting the failing child.\")\n      Restart\n  }\n\n  // Create the EscalatingSupervisor as child\n  val escalatingSupervisor: ActorRef = context.actorOf(Props[EscalatingSupervisor], \"escalatingSupervisor\")\n\n  def receive: Receive = {\n    case msg =>\n      escalatingSupervisor.forward(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EscalationApp extends App {\n  val system = ActorSystem(\"EscalationSystem\")\n  val topSupervisor = system.actorOf(Props[TopLevelSupervisor], \"topSupervisor\")\n\n  // Send a message that causes the child to throw an exception\n  topSupervisor ! \"causeNull\"\n\n  // Allow some time for supervision to take effect before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
      "generated": "Here's an example of how to design an Akka Supervisor Actor in Scala named EscalatingSupervisor that supervises a child actor named FaultyChildActor:\n\n```scala\nimport akka.actor.typed._\nimport akka.actor.typed.model._\nimport akka.actor.typed.scaladsl.{Behaviors, PostStop}\n\nobject EscalatingSupervisor {\n  object MessageAdapter {\n    def causeNull: Any = sys.props.get(\"causeNull\").asInstanceOf[Any]\n  }\n\n  def apply(): Behavior[FaultyChildActor] =\n    Behaviors.setup { context =>\n      val faultyChildActor = context.spawn(FaultyChildActor(), \"faultyChildActor\")\n\n      Behaviors.receiveMessage[FaultyChildActor] { (msg, context) =>\n        try {\n          context.system.ask(FaultyChildActor(), MessageAdapter.causeNull).foreach { cause ->\n            context.system.ask(faultyChildActor, \"responseFromParent\").foreach { response =>\n              // Handle the response from parent\n            }\n          }\n\n          context.system.ask(faultyChildActor, msg.name).foreach { replyTo =>\n            // Handle the message\n            context.system.actorSelection(\"user/\" + replyTo) ! HelloWorld.Greet(msg.name, replyTo)\n          }\n        } catch {\n          case e: Exception =>\n            val supervisor = context.system.actorOf(EscalatingSupervisor(), \"supervisor\")\n            supervisor ! MessageAdapter.causeNull // Escalate the failure\n        }\n\n        Behaviors.same\n      }.onTermination(terminationStrategy = Termination.Strategy.CombinedWithDefault)\n    }\n}\n\nclass FaultyChildActor() extends Actor[FaultyChildActor] with Logging {\n\n  override def receive: Receive[FaultyChildActor] = {\n    case msg => // Handle the message\n    case causeNull =>\n      context.system.actorSelection(\"user/supervisor\") ! Terminated(this) // Terminate myself and escalate to supervisor\n  }\n}\n\nobject HelloWorldBot {\n  sealed trait Message\n\n  final case class Name(name: String) extends Message with Logging {}\n\n  def apply(max: Int): Behavior[Message] =\n    Behaviors.setup { context =>\n      val greeter = context.spawn(HelloWorld(), \"greeter\")\n\n      Behaviors.receiveMessage[Message] { (msg, context) =>\n        val replyTo = context.spawn(this, msg.name)\n        greeter ! HelloWorld.Greet(msg, replyTo)\n        Behaviors.same\n      }\n    }\n\n}\n\ncase class MessageAdapter(causeNull: Any)\n\nobject HelloWorld {\n  sealed trait Greeting\n\n  final case class Greet(name: String, replyTo: ActorRef[Greeting]) extends Greeting with Logging {\n\n    override def toString(): String = s\"Hello $name\"\n  }\n}\n```\n\nIn the above code, `EscalatingSupervisor` is an actor that supervises a child actor named `FaultyChildActor`. When `FaultyChildActor` receives a message, it tries to handle it. However, when it encounters an exception or the \"causeNull\" message, it terminates itself and escalates the failure to its supervisor (`EscalatingSupervisor`). The `EscalatingSupervisor` actor can then try to recover from the failure by restarting its child actor or taking some other corrective action.",
      "bleu": 0.07130548902332018
    }
  ]
}