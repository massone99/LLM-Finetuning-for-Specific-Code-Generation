[
  {
    "idx": 0,
    "prompt": "Implement a simple Akka Actor that echoes back any received message to the sender.",
    "code": "import akka.actor.{Actor, ActorSystem, Props}\n\n# Define the EchoActor\nclass EchoActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"EchoActor received message: $msg from ${sender().path.name}\")\n  }\n}\n\n# Usage Example\nif __name__ == \"__main__\":\n  system = ActorSystem(\"EchoSystem\")\n  echoActor = system.actorOf(Props[EchoActor](), \"echoActor\")\n\n  # Define a simple sender actor to send messages\n  class SenderActor extends Actor {\n    def receive: Receive = {\n      case msg =>\n        echoActor! msg\n      case _ =>\n        println(\"SenderActor received unknown message.\")\n    }\n  }\n\n  sender = system.actorOf(Props[SenderActor](), \"senderActor\")\n\n  # Send messages\n  sender! \"Hello via Echo!\"\n  sender! \"Another echoed message.\"\n\n  # Allow some time for processing before shutdown\n  time.sleep(1000)\n  system.terminate()",
    "error": ""
  },
  {
    "idx": 2,
    "prompt": "Create an Akka Actor in Scala named LoggingActor that utilizes Akka\u2019s built-in logging facilities to log received messages at different log levels. Messages prefixed with \"info\", \"warn\", or \"error\" should be logged at the corresponding levels. All other messages should be logged at the debug level.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.actor.LogLevel\n\n// Define the LoggingActor\nclass LoggingActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      val level = msg.toLowerCase Match {\n        case \"info\" => LogLevel.Info\n        case \"warn\" => LogLevel.Warn\n        case \"error\" => LogLevel.Error\n        case _ => LogLevel.Debug\n      }\n      println(s\"LoggingActor received message at $level: $msg\")\n    case _ =>\n      println(\"LoggingActor received unknown message.\")\n  }\n}\n\n// Usage Example\nobject LoggingApp extends App {\n  val system = ActorSystem(\"LoggingSystem\")\n  val loggingActor = system.actorOf(Props[LoggingActor](), \"loggingActor\")\n\n  loggingActor! \"User logged in.\"\n  loggingActor! \"Software encountered an error.\"\n  loggingActor! \"Application is running smoothly.\"\n  loggingActor! \"info\"\n  loggingActor! \"warn\"\n  loggingActor! \"error\"\n  loggingActor! \"Unknown Message\"\n}",
    "error": ""
  },
  {
    "idx": 3,
    "prompt": "Implement an Akka Actor in Scala named StashingActor that stashes incoming messages while waiting for an \"initialize\" message. Once initialized, it should unstash and process all previously stashed messages and handle new messages normally.",
    "code": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the StashingActor\nclass StashingActor extends Actor {\n  def receive: Receive = {\n    case \"initialize\" =>\n      println(\"StashingActor received 'initialize'.\")\n      unstashAll()\n      processQueue()\n    case msg =>\n      println(s\"StashingActor received message: $msg\")\n  }\n\n  // Internal message queue\n  var queue: List[String] = List.empty\n\n  def processQueue(): Unit = {\n    queue.foreach(_!)\n  }\n\n  override def postStop(): Unit = {\n    queue.foreach(_!)\n  }\n}\n\n// Usage Example\nobject StashingActorApp extends App {\n  val system = ActorSystem(\"StashingActorSystem\")\n  val stashingActor = system.actorOf(Props[StashingActor](), \"stashingActor\")\n\n  // Send stashed messages\n  stashingActor! \"Message 1\"\n  stashingActor! \"Message 2\"\n  stashingActor! \"Message 3\"\n\n  // Send initialize message\n  stashingActor! \"initialize\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 4,
    "prompt": "Design an Akka Actor in Scala named CircuitBreakerActor that interacts with an unreliable external service. Use Akka\u2019s CircuitBreaker to handle failures gracefully. The actor should attempt to call the external service when it receives a \"callService\" message and respond with either the service's response or an error message if the circuit is open.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, CircuitBreaker}\nimport scala.concurrent.duration._\nimport akka.actor.CircuitBreaker._\nimport scala.concurrent.Await\nimport scala.util.Random\n\n// Define messages\ncase object callService\ncase class serviceResponse(content: String)\ncase class serviceError(content: String)\n\n// Define the CircuitBreakerActor\nclass CircuitBreakerActor extends Actor with CircuitBreaker {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case \"callService\" =>\n      println(s\"${self.path.name} attempting to call external service.\")\n      val serviceResponse = Await.result(\n        ExternalServiceActor! \"performService\"\n      )\n      serviceResponse match {\n        case ServiceResponse(content) =>\n          println(s\"${self.path.name} received service response: $content\")\n        case ServiceError(content) =>\n          println(s\"${self.path.name} encountered an error: $content\")\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the ExternalServiceActor\nclass ExternalServiceActor extends Actor {\n  def receive: Receive = {\n    case \"performService\" =>\n      println(s\"${self.path.name} performing service.\")\n      // Simulate failure or success\n      if (Random.nextBoolean()) {\n        println(s\"${self.path.name} failed to perform service.\")\n        sender()! ServiceError(\"Service failed.\")\n      } else {\n        println(s\"${self.path.name} performed service successfully.\")\n        sender()! ServiceResponse(\"Service responded successfully.\")\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CircuitBreakerApp extends App {\n  val system = ActorSystem(\"CircuitBreakerSystem\")\n  val circuitBreaker = system.actorOf(Props[CircuitBreakerActor](), \"circuitBreakerActor\")\n\n  // Allow some time for failure before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 5,
    "prompt": "Implement an Akka Actor using the FSM trait named TrafficLightActor. The actor should have three states: Red, Green, and Yellow. It should transition between these states in the order: Red \u2192 Green \u2192 Yellow \u2192 Red, with each state lasting for a specified duration (e.g., Red for 3 seconds, Green for 2 seconds, Yellow for 1 second). In each state, the actor should print the current state.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport akka.actor.Timers\n\n// Define the TrafficLightActor\nclass TrafficLightActor extends Actor with FSM {\n  import context.dispatcher\n\n  // Define the states\n  case object Red\n  case object Green\n  case object Yellow\n\n  // Schedule state transitions\n  val redDuration: FiniteDuration = 3.seconds\n  val greenDuration: FiniteDuration = 2.seconds\n  val yellowDuration: FiniteDuration = 1.second\n\n  val transitions: Map[String, (ActorSystem, Actor)] = Map(\n    \"Red\" -> (self, Red),\n    \"Green\" -> (self, Green),\n    \"Yellow\" -> (self, Yellow),\n    \"Red\" -> (self, Red) // Transition back to Red after Green\n  )\n\n  // Schedule state changes\n  val scheduler: Map[String, Cancellable] = Map(\n    \"Red\" -> context.system.scheduler.scheduleOnce(redDuration, self, Green),\n    \"Green\" -> context.system.scheduler.scheduleOnce(greenDuration, self, Yellow),\n    \"Yellow\" -> context.system.scheduler.scheduleOnce(yellowDuration, self, Red)\n  )\n\n  def receive: Receive = {\n    case \"toggle\" =>\n      self! transitions(\"Yellow\")\n    case state =>\n      self! state\n  }\n\n  override def postStop(): Unit = {\n    scheduler.foreach(_!.cancel())\n    super.postStop()\n  }\n\n  override def shutdown(): Unit = {\n    scheduler.foreach(_!.cancel())\n    super.shutdown()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TrafficLightApp extends App {\n  val system = ActorSystem(\"TrafficLightSystem\")\n  val trafficLight = system.actorOf(Props(new TrafficLightActor()), \"trafficLightActor\")\n\n  trafficLight! \"Red\"\n  trafficLight! \"Green\"\n  trafficLight! \"Yellow\"\n  trafficLight! \"Red\" // Manually toggle to Red\n\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 6,
    "prompt": "Create an Akka Actor named PriorityActor that processes messages with a custom priority mailbox. Messages of type HighPriority(msg: String) should be processed before messages of type LowPriority(msg: String), regardless of the order they are received. Implement the custom mailbox and demonstrate its usage.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, Mailbox}\n\n// Define custom messages\ncase class HighPriority(msg: String)\ncase class LowPriority(msg: String)\n\n// Define the PriorityMailbox\nclass PriorityMailbox extends Mailbox {\n  def receive: Receive = {\n    case HighPriority(msg) =>\n      println(s\"High Priority message: $msg\")\n    case LowPriority(msg) =>\n      println(s\"Low Priority message: $msg\")\n    case msg =>\n      println(s\"Unknown message: $msg\")\n  }\n}\n\n// Define the PriorityActor\nclass PriorityActor(mailbox: Mailbox) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      mailbox.process(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PriorityApp extends App {\n  val system = ActorSystem(\"PrioritySystem\")\n  \n  // Create a PriorityMailbox\n  val priorityMailbox = system.actorOf(Props[PriorityMailbox](), \"priorityMailbox\")\n  \n  // Create a PriorityActor with the custom mailbox\n  val priorityActor = system.actorOf(Props(new PriorityActor(priorityMailbox)), \"priorityActor\")\n  \n  // Send messages in mixed order\n  priorityActor! LowPriority(\"Welcome\")\n  priorityActor! HighPriority(\"Priority!\")\n  priorityActor! LowPriority(\"Thank you.\")\n  priorityActor! HighPriority(\"Super Priority!\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 8,
    "prompt": "Create an Akka Actor in Scala named DeadLetterMonitor that listens to the system's dead letters and logs any unhandled messages. Demonstrate sending a message to a non-existent actor and having the DeadLetterMonitor capture it.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.actor.DeadLetterMonitor\n\n// Define the NonExistingActor\nclass NonExistingActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"NonExistingActor received message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DeadLetterMonitorApp extends App {\n  val system = ActorSystem(\"DeadLetterMonitorSystem\")\n  val deadLetterMonitor = system.actorOf(Props[DeadLetterMonitor](), \"deadLetterMonitor\")\n\n  // Send a message to the non-existing actor\n  deadLetterMonitor! \"Hello, world!\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 10,
    "prompt": "Implement an Akka Actor in Scala named SwitchActor that starts in a \"happy\" state. When it receives a \"sad\" message, it switches to a \"sad\" state, and vice versa. In the \"happy\" state, it should respond to any message with \"I'm happy!\", and in the \"sad\" state, it should respond with \"I'm sad.\" Demonstrate toggling between states.",
    "code": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define messages\ncase object SadMessage\ncase object HappyMessage\n\n// Define the SwitchActor\nclass SwitchActor extends Actor {\n  def receive: Receive = {\n    case \"sad\" =>\n      println(switchActor.state = \"sad\")\n    case \"happy\" =>\n      println(switchActor.state = \"happy\")\n    case msg =>\n      switchActor.state match {\n        case \"happy\" =>\n          println(s\"SwitchActor received message: $msg, I'm happy!\")\n        case \"sad\" =>\n          println(s\"SwitchActor received message: $msg, I'm sad.\")\n        case _ =>\n          println(s\"SwitchActor received unknown message: $msg\")\n      }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SwitchActorApp extends App {\n  val system = ActorSystem(\"SwitchActorSystem\")\n  val switchActor = system.actorOf(Props[SwitchActor](), \"switchActor\")\n\n  // Toggle between states\n  switchActor! \"happy\"\n  switchActor! \"sad\"\n  switchActor! \"happy\"\n  switchActor! \"sad\"\n  switchActor! \"happy\"\n  switchActor! \"sad\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 13,
    "prompt": "Create an Akka Actor in Scala named SelfMessageActor that schedules itself to receive a \"tick\" message every second. Upon receiving a \"tick\", it should print \"Tick received\" and continue scheduling the next tick. Demonstrate the actor's ticking behavior.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport akka.actor.Timers\n\n// Define the SelfMessageActor\nclass SelfMessageActor extends Actor {\n  import context.dispatcher\n\n  // Schedule the next tick\n  val tick: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = 0.seconds,\n    delay = 1.second,\n    receiver = self,\n    message = \"tick\"\n  )\n\n  def receive: Receive = {\n    case \"tick\" =>\n      println(\"Tick received\")\n      // Schedule the next tick\n      tick.schedule()\n    case msg =>\n      println(s\"Received message: $msg\")\n  }\n\n  override def postStop(): Unit = {\n    tick.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelfMessageActorApp extends App {\n  val system = ActorSystem(\"SelfMessageActorSystem\")\n  val self = system.actorOf(Props[SelfMessageActor](), \"selfMessageActor\")\n\n  // Allow some time for ticks before shutdown\n  Thread.sleep(10000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 15,
    "prompt": "Create an Akka Actor in Scala named ResponderActor that listens for Greet(name: String) messages. Upon receiving such a message, it should reply to the sender with \"Hello, <name>!\". Demonstrate sending a Greet message and receiving the response.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Greet(name: String)\ncase class Respond(content: String)\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Greet(name) =>\n      println(s\"ResponderActor received Greet message: $name\")\n      sender()! Respond(s\"Hello, $name!\")\n    case _ =>\n      println(\"ResponderActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ResponderApp extends App {\n  val system = ActorSystem(\"ResponderSystem\")\n  val responder = system.actorOf(Props[ResponderActor](), \"responderActor\")\n\n  // Define a simple responder actor to send messages and receive responses\n  class ResponderActorExt extends Actor {\n    def receive: Receive = {\n      case msg: Respond =>\n        println(s\"ResponderActorExt received response: $msg\")\n      case _ =>\n        println(\"ResponderActorExt received unknown message.\")\n    }\n  }\n\n  val responderExt = system.actorOf(Props[ResponderActorExt](), \"responderExt\")\n\n  // Send a Greet message\n  responderExt! Greet(\"Alice\")\n\n  // Receive the response\n  responderExt! msg\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  }
]