[
  {
    "idx": 0,
    "prompt": "Implement a simple Akka Actor that echoes back any received message to the sender.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the EchoActor\nclass EchoActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"EchoActor received message: $msg from $\\name\")\n  }\n}\n\n// Usage Example\nobject EchoApp extends App {\n  val system = ActorSystem(\"EchoSystem\")\n  val echo = system.actorOf(Props[EchoActor](), \"echoActor\")\n\n  // Define a simple sender actor\n  class SenderActor(name: String) extends Actor {\n    def receive: Receive = {\n      case msg =>\n        echo! msg\n      case _ =>\n        println(s\"SenderActor received unknown message.\")\n    }\n  }\n\n  val sender = system.actorOf(Props(new SenderActor(\"Alice\")), \"senderActor\")\n\n  // Send messages\n  sender! \"Hello\"\n  sender! \"Akka Actors are awesome!\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 2,
    "prompt": "Create an Akka Actor in Scala named LoggingActor that utilizes Akka\u2019s built-in logging facilities to log received messages at different log levels. Messages prefixed with \"info\", \"warn\", or \"error\" should be logged at the corresponding levels. All other messages should be logged at the debug level.",
    "code": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.log.LoggerLevels\nimport scala.concurrent.duration._\n\n// Define the LoggingActor\nclass LoggingActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      val logLevel = msg.toLowerCase match {\n        case \"info\" => LoggerLevels.Info\n        case \"warn\" => LoggerLevels.Warn\n        case \"error\" => LoggerLevels.Error\n        case _ => LoggerLevels.Debug\n      }\n      println(s\"LoggingActor: $msg at $logLevel\")\n    case _ =>\n      println(\"LoggingActor received unknown message.\")\n  }\n}\n\n// Usage Example\nobject LoggingApp extends App {\n  val system = ActorSystem(\"LoggingSystem\")\n  val loggingActor = system.actorOf(Props[LoggingActor](), \"loggingActor\")\n\n  loggingActor! \"User logged in\"\n  loggingActor! \"Warning: Potential issue detected.\"\n  loggingActor! \"Error: Something went wrong.\"\n  loggingActor! \"Debug: LoggingActor is working.\"\n  loggingActor! \"Unknown message.\"\n\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 3,
    "prompt": "Implement an Akka Actor in Scala named StashingActor that stashes incoming messages while waiting for an \"initialize\" message. Once initialized, it should unstash and process all previously stashed messages and handle new messages normally.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Define the StashingActor\nclass StashingActor extends Actor with Stash {\n  def receive: Receive = {\n    case \"initialize\" =>\n      println(\"StashingActor: Initializing...\")\n      unstashAll()\n      case msg =>\n        println(s\"StashingActor received message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject StashingActorApp extends App {\n  val system = ActorSystem(\"StashingActorSystem\")\n  val stashingActor = system.actorOf(Props[StashingActor](), \"stashingActor\")\n\n  // Stash messages\n  stashingActor! \"Message 1\"\n  stashingActor! \"Message 2\"\n  stashingActor! \"Message 3\"\n\n  // Wait for initialization\n  stashingActor! \"initialize\"\n\n  // Process new messages\n  stashingActor! \"New Message 1\"\n  stashingActor! \"New Message 2\"\n  stashingActor! \"New Message 3\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 4,
    "prompt": "Design an Akka Actor in Scala named CircuitBreakerActor that interacts with an unreliable external service. Use Akka\u2019s CircuitBreaker to handle failures gracefully. The actor should attempt to call the external service when it receives a \"callService\" message and respond with either the service's response or an error message if the circuit is open.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, CircuitBreaker}\nimport scala.concurrent.duration._\nimport akka.actor.CircuitBreaker._\n\n// Define messages\ncase object callService\ncase class serviceResponse(content: String)\ncase class serviceError(error: String)\n\n// Define the CircuitBreakerActor\nclass CircuitBreakerActor extends Actor {\n  import context.dispatcher\n\n  val circuitBreaker: ActorRef = context.actorOf(Props[CircuitBreaker](), \"circuitBreakerActor\")\n  circuitBreaker.closure = 5.seconds\n\n  def receive: Receive = {\n    case callService =>\n      circuitBreaker.open()\n      println(s\"${self.path.name} calling external service.\")\n      val future = context.system.scheduler.scheduleOnce(1.second, self, serviceResponse(\"External Service responded!\"))\n      future.onComplete {\n        case Success(serviceResponse(content)) =>\n          self.tell(content, self)\n        case Failure(serviceError(error)) =>\n          self.tell(error, self)\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CircuitBreakerApp extends App {\n  val system = ActorSystem(\"CircuitBreakerSystem\")\n  val circuitBreakerActor = system.actorOf(Props[CircuitBreakerActor](), \"circuitBreakerActor\")\n\n  // Define a simple external service actor for demonstration\n  class ExternalServiceActor extends Actor {\n    def receive: Receive = {\n      case serviceResponse(content) =>\n        println(s\"External ServiceActor received response: $content\")\n      case serviceError(error) =>\n        println(s\"External ServiceActor encountered an error: $error\")\n      case _ =>\n        println(\"External ServiceActor received unknown message.\")\n    }\n  }\n\n  val externalService = system.actorOf(Props[ExternalServiceActor](), \"externalServiceActor\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(8000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 5,
    "prompt": "Implement an Akka Actor using the FSM trait named TrafficLightActor. The actor should have three states: Red, Green, and Yellow. It should transition between these states in the order: Red \u2192 Green \u2192 Yellow \u2192 Red, with each state lasting for a specified duration (e.g., Red for 3 seconds, Green for 2 seconds, Yellow for 1 second). In each state, the actor should print the current state.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport akka.actor.Timers\n\n// Define the TrafficLightActor\nclass TrafficLightActor extends Actor with FSM {\n  import context.dispatcher\n\n  // Define the states\n  case object Red\n  case object Green\n  case object Yellow\n\n  // Define the transitions\n  def receive: Receive = {\n    case Red =>\n      println(\"TrafficLightActor is in state Red.\")\n      context.system.scheduler.scheduleOnce(3.seconds, self, Green)\n    case Green =>\n      println(\"TrafficLightActor is in state Green.\")\n      context.system.scheduler.scheduleOnce(2.seconds, self, Yellow)\n    case Yellow =>\n      println(\"TrafficLightActor is in state Yellow.\")\n      context.system.scheduler.scheduleOnce(1.second, self, Red)\n    case _ =>\n      println(\"TrafficLightActor received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    context.system.scheduler.cancelAll()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TrafficLightApp extends App {\n  val system = ActorSystem(\"TrafficLightSystem\")\n  val light = system.actorOf(Props(new TrafficLightActor()), \"lightActor\")\n\n  light.start()\n}",
    "error": ""
  },
  {
    "idx": 6,
    "prompt": "Create an Akka Actor named PriorityActor that processes messages with a custom priority mailbox. Messages of type HighPriority(msg: String) should be processed before messages of type LowPriority(msg: String), regardless of the order they are received. Implement the custom mailbox and demonstrate its usage.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, Mailbox}\n\n// Define custom messages\ncase class HighPriority(msg: String)\ncase class LowPriority(msg: String)\n\n// Define the PriorityMailbox\nclass PriorityMailbox extends Mailbox {\n  def receive: Receive = {\n    case HighPriority(msg) =>\n      println(s\"Processing High Priority message: $msg\")\n    case LowPriority(msg) =>\n      println(s\"Processing Low Priority message: $msg\")\n  }\n}\n\n// Define the PriorityActor\nclass PriorityActor(mailbox: Mailbox) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      mailbox! msg\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PriorityApp extends App {\n  val system = ActorSystem(\"PrioritySystem\")\n  val priorityMailbox = system.actorOf(Props[Mailbox](), \"priorityMailbox\")\n  val priorityActor = system.actorOf(Props(new PriorityActor(priorityMailbox)), \"priorityActor\")\n\n  // Send messages in mixed order\n  priorityActor! LowPriority(\"Low Priority Message 1\")\n  priorityActor! LowPriority(\"Low Priority Message 2\")\n  priorityActor! HighPriority(\"High Priority Message 1\")\n  priorityActor! HighPriority(\"High Priority Message 2\")\n  priorityActor! LowPriority(\"Low Priority Message 3\")\n  priorityActor! LowPriority(\"Low Priority Message 4\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 7,
    "prompt": "Implement two Akka Actors in Scala named PingActor and PongActor. The PingActor should initiate communication by sending a \"Ping\" message to the PongActor. Upon receiving a \"Ping\", the PongActor should reply with a \"Pong\" message. The PingActor should respond to each \"Pong\" by sending another \"Ping\", creating a continuous ping-pong exchange.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase object Ping\ncase object Pong\n\n// Define the PingActor\nclass PingActor extends Actor {\n  def receive: Receive = {\n    case \"Ping\" =>\n      println(s\"${self.path.name} received Ping. Will respond with Pong.\")\n      sender()! Pong\n    case Pong =>\n      println(s\"${self.path.name} received Pong. Will send next Ping.\")\n      sender()! Ping\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PingPongApp extends App {\n  val system = ActorSystem(\"PingPongSystem\")\n  val pongActor = system.actorOf(Props[PongActor](), \"pongActor\")\n  val pingActor = system.actorOf(Props[PingActor](), \"pingActor\")\n\n  // Start the ping-pong exchange\n  pingActor! Ping\n\n  // Allow some time for response before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 8,
    "prompt": "Create an Akka Actor in Scala named DeadLetterMonitor that listens to the system's dead letters and logs any unhandled messages. Demonstrate sending a message to a non-existent actor and having the DeadLetterMonitor capture it.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.actor.DeadLetterMonitor\n\n// Define the DeadLetterMonitor Actor\nclass DeadLetterMonitor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"DeadLetterMonitor received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DeadLetterMonitorApp extends App {\n  val system = ActorSystem(\"DeadLetterMonitorSystem\")\n  val dlMonitor = system.actorOf(Props[DeadLetterMonitor](), \"deadLetterMonitor\")\n\n  // Send a message to a non-existent actor\n  val nonExistingActor = system.actorOf(Props[_], \"nonExistingActor\")\n  nonExistingActor! \"Hello, World!\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 9,
    "prompt": "Design an Akka Actor in Scala named ParentActor that creates and manages multiple child actors named ChildActor. The ParentActor should forward any received message to all its child actors. Demonstrate the creation of three child actors and sending messages through the ParentActor.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the ChildActor\nclass ChildActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ChildActor [$name] received message: $msg\")\n  }\n}\n\n// Define the ParentActor\nclass ParentActor extends Actor {\n  // Initialize an empty list of child actors\n  val childActors: List[ActorRef] = List.empty\n\n  // Method to add a child actor\n  def addChild(child: ActorRef) = {\n    childActors = childActors :+ child\n  }\n\n  // Method to send a message to all child actors\n  def sendMessage(msg: String) = {\n    childActors.foreach(_! msg)\n  }\n\n  def receive: Receive = {\n    case msg =>\n      sendMessage(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ParentActorApp extends App {\n  val system = ActorSystem(\"ParentActorSystem\")\n  val parent = system.actorOf(Props[ParentActor](), \"parentActor\")\n\n  // Create three child actors\n  val child1 = system.actorOf(Props(new ChildActor(\"Child1\")), \"child1\")\n  val child2 = system.actorOf(Props(new ChildActor(\"Child2\")), \"child2\")\n  val child3 = system.actorOf(Props(new ChildActor(\"Child3\")), \"child3\")\n\n  // Add child actors to the parent\n  parent.addChild(child1)\n  parent.addChild(child2)\n  parent.addChild(child3)\n\n  // Send messages through the parent actor\n  parent! \"Hello Child 1!\"\n  parent! \"Hello Child 2!\"\n  parent! \"Hello Child 3!\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 10,
    "prompt": "Implement an Akka Actor in Scala named SwitchActor that starts in a \"happy\" state. When it receives a \"sad\" message, it switches to a \"sad\" state, and vice versa. In the \"happy\" state, it should respond to any message with \"I'm happy!\", and in the \"sad\" state, it should respond with \"I'm sad.\" Demonstrate toggling between states.",
    "code": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the SwitchActor\nclass SwitchActor extends Actor {\n  def receive: Receive = {\n    case \"sad\" =>\n      println(s\"${self.path.name} is now sad.\")\n      switchState(\"sad\")\n    case \"happy\" =>\n      println(s\"${self.path.name} is now happy.\")\n      switchState(\"happy\")\n    case msg =>\n      println(s\"${self.path.name} received message: $msg\")\n  }\n\n  def switchState(state: String): Unit = {\n    if (self.state!= state) {\n      self.state = state\n      println(s\"${self.path.name} switched to state: $state\")\n    } else {\n      println(s\"${self.path.name} is already in state: $state\")\n    }\n  }\n\n  val state: String = \"happy\"\n}\n\n// Usage Example (for testing purposes)\nobject SwitchActorApp extends App {\n  val system = ActorSystem(\"SwitchActorSystem\")\n  val switchActor = system.actorOf(Props[SwitchActor](), \"switchActor\")\n\n  // Send messages to toggle states\n  switchActor! \"happy\"\n  switchActor! \"sad\"\n  switchActor! \"happy\"\n  switchActor! \"sad\"\n  switchActor! \"happy\"\n  switchActor! \"sad\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 11,
    "prompt": "Create an Akka Actor in Scala named LifecycleActor that logs messages upon starting (preStart) and stopping (postStop). The actor should also handle a \"shutdown\" message to gracefully stop itself. Demonstrate the lifecycle hooks by sending appropriate messages.",
    "code": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the LifecycleActor\nclass LifecycleActor extends Actor {\n  def receive: Receive = {\n    case \"start\" =>\n      println(\"LifecycleActor: Starting\")\n      preStart()\n    case \"shutdown\" =>\n      println(\"LifecycleActor: Shutting down\")\n      postStop()\n    case msg =>\n      println(s\"LifecycleActor received: $msg\")\n  }\n\n  def preStart(): Unit = {\n    println(\"LifecycleActor: Before start\")\n  }\n\n  def postStop(): Unit = {\n    println(\"LifecycleActor: After stop\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LifecycleActorApp extends App {\n  val system = ActorSystem(\"LifecycleActorSystem\")\n  val lifecycleActor = system.actorOf(Props[LifecycleActor](), \"lifecycleActor\")\n\n  // Send messages\n  lifecycleActor! \"start\"\n  lifecycleActor! \"shutdown\"\n  lifecycleActor! \"start\"\n  lifecycleActor! \"shutdown\"\n  lifecycleActor! \"start\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 13,
    "prompt": "Create an Akka Actor in Scala named SelfMessageActor that schedules itself to receive a \"tick\" message every second. Upon receiving a \"tick\", it should print \"Tick received\" and continue scheduling the next tick. Demonstrate the actor's ticking behavior.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport akka.actor.Timers\n\n// Define the Tick message\ncase object Tick\n\n// Define the SelfMessageActor\nclass SelfMessageActor extends Actor {\n  import context.dispatcher\n\n  // Schedule the first tick\n  val tickSender: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = 0.seconds,\n    delay = 1.second,\n    receiver = self,\n    message = Tick\n  )\n\n  def receive: Receive = {\n    case Tick =>\n      println(\"Tick received\")\n      // Schedule the next tick\n      tickSender.scheduleOnce(1.second, self, Tick)\n  }\n\n  override def postStop(): Unit = {\n    tickSender.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelfMessageActorApp extends App {\n  val system = ActorSystem(\"SelfMessageActorSystem\")\n  val self = system.actorOf(Props[SelfMessageActor](), \"selfMessageActor\")\n\n  // Let the actor run for 10 seconds before shutdown\n  Thread.sleep(10000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 16,
    "prompt": "Design an Akka Supervisor Actor in Scala named EscalatingSupervisor that supervises a child actor named FaultyChildActor. The FaultyChildActor throws a NullPointerException when it receives a \"causeNull\" message. Implement the supervisor's strategy to escalate the failure to its own supervisor upon encountering an exception. Demonstrate the supervision hierarchy and failure escalation.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy, Terminated}\nimport akka.actor.SupervisorStrategy._\nimport scala.concurrent.duration._\n\n// Define the ChildActor\nclass FaultyChildActor extends Actor {\n  def receive: Receive = {\n    case \"causeNull\" =>\n      throw new NullPointerException(\"Simulated NullPointerException.\")\n    case msg =>\n      println(s\"ChildActor received: $msg\")\n  }\n}\n\n// Define the EscalatingSupervisor Actor\nclass EscalatingSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(\n    maxNrOfRetries = 3,\n    withinTimeRange = 1.minute\n  ) {\n    case _: NullPointerException =>\n      println(\"EscalatingSupervisor: Encountered NullPointerException. Escaling failure.\")\n      SupervisorStrategy.Escape\n    case _: Exception =>\n      println(\"EscalatingSupervisor: Encountered unknown exception. Escaling failure.\")\n      SupervisorStrategy.Escape\n  }\n\n  // Create the child actor\n  val child: ActorRef = context.actorOf(Props[FaultyChildActor](), \"childActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EscalatingSupervisorApp extends App {\n  val system = ActorSystem(\"EscalatingSupervisorSystem\")\n  val supervisor = system.actorOf(Props[EscalatingSupervisor](), \"supervisor\")\n\n  supervisor! \"Hello\"\n  supervisor! \"causeNull\"\n  supervisor! \"Are you there?\"\n}",
    "error": ""
  }
]