[
  {
    "idx": 0,
    "prompt": "Implement a simple Akka Actor that echoes back any received message to the sender.",
    "code": "import akka.actor.{Actor, ActorSystem, Props}\n\n# Define the EchoActor\nclass EchoActor extends Actor {\n    def receive: Receive = {\n        case msg: String =>\n            println(s\"EchoActor received message: $msg from ${sender().path.name}\")\n        case _ =>\n            println(\"EchoActor received unknown message.\")\n    }\n}\n\n# Usage Example\nif __name__ == \"__main__\":\n    system = ActorSystem(\"EchoSystem\")\n    echo = system.actorOf(Props[EchoActor](), \"echoActor\")\n\n    # Define a simple sender actor to send messages\n    class SenderActor extends Actor {\n        def receive: Receive = {\n            case msg: String =>\n                echo! msg\n            case _ =>\n                println(\"SenderActor received unknown message.\")\n        }\n    }\n\n    sender = system.actorOf(Props[SenderActor](), \"senderActor\")\n\n    # Send messages\n    sender! \"Hello via Akka!\"\n    sender! \"EchoActor received your message!\"\n\n    # Allow some time for processing before shutdown\n    time.sleep(1000)\n    system.terminate()",
    "error": ""
  },
  {
    "idx": 2,
    "prompt": "Create an Akka Actor in Scala named LoggingActor that utilizes Akka\u2019s built-in logging facilities to log received messages at different log levels. Messages prefixed with \"info\", \"warn\", or \"error\" should be logged at the corresponding levels. All other messages should be logged at the debug level.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, LogLevel}\n\n// Define the LoggingActor\nclass LoggingActor extends Actor {\n  override def postStop(): Unit = {\n    super.postStop()\n    Logger.debug(\"LoggingActor stopped.\")\n  }\n\n  def receive: Receive = {\n    case msg: String =>\n      val logLevel = msg.toLowerCaseMatch(\n        \"info\"    => LogLevel.Info,\n        \"warn\"    => LogLevel.Warn,\n        \"error\"   => LogLevel.Error,\n        _ => LogLevel.Debug\n      )\n      Logger.log(logLevel, s\"LoggingActor received message: $msg\")\n    case _ =>\n      Logger.debug(\"LoggingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LoggingApp extends App {\n  val system = ActorSystem(\"LoggingSystem\")\n  val loggingActor = system.actorOf(Props(new LoggingActor()), \"loggingActor\")\n\n  loggingActor! \"Info message\"\n  loggingActor! \"Warn message\"\n  loggingActor! \"Error message\"\n  loggingActor! \"Debug message\"\n  loggingActor! \"Unknown message\"\n\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 3,
    "prompt": "Implement an Akka Actor in Scala named StashingActor that stashes incoming messages while waiting for an \"initialize\" message. Once initialized, it should unstash and process all previously stashed messages and handle new messages normally.",
    "code": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define messages\ncase object Initialize\ncase message\n\n// Define the StashingActor\nclass StashingActor extends Actor {\n  def receive: Receive = {\n    case Initialize =>\n      println(\"StashingActor: Initializing.\")\n      unstash()\n      processQueue()\n    case msg =>\n      println(s\"StashingActor received: $msg\")\n  }\n\n  def processQueue(): Unit = {\n    while (queue.nonEmpty) {\n      val msg = queue.dequeue()\n      println(s\"StashingActor processing queued message: $msg\")\n    }\n  }\n\n  lazy val queue: Queue[Message] = Queue.empty\n\n  def!msg: Unit = {\n    queue.enqueue(msg)\n  }\n}\n\n// Usage Example\nobject StashingActorApp extends App {\n  val system = ActorSystem(\"StashingActorSystem\")\n  val stashingActor = system.actorOf(Props[StashingActor](), \"stashingActor\")\n\n  // Send messages while stashed\n  stashingActor! \"Message 1\"\n  stashingActor! \"Message 2\"\n  stashingActor! \"Message 3\"\n\n  // Send the initialize message\n  stashingActor! Initialize\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 4,
    "prompt": "Design an Akka Actor in Scala named CircuitBreakerActor that interacts with an unreliable external service. Use Akka\u2019s CircuitBreaker to handle failures gracefully. The actor should attempt to call the external service when it receives a \"callService\" message and respond with either the service's response or an error message if the circuit is open.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, CircuitBreaker}\nimport scala.concurrent.duration._\nimport akka.actor.CircuitBreaker._\n\nimport externalService ==>\"ExternalService\"\n\n// Define messages\ncase object callService\ncase class serviceResponse(content: String)\ncase class serviceError(error: String)\n\n// Define the CircuitBreakerActor\nclass CircuitBreakerActor extends Actor with CircuitBreaker {\n  import context.dispatcher\n\n  // Initialize the circuit breaker\n  circuitBreaker\uff1a_open = false\n  recentFailures\uff1aSeq[ActorRef] = Seq.empty\n\n  def receive: Receive = {\n    case \"callService\" =>\n      if (!circuitBreaker_:open) {\n        val service = context.actorOf(Props(new ExternalService()), \"service\")\n        println(s\"CircuitBreakerActor: Calling external service.\")\n        val future = service?', serviceResponse)\n        future.onComplete {\n          case Success(serviceResponse) =>\n            sender()! serviceResponse\n          case Failure(serviceError) =>\n            sender()! serviceError\n        }\n      } else {\n        println(s\"CircuitBreakerActor: Service is unavailable. Circuit is open.\")\n        sender()! serviceError(\"Service unavailable.\")\n      }\n    case _ =>\n      println(\"CircuitBreakerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CircuitBreakerApp extends App {\n  val system = ActorSystem(\"CircuitBreakerSystem\")\n  val circuitBreaker = system.actorOf(Props(new CircuitBreakerActor()), \"circuitBreakerActor\")\n\n  // Define a simple responder actor to handle responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case serviceResponse =>\n        println(s\"ResponderActor: Service response = $serviceResponse\")\n      case serviceError =>\n        println(s\"ResponderActor: Service error = $serviceError\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Call the service\n  circuitBreaker! callService\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 5,
    "prompt": "Implement an Akka Actor using the FSM trait named TrafficLightActor. The actor should have three states: Red, Green, and Yellow. It should transition between these states in the order: Red \u2192 Green \u2192 Yellow \u2192 Red, with each state lasting for a specified duration (e.g., Red for 3 seconds, Green for 2 seconds, Yellow for 1 second). In each state, the actor should print the current state.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport akka.actor.Timers\n\n// Define the TrafficLightActor\nclass TrafficLightActor extends Actor with FSM {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case \"start\" =>\n      println(\"TrafficLightActor: Transitioning to Red.\")\n      context.system.scheduler.scheduleOnce(3.seconds, self, \"green\")\n    case \"green\" =>\n      println(\"TrafficLightActor: Transitioning to Yellow.\")\n      context.system.scheduler.scheduleOnce(2.seconds, self, \"red\")\n    case \"yellow\" =>\n      println(\"TrafficLightActor: Transitioning to Red.\")\n      context.system.scheduler.scheduleOnce(1.second, self, \"green\")\n    case _ =>\n      println(\"TrafficLightActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TrafficLightApp extends App {\n  val system = ActorSystem(\"TrafficLightSystem\")\n  val trafficLight = system.actorOf(Props(new TrafficLightActor()), \"trafficLightActor\")\n\n  // Start the traffic light\n  trafficLight! \"start\"\n\n  // Allow some time for each state before shutdown\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 6,
    "prompt": "Create an Akka Actor named PriorityActor that processes messages with a custom priority mailbox. Messages of type HighPriority(msg: String) should be processed before messages of type LowPriority(msg: String), regardless of the order they are received. Implement the custom mailbox and demonstrate its usage.",
    "code": "import akka.actor.{Actor, ActorSystem, Props, Mailbox}\n\n// Define messages\ncase class HighPriority(msg: String)\ncase class LowPriority(msg: String)\n\n// Define the Custom Mailbox\nclass PriorityMailbox extends Mailbox {\n  def receive: Receive = {\n    case HighPriority(msg) =>\n      println(s\"High Priority message: $msg\")\n    case LowPriority(msg) =>\n      println(s\"Low Priority message: $msg\")\n    case msg =>\n      println(s\"Unknown message: $msg\")\n  }\n}\n\n// Define the PriorityActor\nclass PriorityActor extends Actor {\n  override val mailbox: Mailbox = PriorityMailbox()\n\n  def receive: Receive = {\n    case msg =>\n      mailbox.receive(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PriorityApp extends App {\n  val system = ActorSystem(\"PrioritySystem\")\n  val priorityActor = system.actorOf(Props[PriorityActor](), \"priorityActor\")\n\n  // Send messages in mixed order\n  priorityActor! LowPriority(\"Welcome\")\n  priorityActor! HighPriority(\"Hello\")\n  priorityActor! LowPriority(\"World\")\n  priorityActor! HighPriority(\"Akkademia\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 8,
    "prompt": "Create an Akka Actor in Scala named DeadLetterMonitor that listens to the system's dead letters and logs any unhandled messages. Demonstrate sending a message to a non-existent actor and having the DeadLetterMonitor capture it.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.actor.DeadLetterMonitor\n\n// Define a simple actor that will fail to handle messages\nclass FailureActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"FailureActor received message: $msg\")\n    case \"_fail\" => println(\"FailureActor received special message.\")\n  }\n}\n\n// Define the DeadLetterMonitor Actor\nclass DeadLetterMonitor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"DeadLetterMonitor received unknown message: $msg\")\n    case \"_fail\" =>\n      println(\"DeadLetterMonitor received special message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DeadLetterMonitorApp extends App {\n  val system = ActorSystem(\"DeadLetterMonitorSystem\")\n  val dlMonitor = system.actorOf(Props[DeadLetterMonitor](), \"dlMonitor\")\n\n  // Create a simple actor that fails to handle messages\n  val failureActor = system.actorOf(Props[FailureActor](), \"failureActor\")\n\n  // Send a message to the non-existent actor\n  dlMonitor! \"Hello, world!\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 9,
    "prompt": "Design an Akka Actor in Scala named ParentActor that creates and manages multiple child actors named ChildActor. The ParentActor should forward any received message to all its child actors. Demonstrate the creation of three child actors and sending messages through the ParentActor.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the ChildActor\nclass ChildActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ChildActor [$name] received message: $msg\")\n  }\n}\n\n// Define the ParentActor\nclass ParentActor extends Actor {\n  var children: Set[ActorRef] = Set.empty\n\n  def receive: Receive = {\n    case msg =>\n      children.foreach(_! msg)\n  }\n\n  def addChild(child: ActorRef): Unit = {\n    children += child\n  }\n\n  def removeChild(child: ActorRef): Unit = {\n    children -= child\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ParentChildApp extends App {\n  val system = ActorSystem(\"ParentChildSystem\")\n  val parent = system.actorOf(Props(new ParentActor()), \"parentActor\")\n\n  // Create child actors\n  val child1 = system.actorOf(Props(new ChildActor(\"Child1\")), \"child1\")\n  val child2 = system.actorOf(Props(new ChildActor(\"Child2\")), \"child2\")\n  val child3 = system.actorOf(Props(new ChildActor(\"Child3\")), \"child3\")\n\n  // Add child actors to the parent\n  parent.addChild(child1)\n  parent.addChild(child2)\n  parent.addChild(child3)\n\n  // Send messages through the parent\n  parent! \"Hello Child 1!\"\n  parent! \"Hello Child 2!\"\n  parent! \"Hello Child 3!\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 10,
    "prompt": "Implement an Akka Actor in Scala named SwitchActor that starts in a \"happy\" state. When it receives a \"sad\" message, it switches to a \"sad\" state, and vice versa. In the \"happy\" state, it should respond to any message with \"I'm happy!\", and in the \"sad\" state, it should respond with \"I'm sad.\" Demonstrate toggling between states.",
    "code": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the SwitchActor\nclass SwitchActor extends Actor {\n  def active: Receive = {\n    case \"sad\" =>\n      println(s\"${self.path.name} switched to sad state.\")\n      state = \"sad\")\n    case msg =>\n      println(s\"${self.path.name} received message: $msg\")\n  }\n\n  def state: String = \"happy\"\n\n  def!msg: Unit = active(msg)\n\n  override def postStop(): Unit = {\n    state = \"happy\"\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SwitchApp extends App {\n  val system = ActorSystem(\"SwitchSystem\")\n  val switchActor = system.actorOf(Props[SwitchActor](), \"switchActor\")\n\n  // Switch to sad state\n  switchActor! \"sad\"\n  switchActor! \"I'm happy!\" // Should print \"I'm sad.\"\n\n  // Switch to happy state\n  switchActor! \"happy\"\n  switchActor! \"I'm happy!\" // Should print \"I'm happy.\"\n\n  // Switch back to sad state\n  switchActor! \"sad\"\n  switchActor! \"I'm happy!\" // Should print \"I'm sad.\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}",
    "error": ""
  },
  {
    "idx": 16,
    "prompt": "Design an Akka Supervisor Actor in Scala named EscalatingSupervisor that supervises a child actor named FaultyChildActor. The FaultyChildActor throws a NullPointerException when it receives a \"causeNull\" message. Implement the supervisor's strategy to escalate the failure to its own supervisor upon encountering an exception. Demonstrate the supervision hierarchy and failure escalation.",
    "code": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy, Terminated}\nimport akka.actor.SupervisorStrategy._\n\nimport scala.concurrent.duration._\n\n// Define the ChildActor\nclass FaultyChildActor extends Actor {\n  def receive: Receive = {\n    case \"causeNull\" =>\n      throw new NullPointerException(\"ChildActor received null cause.\")\n    case msg =>\n      println(s\"ChildActor received message: $msg\")\n  }\n}\n\n// Define the EscalatingSupervisor Actor\nclass EscalatingSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(\n    maxNrOfRetries = 3,\n    withinTimeRange = 1.minute\n  ) {\n    case _: NullPointerException =>\n      println(\"EscalatingSupervisor: Encountered NullPointerException. Escalating failure.\")\n      SupervisorStrategy.Escape\n    case _: Exception =>\n      SupervisorStrategy.None\n  }\n\n  // Create the child actor\n  val child: ActorRef = context.actorOf(Props[FaultyChildActor](), \"childActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EscalatingSupervisorApp extends App {\n  val system = ActorSystem(\"EscalatingSupervisorSystem\")\n  val supervisor = system.actorOf(Props[EscalatingSupervisor](), \"supervisor\")\n\n  supervisor! \"causeNull\"\n  supervisor! \"Post-null message\"\n}",
    "error": ""
  }
]