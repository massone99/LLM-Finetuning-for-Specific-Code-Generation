[
    {
        "idx": 0,
        "prompt": "Implement an Akka Typed actor in Scala that simulates a worker which occasionally fails. Use a backoff supervision strategy to automatically restart the worker with an exponential backoff delay. Demonstrate sending messages to the worker actor and observe how it recovers from failures.",
        "code": "import akka.actor.typed.{ActorRef, ActorSystem, Behavior, SupervisorStrategy}\nimport akka.actor.typed.scaladsl.Behaviors\nimport scala.util.Random\nimport scala.concurrent.duration._\n\nobject FlakyWorker {\n  // Protocol for the FlakyWorker\n  sealed trait Command\n  final case class DoWork(replyTo: ActorRef[String]) extends Command\n  case object Fail extends Command\n\n  def apply(): Behavior[Command] = Behaviors.receive { (context, message) =>\n    message match {\n      case DoWork(replyTo) =>\n        // Simulate random success or failure\n        if (Random.nextBoolean()) {\n          context.log.info(\"FlakyWorker: Work succeeded\")\n          replyTo ! \"Work completed successfully\"\n          Behaviors.same\n        } else {\n          context.log.info(\"FlakyWorker: Work failed, throwing exception\")\n          throw new RuntimeException(\"Simulated failure\")\n        }\n      case Fail =>\n        context.log.info(\"FlakyWorker: Received Fail command, throwing exception\")\n        throw new RuntimeException(\"Forced failure\")\n    }\n  }\n}\n\nobject WorkerSupervisor {\n  def apply(): Behavior[FlakyWorker.Command] = {\n    // Supervise the FlakyWorker using exponential backoff on failure\n    Behaviors.supervise(FlakyWorker())\n      .onFailure[RuntimeException](SupervisorStrategy.restartWithBackoff(1.second, 10.seconds, 0.2))\n  }\n}\n\nobject WorkerApp extends App {\n  // Initialize the actor system with the supervised behavior\n  val system: ActorSystem[FlakyWorker.Command] = ActorSystem(WorkerSupervisor(), \"WorkerSystem\")\n\n  // Create a simple reply actor to receive responses\n  val replyActor: ActorRef[String] = system.systemActorOf(\n    Behaviors.receiveMessage[String] { msg =>\n      println(s\"Reply received: $msg\")\n      Behaviors.same\n    }, \"replyActor\"\n  )\n\n  // Send a work request\n  system ! FlakyWorker.DoWork(replyActor)\n  \n  // Force a failure\n  system ! FlakyWorker.Fail\n\n  // Schedule another work request after 5 seconds\n  import system.executionContext\n  system.scheduler.scheduleOnce(5.seconds) {\n    system ! FlakyWorker.DoWork(replyActor)\n  }\n\n  Thread.sleep(15000)\n  system.terminate()\n}",
        "error_output": "STDOUT:\n[info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 21.0.6)\n[info] loading settings for project akka_placeholder-build-build from metals.sbt ...\n[info] loading project definition from /home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/project/project\n[info] loading settings for project akka_placeholder-build from metals.sbt ...\n[info] loading project definition from /home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/project\n[success] Generated .bloop/akka_placeholder-build.json\n[success] Total time: 1 s, completed 10 feb 2025, 17:15:09\n[info] loading settings for project root from build.sbt ...\n[info] set current project to akka_placeholder (in build file:/home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/)\n[info] compiling 1 Scala source to /home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/target/scala-3.5.2/classes ...\n[error] -- [E134] Type Error: /home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/src/main/scala/Main.scala:59:19 \n[error] 59 |  system.scheduler.scheduleOnce(5.seconds) {\n[error]    |  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[error]    |None of the overloaded alternatives of method scheduleOnce in trait Scheduler with types\n[error]    | (delay: java.time.Duration, runnable: Runnable, executor:\n[error]    |  scala.concurrent.ExecutionContext): akka.actor.Cancellable\n[error]    | (delay: scala.concurrent.duration.FiniteDuration, runnable: Runnable)\n[error]    |  (implicit executor: scala.concurrent.ExecutionContext): akka.actor.Cancellable\n[error]    |match arguments ((scala.concurrent.duration.DurationInt#seconds :\n[error]    |  => scala.concurrent.duration.FiniteDuration))\n[error] one error found\n[error] (Compile / compileIncremental) Compilation failed\n[error] Total time: 2 s, completed 10 feb 2025, 17:15:12\n\nSTDERR:\n",
        "error_cause": "STDERR:"
    },
    {
        "idx": 1,
        "prompt": "Develop an Akka Persistence Typed actor in Scala that logs messages persistently. The actor should handle LogMessage and GetHistory commands, persisting each message. Upon receiving GetHistory, it should reply with all stored messages. Demonstrate persisting a few messages and retrieving the history.",
        "code": "import akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.persistence.typed.PersistenceId\nimport akka.persistence.typed.scaladsl.{Effect, EventSourcedBehavior}\nimport akka.actor.typed.scaladsl.Behaviors\nimport scala.concurrent.duration._\n\nobject LoggerPersistentActor {\n  // Commands\n  sealed trait Command\n  final case class LogMessage(message: String, replyTo: ActorRef[Ack]) extends Command\n  final case class GetHistory(replyTo: ActorRef[History]) extends Command\n\n  sealed trait Ack\n  case object Logged extends Ack\n\n  // Events\n  sealed trait Event\n  final case class MessageLogged(message: String) extends Event\n\n  // State\n  final case class State(messages: List[String] = Nil) {\n    def updated(event: Event): State = event match {\n      case MessageLogged(msg) => messages :+ msg\n    }\n  }\n\n  final case class History(messages: List[String])\n\n  def apply(entityId: String): Behavior[Command] =\n    EventSourcedBehavior[Command, Event, State](\n      persistenceId = PersistenceId.ofUniqueId(entityId),\n      emptyState = State(),\n      commandHandler = (state, command) => command match {\n        case LogMessage(message, replyTo) =>\n          Effect.persist(MessageLogged(message)).thenRun { _ =>\n            replyTo ! Logged\n          }\n        case GetHistory(replyTo) =>\n          replyTo ! History(state.messages)\n          Effect.none\n      },\n      eventHandler = (state, event) => state.updated(event)\n    )\n}\n\nobject LoggerPersistentApp extends App {\n  val system: ActorSystem[LoggerPersistentActor.Command] =\n    ActorSystem(LoggerPersistentActor(\"logger-1\"), \"PersistentLoggerSystem\")\n\n  // Create an ack receiver actor\n  val ackReceiver: ActorRef[LoggerPersistentActor.Ack] =\n    system.systemActorOf(\n      Behaviors.receiveMessage[LoggerPersistentActor.Ack] { ack =>\n        println(\"Ack received\")\n        Behaviors.same\n      },\n      \"ackReceiver\"\n    )\n\n  // Create a history receiver actor\n  val historyReceiver: ActorRef[LoggerPersistentActor.History] =\n    system.systemActorOf(\n      Behaviors.receiveMessage[LoggerPersistentActor.History] { history =>\n        println(s\"History: ${history.messages.mkString(\", \")}\")\n        Behaviors.same\n      },\n      \"historyReceiver\"\n    )\n\n  // Send log messages\n  system ! LoggerPersistentActor.LogMessage(\"First log message\", ackReceiver)\n  system ! LoggerPersistentActor.LogMessage(\"Second log message\", ackReceiver)\n\n  // Request history after a delay\n  import system.executionContext\n  system.scheduler.scheduleOnce(3.seconds) {\n    system ! LoggerPersistentActor.GetHistory(historyReceiver)\n  }\n\n  Thread.sleep(5000)\n  system.terminate()\n}",
        "error_output": "STDOUT:\n[info] welcome to sbt 1.10.5 (Eclipse Adoptium Java 21.0.6)\n[info] loading settings for project akka_placeholder-build-build from metals.sbt ...\n[info] loading project definition from /home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/project/project\n[info] loading settings for project akka_placeholder-build from metals.sbt ...\n[info] loading project definition from /home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/project\n[success] Generated .bloop/akka_placeholder-build.json\n[success] Total time: 1 s, completed 10 feb 2025, 17:15:16\n[info] loading settings for project root from build.sbt ...\n[info] set current project to akka_placeholder (in build file:/home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/)\n[info] compiling 1 Scala source to /home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/target/scala-3.5.2/classes ...\n[error] -- [E007] Type Mismatch Error: /home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/src/main/scala/Main.scala:25:33 \n[error] 25 |      case MessageLogged(msg) => messages :+ msg\n[error]    |                                 ^^^^^^^^^^^^^^^\n[error]    |                                 Found:    List[String]\n[error]    |                                 Required: LoggerPersistentActor.State\n[error]    |\n[error]    | longer explanation available when compiling with `-explain`\n[error] -- [E134] Type Error: /home/lorix/Documenti/uni/tesi/finetuning-llama3.2-scala-for-dsl/build_checker/res/akka_placeholder/src/main/scala/Main.scala:78:19 \n[error] 78 |  system.scheduler.scheduleOnce(3.seconds) {\n[error]    |  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[error]    |None of the overloaded alternatives of method scheduleOnce in trait Scheduler with types\n[error]    | (delay: java.time.Duration, runnable: Runnable, executor:\n[error]    |  scala.concurrent.ExecutionContext): akka.actor.Cancellable\n[error]    | (delay: scala.concurrent.duration.FiniteDuration, runnable: Runnable)\n[error]    |  (implicit executor: scala.concurrent.ExecutionContext): akka.actor.Cancellable\n[error]    |match arguments ((scala.concurrent.duration.DurationInt#seconds :\n[error]    |  => scala.concurrent.duration.FiniteDuration))\n[error] two errors found\n[error] (Compile / compileIncremental) Compilation failed\n[error] Total time: 3 s, completed 10 feb 2025, 17:15:20\n\nSTDERR:\n",
        "error_cause": "STDERR:"
    }
]