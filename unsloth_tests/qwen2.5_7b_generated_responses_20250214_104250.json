[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement a simple Akka Actor that echoes back any received message to the sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the EchoActor\nclass EchoActor extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! s\"Echo: $msg\"\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EchoApp extends App {\n  val system = ActorSystem(\"EchoSystem\")\n  val echoActor = system.actorOf(Props[EchoActor](), \"echoActor\")\n\n  echoActor.tell(\"Hello, Akka!\", echoActor)\n  echoActor.tell(\"This is a test.\", echoActor)\n\n  Thread.sleep(500)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an \"Hello World\" example using Akka Actors"
      },
      {
        "from": "assistant",
        "value": "// HelloWorldActor.scala\nimport akka.actor.{Actor, ActorSystem, Props}\n\nclass HelloWorldActor extends Actor {\n  def receive: Receive = {\n    case \"hello\" => println(\"Hello World!\")\n    case _ => println(\"Unknown message\")\n  }\n}\n\nobject HelloWorldActorApp extends App {\n  val system = ActorSystem(\"HelloWorldSystem\")\n  val actor = system.actorOf(Props[HelloWorldActor](), \"helloWorldActor\")\n  actor ! \"hello\"\n  Thread.sleep(500)\n  system.terminate()\n}\n<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named LoggingActor that utilizes Akka’s built-in logging facilities to log received messages at different log levels. Messages prefixed with \"info\", \"warn\", or \"error\" should be logged at the corresponding levels. All other messages should be logged at the debug level."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.event.Logging\n\nclass LoggingActor extends Actor {\n  val log = Logging(context.system, this)\n\n  def receive: Receive = {\n    case msg: String if msg.startsWith(\"info\") => log.info(msg)\n    case msg: String if msg.startsWith(\"warn\") => log.warning(msg)\n    case msg: String if msg.startsWith(\"error\") => log.error(msg)\n    case msg: String => log.debug(msg)\n    case _ => log.debug(\"LoggingActor: Unknown message\")\n  }\n}\n\nobject LoggingActorApp extends App {\n  val system = ActorSystem(\"LoggingSystem\")\n  val actor = system.actorOf(Props[LoggingActor](), \"loggingActor\")\n\n  actor ! \"info: This is an informational message\"\n  actor ! \"warn: This is a warning message\"\n  actor ! \"error: This is an error message\"\n  actor ! \"debug: This is a debug message\"\n  actor ! \"unknown: This is an unknown message\"\n\n  Thread.sleep(500)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named StashingActor that stashes incoming messages while waiting for an \"initialize\" message. Once initialized, it should unstash and process all previously stashed messages and handle new messages normally."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Define the messages\ncase class Initialize()\ncase class ProcessData(data: String)\n\n// Define the StashingActor\nclass StashingActor extends Actor with Stash {\n  override def preStart(): Unit = {\n    // Stash all incoming messages until initialization\n    stash()\n  }\n\n  def receive: Receive = {\n    case Initialize =>\n      // Unstash all messages when initialized\n      unstashAll()\n      println(\"StashingActor: Initialized, unstash all messages.\")\n    case ProcessData(data) =>\n      // Process data after initialization\n      println(s\"StashingActor: Processing data - $data\")\n    case msg =>\n      // Stash all other messages until initialization\n      println(s\"StashingActor: Stashing message - $msg\")\n      stash()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject StashingApp extends App {\n  val system = ActorSystem(\"StashingSystem\")\n  val stashingActor = system.actorOf(Props[StashingActor](), \"stashingActor\")\n\n  // Send some messages before initialization\n  stashingActor ! \"Data1\"\n  stashingActor ! \"Data2\"\n  stashingActor ! \"Data3\"\n\n  // Initialize the actor\n  stashingActor ! Initialize\n\n  // Send more messages after initialization\n  stashingActor ! ProcessData(\"Data4\")\n  stashingActor ! ProcessData(\"Data5\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named CircuitBreakerActor that interacts with an unreliable external service. Use Akka’s CircuitBreaker to handle failures gracefully. The actor should attempt to call the external service when it receives a \"callService\" message and respond with either the service's response or an error message if the circuit is open."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.CircuitBreaker\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define the external service response\ncase class ServiceResponse(data: String)\n\n// Define the CircuitBreakerActor\nclass CircuitBreakerActor extends Actor {\n  // Create a circuit breaker with a timeout of 1 second and a max failure threshold of 3\n  val breaker = new CircuitBreaker(\n    context.system.scheduler,\n    maxFailures = 3,\n    callTimeout = 1.second,\n    resetTimeout = 5.seconds\n  )\n\n  def receive: Receive = {\n    case \"callService\" =>\n      // Attempt to call the external service\n      breaker.withCircuitBreaker {\n        // Simulate an external service call\n        val future = scala.concurrent.Future {\n          // Simulate a failure after 2 attempts\n          if (context.system.scheduler.now().getMillis % 1000 < 500) {\n            ServiceResponse(\"Service data\")\n          } else {\n            throw new Exception(\"External service failed\")\n          }\n        }\n        future.onComplete {\n          case scala.util.Success(response) =>\n            println(s\"CircuitBreakerActor: External service responded with: ${response.data}\")\n            sender() ! response\n          case scala.util.Failure(ex) =>\n            println(s\"CircuitBreakerActor: External service call failed: ${ex.getMessage}\")\n            sender() ! \"External service call failed\"\n        }\n      }\n    case msg =>\n      println(s\"CircuitBreakerActor received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CircuitBreakerApp extends App {\n  val system = ActorSystem(\"CircuitBreakerSystem\")\n  val actor = system.actorOf(Props[CircuitBreakerActor](), \"circuitBreakerActor\")\n\n  // Send multiple \"callService\" messages to demonstrate circuit breaker behavior\n  for (i <- 1 to 5) {\n    actor ! \"callService\"\n  }\n\n  Thread.sleep(1000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor using the FSM trait named TrafficLightActor. The actor should have three states: Red, Green, and Yellow. It should transition between these states in the order: Red → Green → Yellow → Red, with each state lasting for a specified duration (e.g., Red for 3 seconds, Green for 2 seconds, Yellow for 1 second). In each state, the actor should print the current state."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, FSM}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase object Tick\n\nclass TrafficLightActor extends FSM[String, Unit] {\n  startWith(\"Red\", 0)\n\n  when(\"Red\") {\n    stateTimeout = 3.seconds\n    onTransition {\n      case \"Red\" => println(\"TrafficLightActor: Transitioned to Red\")\n    }\n    onTransition {\n      case \"Green\" => println(\"TrafficLightActor: Transitioned to Green\")\n    }\n    onTransition {\n      case \"Yellow\" => println(\"TrafficLightActor: Transitioned to Yellow\")\n    }\n    onTransition {\n      case \"Red\" => println(\"TrafficLightActor: Transitioned back to Red\")\n    }\n    onTransition {\n      case \"Green\" => println(\"TrafficLightActor: Transitioned back to Green\")\n    }\n    onTransition {\n      case \"Yellow\" => println(\"TrafficLightActor: Transitioned back to Yellow\")\n    }\n    onTransition {\n      case \"Red\" => println(\"TrafficLightActor: Transitioned back to Red\")\n    }\n    onTransition {\n      case \"Green\" => println(\"TrafficLightActor: Transitioned back to Green\")\n    }\n    onTransition {\n      case \"Yellow\" => println(\"TrafficLightActor: Transitioned back to Yellow\")\n    }\n    onTransition {\n      case \"Red\" => println(\"TrafficLightActor: Transitioned back to Red\")\n    }\n    onTransition {\n      case \"Green\" => println(\"TrafficLightActor: Transitioned back to Green\")\n    }\n    onTransition {\n      case \"Yellow\" => println(\"TrafficLightActor: Transitioned back to Yellow\")\n    }\n    onTransition {\n      case \"Red\" => println(\"TrafficLightActor: Transitioned back to Red\")\n    }\n    onTransition {\n      case \"Green\" => println(\"TrafficLightActor: Transitioned back to Green\")\n    }\n    onTransition {\n      case \"Yellow\" => println(\"TrafficLightActor: Transitioned back to Yellow\")\n    }\n    onTransition {\n      case \"Red\" => println(\"TrafficLightActor: Transitioned back to Red\")\n    }\n    onTransition {\n      case \"Green\" => println(\"TrafficLightActor: Transitioned back to Green\")\n    }\n    onTransition {\n      case \"Yellow\" => println(\"TrafficLightActor: Transitioned back to Yellow\")\n    }\n    onTransition {\n      case \"Red\" => println(\"TrafficLightActor: Transition"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor named PriorityActor that processes messages with a custom priority mailbox. Messages of type HighPriority(msg: String) should be processed before messages of type LowPriority(msg: String), regardless of the order they are received. Implement the custom mailbox and demonstrate its usage."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, Stash}\nimport akka.dispatch.BoundedMailbox\nimport scala.concurrent.duration._\n\n// Define message types\ncase class HighPriority(msg: String)\ncase class LowPriority(msg: String)\n\n// Define the custom mailbox\nclass PriorityMailbox(settings: akka.actor.Settings) extends BoundedMailbox(settings) {\n  override def createMailbox(name: String, system: akka.actor.ExtendedActorSystem): akka.actor.Mailbox = {\n    new PriorityMailboxActor(system)\n  }\n}\n\n// Define the custom mailbox actor\nclass PriorityMailboxActor(system: akka.actor.ExtendedActorSystem) extends akka.actor.BoundedMailbox(system) {\n  override def createMailbox(name: String, system: akka.actor.ExtendedActorSystem): akka.actor.Mailbox = {\n    new PriorityMailboxActor(system)\n  }\n\n  override def preStart(): Unit = {\n    println(\"PriorityMailboxActor: Pre-start\")\n    super.preStart()\n  }\n\n  override def postStop(): Unit = {\n    println(\"PriorityMailboxActor: Post-stop\")\n    super.postStop()\n  }\n\n  override def preRestart(reason: Throwable, message: Option[Any]): Unit = {\n    println(s\"PriorityMailboxActor: Pre-restart due to ${reason.getMessage}\")\n    super.preRestart(reason, message)\n  }\n\n  override def postRestart(reason: Throwable): Unit = {\n    println(s\"PriorityMailboxActor: Post-restart due to ${reason.getMessage}\")\n    super.postRestart(reason)\n  }\n}\n\n// Define the PriorityActor\nclass PriorityActor extends Actor {\n  // Use the custom mailbox\n  context.setMailbox(\"priorityMailbox\")\n\n  def receive: Receive = {\n    case HighPriority(msg) =>\n      println(s\"PriorityActor: Processing high-priority message: $msg\")\n    case LowPriority(msg) =>\n      println(s\"PriorityActor: Processing low-priority message: $msg\")\n    case _ =>\n      println(\"PriorityActor: Unknown message\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PriorityApp extends App {\n  val system = ActorSystem(\"PrioritySystem\")\n  val priorityActor = system.actorOf(Props[PriorityActor](), \"priorityActor\")\n\n  // Send high-priority message\n  priorityActor ! HighPriority(\"High Priority Message\")\n  // Send low-priority message\n  priorityActor ! LowPriority(\"Low Priority Message\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement two Akka Actors in Scala named PingActor and PongActor. The PingActor should initiate communication by sending a \"Ping\" message to the PongActor. Upon receiving a \"Ping\", the PongActor should reply with a \"Pong\" message. The PingActor should respond to each \"Pong\" by sending another \"Ping\", creating a continuous ping-pong exchange."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define messages\ncase object Ping\ncase object Pong\n\n// Define the PingActor\nclass PingActor extends Actor {\n  def receive: Receive = {\n    case Ping =>\n      println(\"PingActor: Received Ping, sending Pong\")\n      sender() ! Pong\n    case _ =>\n      println(\"PingActor: Unknown message\")\n  }\n}\n\n// Define the PongActor\nclass PongActor extends Actor {\n  def receive: Receive = {\n    case Pong =>\n      println(\"PongActor: Received Pong, sending Ping\")\n      sender() ! Ping\n    case _ =>\n      println(\"PongActor: Unknown message\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PingPongApp extends App {\n  val system = ActorSystem(\"PingPongSystem\")\n  val pingActor = system.actorOf(Props[PingActor](), \"pingActor\")\n  val pongActor = system.actorOf(Props[PongActor](), \"pongActor\")\n\n  // Start the ping-pong exchange\n  pingActor ! Ping\n\n  // Allow some time for the exchange before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named DeadLetterMonitor that listens to the system's dead letters and logs any unhandled messages. Demonstrate sending a message to a non-existent actor and having the DeadLetterMonitor capture it."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.event.Logging\nimport akka.actor.SupervisorStrategy.{Resume, Stop}\nimport akka.actor.OneForOneStrategy\n\n// Define a simple message\ncase class Greet(name: String)\n\n// Define an actor that will not handle the Greet message\nclass NonHandlerActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"NonHandlerActor received: $msg\")\n  }\n}\n\n// Define the DeadLetterMonitor actor\nclass DeadLetterMonitor extends Actor {\n  val log = Logging(context.system, this)\n  def receive: Receive = {\n    case msg => log.info(s\"DeadLetterMonitor: Received dead letter: $msg\")\n  }\n}\n\n// Define a supervisor strategy that logs and resumes\nclass SupervisorStrategyActor extends Actor {\n  val child: ActorRef = context.actorOf(Props[NonHandlerActor](), \"nonHandler\")\n  def receive: Receive = {\n    case msg => child.forward(msg)\n  }\n  override val supervisorStrategy = OneForOneStrategy(maxNrOfRetries = 3, withinTimeRange = 1.minute) {\n    case _: IllegalArgumentException => Resume\n  }\n}\n\nobject DeadLetterMonitorApp extends App {\n  val system = ActorSystem(\"DeadLetterSystem\")\n  val monitor = system.actorOf(Props[DeadLetterMonitor](), \"deadLetterMonitor\")\n  val supervisor = system.actorOf(Props[SupervisorStrategyActor](), \"supervisorStrategyActor\")\n\n  // Send a message to the non-existent actor\n  supervisor ! Greet(\"Akka\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named ParentActor that creates and manages multiple child actors named ChildActor. The ParentActor should forward any received message to all its child actors. Demonstrate the creation of three child actors and sending messages through the ParentActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the ChildActor\nclass ChildActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"ChildActor[$name] received: $msg\")\n  }\n}\n\n// Define the ParentActor\nclass ParentActor extends Actor {\n  // Create child actors\n  val child1: ActorRef = context.actorOf(Props(new ChildActor(\"Child1\")), \"child1\")\n  val child2: ActorRef = context.actorOf(Props(new ChildActor(\"Child2\")), \"child2\")\n  val child3: ActorRef = context.actorOf(Props(new ChildActor(\"Child3\")), \"child3\")\n\n  def receive: Receive = {\n    case msg => {\n      // Forward the message to all child actors\n      child1 ! msg\n      child2 ! msg\n      child3 ! msg\n    }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ParentChildApp extends App {\n  val system = ActorSystem(\"ParentChildSystem\")\n  val parent = system.actorOf(Props[ParentActor](), \"parentActor\")\n\n  // Send a message through the parent actor\n  parent ! \"Hello, children!\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SwitchActor that starts in a \"happy\" state. When it receives a \"sad\" message, it switches to a \"sad\" state, and vice versa. In the \"happy\" state, it should respond to any message with \"I'm happy!\", and in the \"sad\" state, it should respond with \"I'm sad.\" Demonstrate toggling between states."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Sad\ncase object Happy\n\nclass SwitchActor extends Actor {\n  var state: String = \"happy\"\n\n  def receive: Receive = {\n    case Sad =>\n      state = \"sad\"\n      println(s\"SwitchActor: Switched to $state state.\")\n    case Happy =>\n      state = \"happy\"\n      println(s\"SwitchActor: Switched to $state state.\")\n    case msg =>\n      println(s\"SwitchActor in $state state: $msg\")\n  }\n}\n\nobject SwitchActorApp extends App {\n  val system = ActorSystem(\"SwitchSystem\")\n  val actor = system.actorOf(Props[SwitchActor](), \"switchActor\")\n\n  actor ! Happy\n  actor ! \"How are you?\"\n  actor ! Sad\n  actor ! \"How are you now?\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named LifecycleActor that logs messages upon starting (preStart) and stopping (postStop). The actor should also handle a \"shutdown\" message to gracefully stop itself. Demonstrate the lifecycle hooks by sending appropriate messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// LifecycleActor logs messages upon starting and stopping\nclass LifecycleActor extends Actor {\n  override def preStart(): Unit = {\n    println(s\"${self.path.name} has started.\")\n  }\n\n  override def postStop(): Unit = {\n    println(s\"${self.path.name} has stopped.\")\n  }\n\n  def receive: Receive = {\n    case \"shutdown\" =>\n      println(s\"${self.path.name} is shutting down.\")\n      context.stop(self)\n    case msg =>\n      println(s\"LifecycleActor received: $msg\")\n  }\n}\n\nobject LifecycleActorApp extends App {\n  val system = ActorSystem(\"LifecycleSystem\")\n  val actor = system.actorOf(Props[LifecycleActor](), \"lifecycleActor\")\n\n  actor ! \"Hello\"\n  actor ! \"shutdown\"\n\n  Thread.sleep(500)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named FilterActor that processes only integer messages greater than 10. For such messages, it should respond with \"Accepted: <number>\". For all other messages, it should respond with \"Rejected: <number>\". Demonstrate the actor by sending a mix of messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the FilterActor\nclass FilterActor extends Actor {\n  def receive: Receive = {\n    case n: Int if n > 10 => println(s\"FilterActor: Accepted: $n\")\n    case n: Int => println(s\"FilterActor: Rejected: $n\")\n    case _ => println(\"FilterActor: Unknown message\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject FilterActorApp extends App {\n  val system = ActorSystem(\"FilterSystem\")\n  val filter = system.actorOf(Props[FilterActor](), \"filterActor\")\n\n  // Send a mix of messages\n  filter ! 5\n  filter ! 15\n  filter ! \"test\"\n  filter ! 20\n\n  Thread.sleep(500)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named SelfMessageActor that schedules itself to receive a \"tick\" message every second. Upon receiving a \"tick\", it should print \"Tick received\" and continue scheduling the next tick. Demonstrate the actor's ticking behavior."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass SelfMessageActor extends Actor {\n  def receive: Receive = {\n    case \"start\" =>\n      println(\"SelfMessageActor: Starting self-ticking\")\n      context.system.scheduler.scheduleWithFixedDelay(0.seconds, 1.second, self, \"tick\")\n    case \"stop\" =>\n      println(\"SelfMessageActor: Stopping self-ticking\")\n      context.system.scheduler.scheduleOnce(1.second, self, \"tick\")\n    case \"tick\" =>\n      println(\"SelfMessageActor: Tick received\")\n    case _ =>\n      println(\"SelfMessageActor: Unknown message\")\n  }\n}\n\nobject SelfMessageActorApp extends App {\n  val system = ActorSystem(\"SelfMessageSystem\")\n  val actor = system.actorOf(Props[SelfMessageActor](), \"selfMessageActor\")\n  actor ! \"start\"\n  Thread.sleep(5000)\n  actor ! \"stop\"\n  Thread.sleep(2000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named LimitedProcessorActor that maintains an internal queue of messages. The actor should process only one message at a time and ignore incoming messages while busy processing. Once processing is complete, it should process the next message in the queue. Demonstrate the actor handling multiple incoming messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define a message to process\ncase class ProcessMessage(content: String)\n\n// Define the LimitedProcessorActor\nclass LimitedProcessorActor extends Actor {\n  // Internal queue to hold messages\n  private var queue: List[ProcessMessage] = Nil\n\n  def receive: Receive = {\n    case ProcessMessage(content) =>\n      // If the queue is empty, process the message immediately\n      if (queue.isEmpty) {\n        println(s\"Processing: $content\")\n        // Simulate processing time\n        Thread.sleep(1000)\n        println(s\"Processed: $content\")\n        // Clear the queue after processing\n        queue = Nil\n      } else {\n        // If the queue is not empty, add the message to the queue\n        queue = ProcessMessage(content) :: queue\n        println(s\"Message added to queue: $content\")\n      }\n    case _ =>\n      println(\"LimitedProcessorActor: Unknown message\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LimitedProcessorApp extends App {\n  val system = ActorSystem(\"LimitedProcessorSystem\")\n  val processor = system.actorOf(Props[LimitedProcessorActor](), \"limitedProcessor\")\n\n  // Send multiple messages\n  processor ! ProcessMessage(\"Message 1\")\n  processor ! ProcessMessage(\"Message 2\")\n  processor ! ProcessMessage(\"Message 3\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named ResponderActor that listens for Greet(name: String) messages. Upon receiving such a message, it should reply to the sender with \"Hello, <name>!\". Demonstrate sending a Greet message and receiving the response."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the message\ncase class Greet(name: String)\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Greet(name) =>\n      println(s\"ResponderActor: Hello, $name!\")\n      sender() ! s\"Hello, $name!\"\n    case _ =>\n      println(\"ResponderActor: Unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ResponderApp extends App {\n  val system = ActorSystem(\"ResponderSystem\")\n  val responder = system.actorOf(Props[ResponderActor](), \"responderActor\")\n\n  // Send a Greet message\n  responder ! Greet(\"Alice\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(500)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Supervisor Actor in Scala named EscalatingSupervisor that supervises a child actor named FaultyChildActor. The FaultyChildActor throws a NullPointerException when it receives a \"causeNull\" message. Implement the supervisor's strategy to escalate the failure to its own supervisor upon encountering an exception. Demonstrate the supervision hierarchy and failure escalation."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy.{Restart, Escalate}\nimport scala.concurrent.duration._\n\n// Child actor that throws a NullPointerException\nclass FaultyChildActor extends Actor {\n  def receive: Receive = {\n    case \"causeNull\" =>\n      println(\"FaultyChildActor: Causing a NullPointerException\")\n      throw new NullPointerException(\"Child actor intentionally causing NPE\")\n    case msg =>\n      println(s\"FaultyChildActor received: $msg\")\n  }\n}\n\n// Supervisor actor that escalates failures\nclass EscalatingSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(maxNrOfRetries = 3, withinTimeRange = 1.minute) {\n    case _: NullPointerException => Escalate // Escalate NPE to its own supervisor\n    case _: Exception => Restart // Restart on other exceptions\n  }\n\n  val child = context.actorOf(Props[FaultyChildActor](), \"faultyChild\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Application entry point\nobject EscalatingSupervisorApp extends App {\n  val system = ActorSystem(\"EscalationSystem\")\n  val supervisor = system.actorOf(Props[EscalatingSupervisor](), \"escalatingSupervisor\")\n\n  supervisor ! \"causeNull\" // Should escalate to its own supervisor\n  supervisor ! \"normalMsg\" // Should be handled normally\n\n  Thread.sleep(2000)\n  system.terminate()\n}<|endoftext|>"
      }
    ]
  }
]