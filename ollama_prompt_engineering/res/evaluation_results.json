[
    {
        "prompt": "Implement a simple Akka Actor that echoes back any received message to the sender.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n\nobject EchoActor {\n  sealed trait Command\n  case class Echo(message: String) extends Command\n\n  def apply(): Behavior[Command] = Behaviors.receive { (context, message) =>\n    message match {\n      case Echo(m) => context.sender() ! m\n      case _       => ()\n    }\n    Behaviors.same\n  }\n}\n```",
        "time_taken": 1.598452091217041
    },
    {
        "prompt": "Implement an \"Hello World\" example using Akka Actors",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{ActorSystem, Props, Actor}\n\nobject HelloWorldActorExample extends App {\n\n  // Define the HelloActor class\n  class HelloActor extends Actor {\n    override def receive: Receive = {\n      case _ => println(\"Hello, World!\")\n    }\n  }\n\n  // Create an actor system\n  val system = ActorSystem(\"HelloWorldSystem\")\n\n  // Create and start a new instance of HelloActor\n  val helloActor = system.actorOf(Props[HelloActor], name = \"helloActor\")\n\n  // Send a message to trigger the print statement\n  helloActor ! ()\n}\n```",
        "time_taken": 1.9262421131134033
    },
    {
        "prompt": "Create an Akka Actor in Scala named LoggingActor that utilizes Akka\u2019s built-in logging facilities to log received messages at different log levels. Messages prefixed with \"info\", \"warn\", or \"error\" should be logged at the corresponding levels. All other messages should be logged at the debug level.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, Props}\nimport akka.event.{Logging}\n\nclass LoggingActor extends Actor {\n  val log = Logging(context.system, this)\n\n  override def receive: Receive = {\n    case message @ \"info\" + _ =>\n      log.info(message)\n    case message @ \"warn\" + _ =>\n      log.warn(message)\n    case message @ \"error\" + _ =>\n      log.error(message)\n    case other =>\n      log.debug(s\"Received message: $other\")\n  }\n}\n\nobject LoggingActor {\n  def props(): Props = Props[LoggingActor]\n}\n```",
        "time_taken": 1.8823444843292236
    },
    {
        "prompt": "Implement an Akka Actor in Scala named StashingActor that stashes incoming messages while waiting for an \"initialize\" message. Once initialized, it should unstash and process all previously stashed messages and handle new messages normally.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, ActorLogging, Props}\n\nclass StashingActor extends Actor with ActorLogging {\n\n  override def preStart(): Unit = log.info(\"StashingActor started\")\n\n  var isInitialized: Boolean = false\n\n  override def receive: Receive = {\n    case message if !isInitialized =>\n      log.debug(s\"Message received before initialization: $message\")\n      context.become(initializing)\n      stash()\n    case _ => unstashAll(); context.unbecome(); unstashAndProcess\n  }\n\n  val initializing: Receive = {\n    case \"initialize\" =>\n      isInitialized = true\n      context become unstashAndProcess\n    case message => log.warning(s\"Message stashed before initialization: $message\")\n  }\n\n  def unstashAndProcess: Receive = {\n    case message =>\n      log.info(s\"Processing message: $message\")\n      // Add your logic to process the messages here\n  }\n}\n\nobject StashingActor {\n  def props(): Props = Props(new StashingActor())\n}\n```",
        "time_taken": 3.230868101119995
    },
    {
        "prompt": "Design an Akka Actor in Scala named CircuitBreakerActor that interacts with an unreliable external service. Use Akka\u2019s CircuitBreaker to handle failures gracefully. The actor should attempt to call the external service when it receives a \"callService\" message and respond with either the service's response or an error message if the circuit is open.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, ActorSystem, Props}\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass CircuitBreakerActor(circuitBreaker: akka.pattern.CircuitBreaker) extends Actor {\n\n  override def receive: Receive = {\n    case callService =>\n      circuitBreaker.withCircuitBreaker {\n        // Simulate calling external service\n        val result = if (scala.util.Random.nextBoolean()) \"Service Response\" else throw new RuntimeException(\"Simulated Failure\")\n\n        sender() ! result\n      }\n  }\n}\n\nobject CircuitBreakerActor {\n  def props(circuitBreaker: akka.pattern.CircuitBreaker): Props =\n    Props(new CircuitBreakerActor(circuitBreaker))\n\n  def main(args: Array[String]): Unit = {\n    import scala.concurrent.duration._\n    implicit val system = ActorSystem(\"CircuitBreakerExample\")\n\n    // Define the circuit breaker configuration\n    val circuitBreakerConfig = akka.pattern.CircuitBreaker.Config(\n      maxFailures = 3,\n      callTimeout = 1.second,\n      resetTimeout = 5.seconds\n    )\n\n    // Create a CircuitBreaker instance\n    val circuitBreaker = akka.pattern.CircuitBreaker(system, circuitBreakerConfig)\n\n    // Start the actor with the configured CircuitBreaker\n    val actorRef = system.actorOf(props(circuitBreaker))\n\n    // Send message to actor and print result\n    (1 to 5).foreach(_ => {\n      implicit val timeout: Timeout = 5.seconds\n      system.scheduler.scheduleOnce(1.second) {\n        actorRef ? callService map { response =>\n          println(s\"Response: $response\")\n        }\n      }\n    })\n\n    // Simulate some failure to open the circuit\n    Thread.sleep(6000)\n\n    implicit val timeout: Timeout = 5.seconds\n\n    system.scheduler.scheduleOnce(1.second) {\n      actorRef ? callService map { response =>\n        println(s\"Response after circuit is opened: $response\")\n      }\n    }\n\n    // Wait for termination signal\n    Thread.sleep(7000)\n  }\n}\n```",
        "time_taken": 6.854207992553711
    },
    {
        "prompt": "Implement an Akka Actor using the FSM trait named TrafficLightActor. The actor should have three states: Red, Green, and Yellow. It should transition between these states in the order: Red \u2192 Green \u2192 Yellow \u2192 Red, with each state lasting for a specified duration (e.g., Red for 3 seconds, Green for 2 seconds, Yellow for 1 second). In each state, the actor should print the current state.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.Actor\nimport akka.actor.FSM\nimport scala.concurrent.duration._\nimport akka.event.Logging\n\ncase class Transition(from: String, to: String)\n\nclass TrafficLightActor extends Actor with FSM[String, Unit] {\n  import Logging._\n\n  startWith(Red,())\n\n  when(Red) {\n    case Event(Transition(_, _), _) => goto(Green)\n    case _ =>\n      log.info(s\"Current state is Red\")\n      stay()\n  }\n\n  when(Green) {\n    case Event(Transition(_, _), _) => goto(Yellow)\n    case _ =>\n      log.info(s\"Current state is Green\")\n      stay()\n  }\n\n  when(Yellow) {\n    case Event(Transition(_, _), _) => goto(Red)\n    case _ =>\n      log.info(s\"Current state is Yellow\")\n      stay()\n  }\n\n  initialize()\n}\n\nobject TrafficLightActor {\n  sealed trait State\n  case object Red extends State\n  case object Green extends State\n  case object Yellow extends State\n\n  def main(args: Array[String]): Unit = {\n    val system = akka.actor.ActorSystem(\"TrafficLightSystem\")\n    val trafficLight = system.actorOf(Props[TrafficLightActor], \"trafficLight\")\n\n    // Simulate the state transitions with a timer (for demonstration)\n    import scala.concurrent.ExecutionContext.Implicits.global\n    trafficLight ! Transition(Red, Green)\n    system.scheduler.scheduleOnce(3.seconds) {\n      trafficLight ! Transition(Green, Yellow)\n    }\n    system.scheduler.scheduleOnce(1.second) {\n      trafficLight ! Transition(Yellow, Red)\n    }\n  }\n}\n```",
        "time_taken": 5.242037534713745
    },
    {
        "prompt": "Create an Akka Actor named PriorityActor that processes messages with a custom priority mailbox. Messages of type HighPriority(msg: String) should be processed before messages of type LowPriority(msg: String), regardless of the order they are received. Implement the custom mailbox and demonstrate its usage.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "import akka.actor.{Actor, Props}\nimport akka.dispatch.MailboxType\n\nobject CustomPriorityMailbox extends MailboxType {\n  override def create mailboxesRoot: AnyRef = new CustomPriorityActor\n}\n\nclass CustomPriorityActor extends Actor {\n  import scala.collection.mutable.PriorityQueue\n\n  private val highPQ = PriorityQueue[HighPriority]()\n  private val lowPQ = PriorityQueue[LowPriority]()\n\n  override def postStop(): Unit = {\n    highPQ.clear()\n    lowPQ.clear()\n  }\n\n  def receive: PartialFunction[Any, Unit] = {\n    case hp: HighPriority => highPQ.enqueue(hp)\n    case lp: LowPriority => lowPQ.enqueue(lp)\n\n    case 'process =>\n      processMessages()\n  }\n\n  private def processMessages(): Unit = {\n    if (!highPQ.isEmpty) {\n      val msg = highPQ.dequeue()\n      sender() ! s\"Processed ${msg.msg}\"\n    } else if (!lowPQ.isEmpty) {\n      val msg = lowPQ.dequeue()\n      sender() ! s\"Processed ${msg.msg}\"\n    }\n  }\n\n  override def preStart(): Unit = context.become(receive ~ receive)\n}\n\ncase class HighPriority(msg: String)\n\ncase class LowPriority(msg: String)\n\nobject Main extends App {\n  import akka.actor.ActorSystem\n  import CustomPriorityMailbox._\n\n  val system = ActorSystem(\"PriorityActorSystem\")\n  val actorRef = system.actorOf(Props[CustomPriorityActor], \"priorityActor\")\n\n  // Sending high priority messages first\n  for (i <- 1 to 5) {\n    actorRef ! HighPriority(s\"High Priority Message $i\")\n  }\n\n  Thread.sleep(1000)\n\n  // Sending low priority messages\n  for (i <- 6 to 10) {\n    actorRef ! LowPriority(s\"Low Priority Message $i\")\n  }\n\n  Thread.sleep(2000)\n\n  // Trigger processing to see the results\n  actorRef ! 'process\n\n  system.whenTerminated.foreach(_ => println(\"System terminated\"))\n}",
        "time_taken": 6.651866436004639
    },
    {
        "prompt": "Implement two Akka Actors in Scala named PingActor and PongActor. The PingActor should initiate communication by sending a \"Ping\" message to the PongActor. Upon receiving a \"Ping\", the PongActor should reply with a \"Pong\" message. The PingActor should respond to each \"Pong\" by sending another \"Ping\", creating a continuous ping-pong exchange.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, ActorSystem, Props}\n\nclass PingActor(pingActorRef: ActorRef) extends Actor {\n  override def receive: Receive = {\n    case \"Start\" =>\n      sendPing()\n    \n    case \"Ping\" =>\n      sendPong()\n  }\n\n  private def sendPing(): Unit = {\n    pingActorRef ! \"Ping\"\n  }\n\n  private def sendPong(): Unit = {\n    pingActorRef ! \"Pong\"\n  }\n}\n\nclass PongActor(pingActorRef: ActorRef) extends Actor {\n  override def receive: Receive = {\n    case \"Pong\" =>\n      pingActorRef ! \"Ping\"\n  }\n}\n\nobject PingPongApp extends App {\n  val system = ActorSystem(\"PingPongSystem\")\n  \n  val pongActor = system.actorOf(Props(new PongActor(null)), name = \"pongActor\")\n  val pingActor = system.actorOf(Props(new PingActor(pongActor)), name = \"pingActor\")\n\n  pingActor ! \"Start\"\n}\n```",
        "time_taken": 3.3764657974243164
    },
    {
        "prompt": "Create an Akka Actor in Scala named DeadLetterMonitor that listens to the system's dead letters and logs any unhandled messages. Demonstrate sending a message to a non-existent actor and having the DeadLetterMonitor capture it.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, ActorSystem, Props}\nimport akka.event.Logging\n\ncase object Ping\n\nclass DeadLetterMonitor extends Actor {\n  val log = Logging(context.system, this)\n\n  override def receive: Receive = {\n    case deadLetter: AnyRef =>\n      log.info(s\"Dead letter received: $deadLetter\")\n  }\n}\n\nobject Main extends App {\n  implicit val system = ActorSystem(\"DeadLetterSystem\")\n\n  // Create the DeadLetterMonitor actor\n  val monitor = system.actorOf(Props[DeadLetterMonitor], \"monitor\")\n\n  // Send a message to a non-existent actor\n  system.actorSelection(\"akka://DeadLetterSystem/user/nonExistentActor\") ! Ping\n\n  // Wait for user input before shutting down the system\n  println(\"Press enter to exit...\")\n  scala.io.StdIn.readLine()\n  system.terminate()\n}\n```",
        "time_taken": 2.7806363105773926
    },
    {
        "prompt": "Design an Akka Actor in Scala named ParentActor that creates and manages multiple child actors named ChildActor. The ParentActor should forward any received message to all its child actors. Demonstrate the creation of three child actors and sending messages through the ParentActor.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, Props}\n\n// Define the ChildActor class\nclass ChildActor extends Actor {\n  override def receive: Receive = {\n    case message => println(s\"Child received: $message\")\n  }\n}\n\nobject ParentActor {\n  def props(): Props = Props[ParentActor]\n}\n\nclass ParentActor extends Actor {\n  import ParentActor._\n\n  // List to hold child actors\n  private val children = collection.mutable.ListBuffer[ActorRef]()\n\n  override def preStart(): Unit = {\n    for (_ <- 1 to 3) {\n      val child = context.actorOf(ChildActor.props, s\"child${children.size + 1}\")\n      children += child\n    }\n  }\n\n  override def receive: Receive = {\n    case message =>\n      // Forward the message to all child actors\n      children.foreach(_ ! message)\n  }\n}\n\nobject AkkaExample extends App {\n  import akka.actor.ActorSystem\n\n  val system = ActorSystem(\"ParentChildSystem\")\n  val parent = system.actorOf(ParentActor.props, \"parent\")\n\n  // Send messages through the ParentActor\n  parent ! \"Hello Child1\"\n  parent ! \"Hello Child2\"\n  parent ! \"Hello Child3\"\n}\n```",
        "time_taken": 3.9520013332366943
    },
    {
        "prompt": "Implement an Akka Actor in Scala named SwitchActor that starts in a \"happy\" state. When it receives a \"sad\" message, it switches to a \"sad\" state, and vice versa. In the \"happy\" state, it should respond to any message with \"I'm happy!\", and in the \"sad\" state, it should respond with \"I'm sad.\" Demonstrate toggling between states.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, ActorLogging, Props}\n\ncase object HappyMessage\ncase object SadMessage\n\nobject SwitchActor {\n  def props(): Props = Props[SwitchActor]\n}\n\nclass SwitchActor extends Actor with ActorLogging {\n\n  private var state: String = \"happy\"\n\n  override def receive: Receive = {\n    case HappyMessage =>\n      log.info(\"Received HappyMessage\")\n      if (state == \"sad\") state = \"happy\"\n      context.become(happyState)\n      sender() ! s\"I'm happy!\"\n\n    case SadMessage =>\n      log.info(\"Received SadMessage\")\n      if (state == \"happy\") state = \"sad\"\n      context.become(sadState)\n      sender() ! s\"I'm sad.\"\n\n    case _ => // Ignore other messages\n  }\n\n  def happyState: Receive = {\n    case HappyMessage => // Stay in the same state and reply with happiness message\n      log.info(\"Still in happy state\")\n      sender() ! s\"I'm still happy!\"\n    case SadMessage =>\n      state = \"sad\"\n      context.unbecome()\n      sender() ! s\"Switched to sad, I'm now sad.\"\n  }\n\n  def sadState: Receive = {\n    case HappyMessage =>\n      state = \"happy\"\n      context.unbecome()\n      sender() ! s\"Switched to happy, I'm now happy!\"\n    case SadMessage => // Stay in the same state and reply with sadness message\n      log.info(\"Still in sad state\")\n      sender() ! s\"I'm still sad.\"\n  }\n}\n\n// Example usage:\n// val system = ActorSystem(\"SwitchActorSystem\")\n// val switchActor = system.actorOf(SwitchActor.props(), \"switchActor\")\n\n// switchActor ! HappyMessage // Should respond with I'm happy!\n// switchActor ! SadMessage  // Should respond with I'm sad.\n// switchActor ! HappyMessage // Should remain in the same state and reply with I'm still happy!\n```",
        "time_taken": 6.338795185089111
    },
    {
        "prompt": "Create an Akka Actor in Scala named LifecycleActor that logs messages upon starting (preStart) and stopping (postStop). The actor should also handle a \"shutdown\" message to gracefully stop itself. Demonstrate the lifecycle hooks by sending appropriate messages.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, Props, ActorSystem}\n\nclass LifecycleActor extends Actor {\n  override def preStart(): Unit = {\n    println(\"LifecycleActor is starting...\")\n  }\n\n  override def postStop(): Unit = {\n    println(\"LifecycleActor has stopped.\")\n  }\n\n  def receive: Receive = {\n    case \"message\" => println(\"Received a message\")\n    case \"shutdown\" => context.stop(self)\n  }\n}\n\nobject LifecycleActorExample extends App {\n  val system = ActorSystem(\"LifecycleSystem\")\n\n  val lifecycleActor = system.actorOf(Props[LifecycleActor], name = \"lifecycleActor\")\n\n  // Sending messages to demonstrate lifecycle hooks\n  println(\"Sending a message\")\n  lifecycleActor ! \"message\"\n  \n  println(\"Sending a shutdown command\")\n  lifecycleActor ! \"shutdown\"\n\n  Thread.sleep(1000) // Wait for the actor to stop\n\n  system.terminate()\n}\n```",
        "time_taken": 2.9491915702819824
    },
    {
        "prompt": "Implement an Akka Actor in Scala named FilterActor that processes only integer messages greater than 10. For such messages, it should respond with \"Accepted: <number>\". For all other messages, it should respond with \"Rejected: <number>\". Demonstrate the actor by sending a mix of messages.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.Actor\nimport akka.actor.Props\n\nobject FilterActor {\n  def props = Props[FilterActor]\n\n  case class Message(number: Int)\n\n  case object Shutdown extends Message(-1)\n}\n\nclass FilterActor extends Actor {\n  override def receive: Receive = {\n    case Message(n) if n > 10 => sender() ! s\"Accepted: $n\"\n    case msg: Message => sender() ! s\"Rejected: ${msg.number}\"\n    case FilterActor.Shutdown => context.stop(self)\n  }\n}\n\nobject Main extends App {\n  import akka.actor.ActorSystem\n  import akka.pattern.ask\n\n  implicit val system = ActorSystem(\"FilterSystem\")\n  val filterActor = system.actorOf(FilterActor.props, \"filterActor\")\n\n  // Send a mix of messages to the actor\n  List(5, 12, -3, 8, 20).foreach { num =>\n    filterActor ! FilterActor.Message(num)\n  }\n\n  // Shutdown the actor after processing\n  Thread.sleep(1000) // Give some time for messages to be processed\n  filterActor ! FilterActor.Shutdown\n\n  system.awaitTermination()\n}\n```",
        "time_taken": 3.8464620113372803
    },
    {
        "prompt": "Create an Akka Actor in Scala named SelfMessageActor that schedules itself to receive a \"tick\" message every second. Upon receiving a \"tick\", it should print \"Tick received\" and continue scheduling the next tick. Demonstrate the actor's ticking behavior.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, ActorSystem, Props}\n\ncase object Tick\n\nclass SelfMessageActor extends Actor {\n  override def receive: Receive = {\n    case Tick =>\n      println(\"Tick received\")\n      context.system.scheduler.scheduleOnce(1.second, self, Tick)\n  }\n}\n\nobject SelfMessageActorApp extends App {\n  val system = ActorSystem(\"SelfMessageActorSystem\")\n  val actor = system.actorOf(Props[SelfMessageActor], \"selfMessageActor\")\n\n  // Initial scheduling\n  actor ! Tick\n\n  // To keep the main thread alive to observe the messages\n  Thread.sleep(10.seconds.toMillis)\n}\n```",
        "time_taken": 2.1109673976898193
    },
    {
        "prompt": "Implement an Akka Actor in Scala named LimitedProcessorActor that maintains an internal queue of messages. The actor should process only one message at a time and ignore incoming messages while busy processing. Once processing is complete, it should process the next message in the queue. Demonstrate the actor handling multiple incoming messages.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, ActorLogging, Props}\nimport scala.collection.mutable.Queue\n\nclass LimitedProcessorActor extends Actor with ActorLogging {\n  private val queue = Queue.empty[String]\n\n  override def receive: Receive = processing(None)\n\n  def processing(currentMessageOpt: Option[String]): Receive = {\n    case msg: String =>\n      log.info(s\"Processing message $msg\")\n      currentMessageOpt match {\n        case Some(_) => // Ignore incoming messages while already processing\n          log.info(\"Ignoring new message as one is currently being processed.\")\n        case None =>\n          queue.enqueue(msg)\n          if (queue.length > 1) context.become(processing(Some(queue.head)))\n      }\n\n    case _ => // Handle other cases if needed\n      log.warning(\"Unknown message type received\")\n  }\n}\n\nobject LimitedProcessorActor {\n  def props: Props = Props[LimitedProcessorActor]\n}\n```",
        "time_taken": 2.842641830444336
    },
    {
        "prompt": "Create an Akka Actor in Scala named ResponderActor that listens for Greet(name: String) messages. Upon receiving such a message, it should reply to the sender with \"Hello, <name>!\". Demonstrate sending a Greet message and receiving the response.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, Props, ActorSystem}\nimport scala.concurrent.duration._\n\ncase class Greet(name: String)\n\nclass ResponderActor extends Actor {\n  override def receive: Receive = {\n    case Greet(name) => sender() ! s\"Hello, $name!\"\n  }\n}\n\nobject Main extends App {\n  val system = ActorSystem(\"GreetingSystem\")\n  val responder = system.actorOf(Props[ResponderActor], name = \"responder\")\n\n  import system.dispatcher\n  val futureResponse = responder ? Greet(\"Scala\")\n\n  futureResponse.foreach { response =>\n    println(response)\n  }\n\n  Thread.sleep(2000) // Wait for the message to be processed and printed.\n}\n```",
        "time_taken": 2.3279542922973633
    },
    {
        "prompt": "Design an Akka Supervisor Actor in Scala named EscalatingSupervisor that supervises a child actor named FaultyChildActor. The FaultyChildActor throws a NullPointerException when it receives a \"causeNull\" message. Implement the supervisor's strategy to escalate the failure to its own supervisor upon encountering an exception. Demonstrate the supervision hierarchy and failure escalation.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting. Focus on actor-based solutions.",
        "response": "```scala\nimport akka.actor.{Actor, ActorLogging, Props, SupervisorStrategy, Terminated}\nimport akka.routing.RoundRobinPool\n\nclass EscalatingSupervisor extends Actor with ActorLogging {\n  val faultyChildActor = context.actorOf(Props[FaultyChildActor], \"faultyChild\")\n\n  override def supervisorStrategy: SupervisorStrategy =\n    OneForOneStrategy() {\n      case _: NullPointerException => Escalate\n    }\n\n  override def receive: Receive = {\n    case msg: String =>\n      log.info(s\"EscalatingSupervisor received message: $msg\")\n      faultyChildActor forward s\"causeNull_$msg\"\n    case Terminated(child) =>\n      log.error(\"Faulty child actor terminated, restarting...\")\n      context.watch(context.actorOf(Props[FaultyChildActor], \"faultyChild\"))\n  }\n}\n\nclass FaultyChildActor extends Actor with ActorLogging {\n  override def receive: Receive = {\n    case \"causeNull\" => throw new NullPointerException(\"Simulating null pointer\")\n    case msg: String =>\n      log.info(s\"FaultyChildActor received message: $msg\")\n  }\n}\n\nobject EscalatingSupervisorApp extends App {\n  import akka.actor.ActorSystem\n  implicit val system = ActorSystem(\"EscalationExample\")\n\n  val supervisor = system.actorOf(Props[EscalatingSupervisor], \"supervisor\")\n\n  // Simulate failure and observe the escalation behavior\n  supervisor ! \"test\"\n}\n```",
        "time_taken": 4.702380657196045
    }
]