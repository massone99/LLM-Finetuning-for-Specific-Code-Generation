[
    {
        "prompt": "Implement a simple Akka Actor that echoes back any received message to the sender.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{ActorSystem, Props}\nimport akka.persistence.{PersistenceId, PersistencePlugin}\n\nobject EchoActor {\n  def main(args: Array[String]): Unit = {\n    val system = ActorSystem(\"EchoActor\", PersistencePlugin().akkaConfig.getOptionalString(\"akka.persistence.type\").getOrElse(\"journal\"))\n    \n    val echoActor = system.actorOf(Props[EchoActor])\n    \n    val sender = System.getProperty(\"sender\")\n    if (sender != null) {\n      val message = \"Hello\"\n      echoActor ! message\n      while (!system.terminate()) {}\n    }\n  }\n}\n\nclass EchoActor extends Actor {\n  override def receive: Receive = {\n    case msg => context.system.postStop { () =>\n      println(s\"Echo received message $msg from $self\")\n    }\n    case msg => sender ! msg\n  }\n}\n```",
        "time_taken": 3.718743085861206
    },
    {
        "prompt": "Implement an \"Hello World\" example using Akka Actors",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{ActorSystem, Props}\nimport akka.pattern.ask\n\nobject HelloWorld {\n  def main(args: Array[String]) {\n    val system = ActorSystem(\"hello-world-system\")\n    val helloWorldActor = system.actorOf(Props[HelloWorldActor], \"hello-world-actor\")\n\n    implicit val timeout: scala.concurrent.Duration = scala.concurrent Duration.seconds(10)\n\n    helloWorldActor ! \"greet\"\n  }\n}\n\nclass HelloWorldActor extends Actor {\n  override def receive: Receive = {\n    case \"greet\" => println(\"Hello World!\")\n    case _        => println(s\"Received unknown message ${self.path.toString}\")\n  }\n}\n```",
        "time_taken": 1.1574597358703613
    },
    {
        "prompt": "Create an Akka Actor in Scala named LoggingActor that utilizes Akka\u2019s built-in logging facilities to log received messages at different log levels. Messages prefixed with \"info\", \"warn\", or \"error\" should be logged at the corresponding levels. All other messages should be logged at the debug level.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.ActorSystem\nimport akka.actor.{Actor, Behavior}\nimport akka.event.LoggingAdapter\nimport akka.event.Logging\nimport akka.event.Level\nimport scala.util.matching.Regex\n\nclass LoggingActor extends Actor {\n  val loggingAdapter = Logging(context.system).application(context.system.name)\n\n  override def receive: Receive = {\n    case (msg: String) if Regex(\"info|warn|error\").matches(msg) =>\n      loggingAdapter.info(s\"Received message: $msg\")\n    case msg => loggingAdapter.debug(s\"Received message: $msg\")\n  }\n}\n```",
        "time_taken": 1.052147388458252
    },
    {
        "prompt": "Implement an Akka Actor in Scala named StashingActor that stashes incoming messages while waiting for an \"initialize\" message. Once initialized, it should unstash and process all previously stashed messages and handle new messages normally.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\n\ncase class Initialize\n\nclass StashingActor extends Actor {\n  import context._\n  val stash = context.stash\n\n  override def receive: ReceiveAny = {\n    case message =>\n      stash(message)\n\n    case msg if msg == Initialize =>\n      while (!stash.isEmpty) {\n        stash.get().foreach(process)\n      }\n      stash.clear()\n  }\n\n  private def process(msg: Any): Unit = {\n    // Process the message here, for example:\n    println(s\"Received message: $msg\")\n  }\n}\n\nobject StashingActor {\n  def apply(): Props = Props(StashingActor)\n}\n```",
        "time_taken": 1.2936322689056396
    },
    {
        "prompt": "Design an Akka Actor in Scala named CircuitBreakerActor that interacts with an unreliable external service. Use Akka\u2019s CircuitBreaker to handle failures gracefully. The actor should attempt to call the external service when it receives a \"callService\" message and respond with either the service's response or an error message if the circuit is open.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{Actor, ActorSystem}\nimport akka.pattern.pipeTo\nimport akka.util.ByteString\nimport com.typesafe.config.Config\nimport io.github.cdimascio.johanart.CircuitBreaker\nimport scala.concurrent.duration._\nimport scala.language.postfixOps\n\nobject CircuitBreakerActor {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem(\"CircuitBreakerActor\")\n    val circuitBreaker = new CircuitBreaker(\n      maxFailures = 3,\n      timeout = Duration.seconds(30),\n      resetTimeout = Duration.seconds(10)\n    )\n\n    class CircuitBreakerActor extends Actor with CircuitBreaker {\n      override def receive: Receive = {\n        case \"callService\" =>\n          circuitBreaker.execute(() => {\n            // Attempt to call the external service\n            val response = ByteString(\"Hello, World!\")\n            system.eventStream.publish(response)\n            System.out.println(response.toString())\n            Right(response.toString())\n          }).pipeTo(self)\n      }\n    }\n\n    val actor = system.actorOf(CircuitBreakerActor.classOf[CircuitBreakerActor], \"CircuitBreakerActor\")\n    ActorSystem(implicit system => system.deadLetterQueue(\" failures\").autoComplete(false))\n\n    // Start the actor\n    actor ! \"callService\"\n  }\n}\n```",
        "time_taken": 2.312706708908081
    },
    {
        "prompt": "Implement an Akka Actor using the FSM trait named TrafficLightActor. The actor should have three states: Red, Green, and Yellow. It should transition between these states in the order: Red \u2192 Green \u2192 Yellow \u2192 Red, with each state lasting for a specified duration (e.g., Red for 3 seconds, Green for 2 seconds, Yellow for 1 second). In each state, the actor should print the current state.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.ActorSystem\nimport akka.actor.FSM\nimport akka.pattern.Prepended\nimport scala.concurrent.duration._\n\nobject TrafficLightActor {\n  def main(args: Array[String]) {\n    implicit val system = ActorSystem(\"traffic-light-actor\")\n    implicit val fsm = FSM[State, String]()\n\n    val redDuration = 3.seconds\n    val greenDuration = 2.seconds\n    val yellowDuration = 1.second\n\n    fsm.stateTransition(Red, Green, \"green\", redDuration)\n    fsm.stateTransition(Green, Yellow, \"yellow\", greenDuration)\n    fsm.stateTransition(Yellow, Red, \"red\", yellowDuration)\n\n    fsm.onStateTransition += {\n      case (state, _) =>\n        println(s\"$state\")\n    }\n\n    fsm.resetTo(Red)\n\n    val transition = Prepped[Nothing](Prepended(Red, Green, Yellow))\n    fsm.runWith(transition)\n  }\n}\n\ncase class State(current: String) {\n  def next(current: String): Option[(State, String)] = current match {\n    case \"Red\" => Some((Green, \"green\"), redDuration)\n    case \"Green\" => Some((Yellow, \"yellow\"), greenDuration)\n    case \"Yellow\" => Some((Red, \"red\"), yellowDuration)\n  }\n}\n\nobject State {\n  val redDuration = Duration(3.seconds)\n  val greenDuration = Duration(2.seconds)\n  val yellowDuration = Duration(1.second)\n}\n```",
        "time_taken": 2.6071386337280273
    },
    {
        "prompt": "Create an Akka Actor named PriorityActor that processes messages with a custom priority mailbox. Messages of type HighPriority(msg: String) should be processed before messages of type LowPriority(msg: String), regardless of the order they are received. Implement the custom mailbox and demonstrate its usage.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{Actor, ActorSystem, Props}\nimport akka.patterns.pubsub.Publisher\nimport akka.patterns.pubsub.Subscriber\nimport scala.concurrent.duration._\n\nobject PriorityActor {\n  trait Message {\n    def priority: Int\n  }\n\n  case class HighPriority(msg: String) extends Message {\n    override def priority = 1\n  }\n\n  case class LowPriority(msg: String) extends Message {\n    override def priority = 2\n  }\n\n  class CustomMailbox extends Publisher[Message, String] with Subscriber[Message] {\n    var orderedMessages = scala.collection.mutable.ArrayBuffer[Message]()\n    var processedMessages = scala.collection.mutable.ArrayBuffer[Message]()\n\n    override def onSubscriberAdded(): Unit = {}\n\n    override def onSubscriberRemoved(): Unit = {}\n\n    override def onMessageReceived(msg: Message): Unit = {\n      msg.priority match {\n        case 1 => orderedMessages.append(msg)\n        case 2 => processedMessages.append(msg)\n      }\n    }\n\n    override def onMessageProcessed(msg: Message): Unit = {\n      if (orderedMessages.contains(msg)) {\n        orderedMessages = orderedMessages.filter(_ != msg)\n      } else if (!processedMessages.contains(msg)) {\n        throw new Exception(s\"Message of type $msg.getClass did not match its priority\")\n      }\n    }\n\n    override def onActorTerminated(): Unit = {}\n  }\n\n  class PriorityActor extends Actor with Publisher[Message, String] with Subscriber[Message] {\n    val mailbox = new CustomMailbox\n    var publishedMessages = scala.collection.mutable.ArrayBuffer[String]()\n    var processedMessages = scala.collection.mutable.ArrayBuffer[String]()\n\n    override def preRestart(reason: Exception, msg: ActorMaterialize): Unit = {\n      super.preRestart(reason, msg)\n      publish(\"Initial message\")\n    }\n\n    override def postRestart(reason: Exception, msg: ActorMaterialize): Unit = {\n      super.postRestart(reason, msg)\n      publish(\"Post restart message\")\n    }\n\n    override def receive: Receive = {\n      case msg: Message =>\n        mailbox.onMessageReceived(msg)\n      case String() => {\n        publishedMessages.append(mailbox.processedMessages.mkString(\"\\n\"))\n        publish(s\"Message received and processed\\n${publishedMessages}\")\n        // Intentionally drop messages that don't match their priority\n        if (mailbox.orderedMessages.nonEmpty) {\n          val firstOrderedMsg = mailbox.orderedMessages.head\n          println(s\"Dropped message of type ${firstOrderedMsg.getClass} from the high priority queue\")\n          mailbox.processedMessages.append(firstOrderedMsg)\n        }\n      }\n    }\n\n    override def onMessageProcessed(msg: Message): Unit = {\n      processedMessages.append(msg)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val system = ActorSystem(\"PriorityActor\")\n    val priorityActor = system.actorOf(Props[PriorityActor], \"priorityActor\")\n\n    // Send some messages\n    for (i <- 1 to 10) {\n      if (i % 2 == 0) {\n        priorityActor ! LowPriority(s\"Message $i\")\n      } else {\n        priorityActor ! HighPriority(s\"Message $i\")\n      }\n    }\n\n    // Wait and print the output\n    Thread.sleep(1000 * 5)\n    system.terminate()\n  }\n}\n```",
        "time_taken": 5.764237403869629
    },
    {
        "prompt": "Implement two Akka Actors in Scala named PingActor and PongActor. The PingActor should initiate communication by sending a \"Ping\" message to the PongActor. Upon receiving a \"Ping\", the PongActor should reply with a \"Pong\" message. The PingActor should respond to each \"Pong\" by sending another \"Ping\", creating a continuous ping-pong exchange.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{Actor, ActorSystem, Props}\n\nclass PingActor extends Actor {\n  override def receive: Receive = {\n    case _ => context.system.postStop {}\n  }\n\n  override def preStart(): Unit = {\n    super.preStart()\n    val pongActor = context.system.actorOf(Props[PongActor], \"pong\")\n    pongActor ! \"Ping\"\n  }\n}\n\nclass PongActor extends Actor {\n  override def receive: Receive = {\n    case msg @ Message(\"Ping\") => sender() ! \"Pong\" // reply to the ping\n    case _ => context.system.postStop {}\n  }\n}\n```\n\n```scala\nimport akka.actor.{Actor, ActorSystem, Props}\n\nobject PingPong {\n  def main(args: Array[String]): Unit = {\n    val system = ActorSystem(\"PingPong\")\n    val pongActor = system.actorOf(Props[PongActor], \"pong\")\n\n    val pingActor = system.actorOf(Props[PingActor], \"ping\")\n    pingActor ! \"Ping\"\n  }\n}\n```",
        "time_taken": 1.8346800804138184
    },
    {
        "prompt": "Create an Akka Actor in Scala named DeadLetterMonitor that listens to the system's dead letters and logs any unhandled messages. Demonstrate sending a message to a non-existent actor and having the DeadLetterMonitor capture it.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.ActorSystem\nimport akka.actor DeadLetters\nimport akka.actor.DeadLetterHandler\nimport akka.actor.Props\nimport akka.event.{LoggingLevel, Logger}\n\nobject DeadLetterMonitor {\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem(\"dead-letter-monitor\")\n    implicit val log = Logger(system.name, LoggingLevel.Info)\n\n    val deadLetterMonitor = Props(new DeadLetterMonitor())\n      .withSupervisorStrategy(DoneStrategy)\n    system.actorOf(deadLetterMonitor).withinWidthLimit(10)\n\n    // send a message to a non-existent actor\n    def sendMessageToNonExistentActor(message: String) = {\n      val deadLettersRef = system.parent\n      if (deadLettersRef != null) {\n        deadLettersRef.sendOne(message)\n      } else {\n        log.info(\"No parent actor found, sending message to dead letters\")\n      }\n    }\n\n    sendMessageToNonExistentActor(\"Hello, World!\")\n\n    system.terminate()\n  }\n}\n\nclass DeadLetterMonitor extends Actor with DeadLetterHandler {\n\n  override def receive: Receive = {\n    case DeadLetter(message) => log.info(s\"Unhandled message: $message\")\n  }\n}\n```",
        "time_taken": 2.099287271499634
    },
    {
        "prompt": "Design an Akka Actor in Scala named ParentActor that creates and manages multiple child actors named ChildActor. The ParentActor should forward any received message to all its child actors. Demonstrate the creation of three child actors and sending messages through the ParentActor.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{ActorSystem, Props}\n\nobject ParentActor {\n  def main(args: Array[String]) = {\n    val system = ActorSystem(\"ParentActor\")\n\n    // Create child actor\n    val parentActor = system.actorOf(Props[ParentActor], \"parentActor\")\n    val child1 = system.actorOf(Props[ChildActor], \"child1\")\n    val child2 = system.actorOf(Props[ChildActor], \"child2\")\n    val child3 = system.actorOf(Props[ChildActor], \"child3\")\n\n    // Forward messages to all child actors\n    parentActor receive {\n      case msg => child1 ! msg; child2 ! msg; child3 ! msg\n    }\n\n    // Create three instances of ChildActor and send them a message\n    val child1Instance = system.actorOf(Props[ChildActor], \"child1-instance\")\n    val child2Instance = system.actorOf(Props[ChildActor], \"child2-instance\")\n    val child3Instance = system.actorOf(Props[ChildActor], \"child3-instance\")\n\n    parentActor.tell(\"Hello from Child1!\", child1)\n    parentActor.tell(\"Hello from Child2!\", child2)\n    parentActor.tell(\"Hello from Child3!\", child3)\n\n    // Keep the application running for 10 seconds\n    Thread.sleep(10000)\n  }\n}\n\nclass ParentActor extends Actor {\n  override def receive: Receive = {\n    case msg => context.log.info(s\"Received message ${msg.toString} from ParentActor\")\n  }\n}\n\nclass ChildActor extends Actor {\n  override def receive: Receive = {\n    case msg => context.log.info(s\"Received message $msg from ChildActor\")\n  }\n}\n```",
        "time_taken": 3.0377180576324463
    },
    {
        "prompt": "Implement an Akka Actor in Scala named SwitchActor that starts in a \"happy\" state. When it receives a \"sad\" message, it switches to a \"sad\" state, and vice versa. In the \"happy\" state, it should respond to any message with \"I'm happy!\", and in the \"sad\" state, it should respond with \"I'm sad.\" Demonstrate toggling between states.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor._\n\nobject SwitchActor {\n  def main(args: Array[String]): Unit = {\n    val system = ActorSystem(\"SwitchActor\")\n    val actor = system.actorOf(Props[SwitchActor], \"switchActor\")\n\n    // Send a happy message to test the initial state\n    actor ! \"happy\"\n\n    // Toggle between sad and happy states\n    actor ! \"sad\"\n    actor ! \"happy\"\n    actor ! \"sad\"\n  }\n}\n\nclass SwitchActor extends Actor {\n  var state = \"happy\"\n\n  override def receive: ReceiveAny = {\n    case \"happy\" => {\n      state = \"happy\"\n      sender() ! \"I'm happy!\"\n    }\n    case \"sad\" => {\n      state = \"sad\"\n      sender() ! \"I'm sad.\"\n    }\n  }\n}\n```",
        "time_taken": 1.4292161464691162
    },
    {
        "prompt": "Create an Akka Actor in Scala named LifecycleActor that logs messages upon starting (preStart) and stopping (postStop). The actor should also handle a \"shutdown\" message to gracefully stop itself. Demonstrate the lifecycle hooks by sending appropriate messages.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{ActorSystem, Props}\nimport akka.pattern._ \nimport akka.util.Timeout\n\nobject LifecycleActor {\n  def main(args: Array[String]) {\n    implicit val system = ActorSystem(\"system\")\n    implicit val timeout = Timeout(10 seconds)\n\n    val lifecycleActor = system.actorOf(Props[LifecycleActor])\n\n    // Send start and shutdown messages to test preStart and postStop\n    (systemactorOf(lifecycleActor), \"start\").onComplete(_ => lifecycleActor ! \"shutdown\")\n\n    // Send stop message directly to the actor\n    lifecycleActor ! \"stop\"\n\n    // Send shutdown message again after stopping for testing postStop\n    (system, lifecycleActor).onComplete { case (_, _) =>\n      lifecycleActor ! \"shutdown\"\n    }\n\n    // Keep the application running until manually stopped\n    implicit val system = ActorSystem(\"system\")\n  }\n}\n\nclass LifecycleActor extends Actor {\n  override def preStart(): Unit = {\n    println(s\"Starting actor ${self.path}.\")\n  }\n\n  override def postStop(): Unit = {\n    println(s\"Stopping actor ${self.path}.\")\n  }\n\n  override def receive: Receive = {\n    case \"shutdown\" => context.stop(self)\n    case \"stop\" => context.stop(self)\n    case _          => println(s\"Received message ${self.path}: $msg\")\n  }\n}\n```",
        "time_taken": 2.369945526123047
    },
    {
        "prompt": "Implement an Akka Actor in Scala named FilterActor that processes only integer messages greater than 10. For such messages, it should respond with \"Accepted: <number>\". For all other messages, it should respond with \"Rejected: <number>\". Demonstrate the actor by sending a mix of messages.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{ActorSystem, Props}\nimport akka.pattern.pipeTo\nimport scala.concurrent.duration._\n\nobject FilterActor {\n  def main(args: Array[String]) {\n    implicit val system = ActorSystem(\"filter-system\")\n\n    val filterActor = system.actorOf(Props[FilterActor], \"filter-actor\")\n    pipeTo(filterActor)(10)\n    pipeTo(filterActor)(11)\n    pipeTo(filterActor)(\"hello\")\n    pipeTo(filterActor)(20)\n\n    system.terminateAfter(5.seconds)\n  }\n}\n\nclass FilterActor extends Actor {\n  override def receive: Receive = {\n    case msg @ Integer(msg) if msg > 10 => sender() ! s\"Accepted: $msg\"\n    case msg @ Integer(_)           => sender() ! s\"Rejected: $msg\"\n    case _                           => println(\"Invalid message type\")\n  }\n}\n\ncase class Integer(n: Int)\n```",
        "time_taken": 1.635223150253296
    },
    {
        "prompt": "Create an Akka Actor in Scala named SelfMessageActor that schedules itself to receive a \"tick\" message every second. Upon receiving a \"tick\", it should print \"Tick received\" and continue scheduling the next tick. Demonstrate the actor's ticking behavior.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{Actor, ActorSystem}\nimport akka.event.Logging\nimport akka.event LoggingLevel\nimport akka.util.Timeout\nimport scala.concurrent.duration.Duration\n\nobject SelfMessageActor {\n  def main(args: Array[String]) {\n    implicit val system = ActorSystem(\"SelfMessageActor\")\n    val selfActor = system.actorOf(SelfMessageActor.classOf[SelfMessageActor], \"self-actor\")\n\n    // set initial timeout duration for the actor\n    implicit val timeout: Timeout = Duration(5.seconds)\n\n    def scheduleTick() = {\n      selfActor.tell(\"tick\", selfActor)\n      ActorSystem.system().scheduler().scheduleOnceAfter(Duration(1.second), () => scheduleTick())\n    }\n\n    scheduleTick()\n  }\n}\n\nclass SelfMessageActor extends Actor with Logging {\n  override def receive: Receive = {\n    case msg @ \"tick\" =>\n      logInformation(\"Tick received\")\n      self.tell(\"tick\", self)\n  }\n}\n```",
        "time_taken": 1.6966402530670166
    },
    {
        "prompt": "Implement an Akka Actor in Scala named LimitedProcessorActor that maintains an internal queue of messages. The actor should process only one message at a time and ignore incoming messages while busy processing. Once processing is complete, it should process the next message in the queue. Demonstrate the actor handling multiple incoming messages.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{Actor, ActorSystem}\nimport akka.pattern.pipeAll\nimport scala.concurrent.duration._\n\nobject LimitedProcessorActor {\n  def main(args: Array[String]) {\n    implicit val system = ActorSystem(\"LimitedProcessorActor\")\n    implicit val materializer = ActorMaterializer()\n    implicit val dispatcher = SystemDispatcher\n\n    class LimitedProcessorActor extends Actor {\n      import LimitedProcessorActor._\n      private var messageQueue = Vector.empty[Message]\n      private var busy = false\n      private def processNext(): Unit = {\n        busy = true\n        try {\n          val Message(msg, _) = messageQueue.head\n          messageQueue = messageQueue.tail\n          msg match {\n            case \"hello\" => println(\"Hello\")\n            case \"world\" => println(\"World\")\n          }\n        } catch {\n          case _: Exception =>\n            // ignore and continue\n        } finally {\n          busy = false\n        }\n      }\n\n      override def receive: Receive[Message] = {\n        case msg @ Message(msg, sender) =>\n          messageQueue ::= msg\n          if (!busy) processNext()\n      }\n    }\n\n    sealed trait Message\n    case class Message(message: String) extends Message\n\n    val limitedProcessorActor = system.actorOf(LimitedProcessorActor.classOf[LimitedProcessorActor])\n    pipeAll(limitedProcessorActor, (limitedProcessorActor.path + \"/tell\").rsToScalaActorRef)\n  }\n}\n```",
        "time_taken": 2.5161678791046143
    },
    {
        "prompt": "Create an Akka Actor in Scala named ResponderActor that listens for Greet(name: String) messages. Upon receiving such a message, it should reply to the sender with \"Hello, <name>!\". Demonstrate sending a Greet message and receiving the response.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\n\nobject ResponderActor {\n  def main(args: Array[String]) {\n    implicit val system = ActorSystem(\"ResponderActor\")\n    implicit val timeout = Timeout(10.seconds)\n\n    class ResponderActor extends Actor {\n      override def receive: Receive = {\n        case Greet(name) =>\n          context.actorSelection tell s\"Hello, $name!\"\n      }\n    }\n\n    val responderActor = system actedUpon Props(ResponderActor)\n    val responseFuture = ask(responderActor, \"Who are you?\")\n    println(responseFuture.get)\n\n    // Send a Greet message\n    val sender = systemactorOf(Greet(\"John\"))\n  }\n}\n\ncase class Greet(name: String)\n```",
        "time_taken": 1.3722529411315918
    },
    {
        "prompt": "Design an Akka Supervisor Actor in Scala named EscalatingSupervisor that supervises a child actor named FaultyChildActor. The FaultyChildActor throws a NullPointerException when it receives a \"causeNull\" message. Implement the supervisor's strategy to escalate the failure to its own supervisor upon encountering an exception. Demonstrate the supervision hierarchy and failure escalation.",
        "system_prompt": "You are a code assistant specialized in Akka and Scala. Provide only code in your response, without explanations or markdown formatting",
        "response": "```scala\nimport akka.actor.{Behavior, ActorSystem}\nimport akka.pattern._\nimport scala.concurrent.duration._\n\nobject EscalatingSupervisor {\n  def main(args: Array[String]) {\n    val system = ActorSystem(\"EscalatingSupervisor\")\n\n    class FaultyChildActor extends Actor with SupervisorStrategy {\n      override type Rep = Any\n\n      override def behavior: Behavior[Any] = catch {\n        case _ => Failure\n      }\n\n      override def restartWith(newStrategy: SupervisorStrategy): Behavior[Any] = newStrategy\n    }\n\n    val childActorBehavior = FaultyChildActor()\n    val supervisorStrategy = OnRestart(reset, withDeadLetters)\n\n    val supervisor = system.actorOf(FaultyChildActor.props(classOf[FaultyChildActor]) + \"backstage\", \"EscalatingSupervisor\")\n    supervisor ! childActorBehavior\n\n    val escaler = supervisor.withSupervisorStrategy(supervisorStrategy)\n    val restartCommand = actorSelection(\"EscalatingSupervisor\").replaceWith(escaler)\n\n    Thread.sleep(5000)\n    supervisor ! \"causeNull\"\n  }\n}\n```",
        "time_taken": 1.916919231414795
    }
]