import akka.actor.{Actor, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy, Terminated}
import akka.pattern.ask
import akka.util.Timeout

import scala.concurrent.duration._
import scala.concurrent.Await
import scala.util.{Try, Success, Failure}

// Define the ChildActor
class FaultyChildActor extends Actor {
  def receive: Receive = {
    case "causeNull" =>
      throw new NullPointerException("ChildActor failed with null cause.")
    case msg =>
      println(s"ChildActor received: $msg")
  }
}

// Define the Supervisor Actor
class EscalatingSupervisor extends Actor with OneForOneStrategy {
  override val maxNumberOfRetries: Int = 2

  override def postStop(): Unit = {
    println("EscalatingSupervisor has stopped.")
    super.postStop()
  }
}

// Usage Example
object EscalatingSupervisorApp extends App {
  val system = ActorSystem("EscalatingSupervisorSystem")
  val supervisor = system.actorOf(Props[EscalatingSupervisor](), "escalatingSupervisor")

  // Define a simple resolver actor to perform the failover
  class ResolverActor extends Actor {
    def receive: Receive = {
      case msg =>
        if (msg.printStackTrace().trim.endsWith(".java:")) {
          println("ResolverActor taking over.")
          supervisor! msg.name
        } else {
          println(s"ResolverActor cannot rescue: $msg")
        }
    }
  }
  val resolver = system.actorOf(Props[ResolverActor](), "resolverActor")

  implicit val timeout: Timeout = Timeout(2.seconds)
  val future = supervisor? "causeNull"
  val result = Await.result(future, timeout.duration)

  // Process the result
  val attempt = Try(result)
  attempt match {
    case Success(_) => println("Supervisor allowed the failure to proceed.")
    case Failure(_) =>
      println("Supervisor escalated the failure to ResolverActor.")
  }

  resolver! "causeNull"
}