import akka.actor.{Actor, ActorSystem, Props}
import akka.pattern.ask
import akka.util.Timeout
import scala.concurrent.duration._
import scala.util.{Try, Success, Failure}

// Define the TrafficLightState
sealed trait TrafficLightState extends Product

case class Red extends TrafficLightState
case class Green extends TrafficLightState
case class Yellow extends TrafficLightState

// Define the TrafficLightActor
class TrafficLightActor extends Actor with FiniteStateMachine[TrafficLightState, Red, Green, Yellow] {
  override def initial_state: TrafficLightState = Red
  override def createStateMachine: Receive => Either[TrafficLightState, Unit] = {
    case Red => self переход(Green)
    case Green => self-transitional(Green)
    case Yellow => self-transitional(Yellow)
  }

  override def currentState: TrafficLightState = super.currentState

  override def transition(state: TrafficLightState): Unit = {
    println(s"TrafficLightActor is transitioning from $currentState to $state")
  }

  override def postTransition(state: TrafficLightState): Unit = {
    println(s"TrafficLightActor entered state $state")
    context.system.scheduler.scheduleOnce(2.seconds, self, Yellow) // Green for 2 seconds
  }
}

// Usage Example
object TrafficLightApp extends App {
  val system = ActorSystem("TrafficLightSystem")
  val trafficLight = system.actorOf(Props[TrafficLightActor](), "trafficLight")

  implicit val timeout: Timeout = Timeout(3.seconds)

  Try {
    val _ = trafficLight? "toggle"
    trafficLight.tell("toggle", trafficLight.path)
  } match {
    case Success(_) =>
      println("TrafficLight Actor successfully transitioned through its states.")
    case Failure(exception) =>
      println(s"Error occurred: ${exception.printStackTrace()}")
  }
}