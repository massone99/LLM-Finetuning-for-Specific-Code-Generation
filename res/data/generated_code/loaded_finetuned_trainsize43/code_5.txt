import akka.actor.{Actor, ActorSystem, Props, Cancellable}
import scala.concurrent.duration._
import scala.util.{Success, Failure}

// Define messages
case object CallService
case class ServiceResponse(res: String)
case class ServiceFailure(error: String)
case object CircuitOpen
case class CircuitClosed

// Define the CircuitBreakerActor
class CircuitBreakerActor extends Actor {
  import context.dispatcher

  // Internal state
  var isClosed: Boolean = true
  var failureCount: Int = 0
  var maxFailures: Int = 3
  val timeout: FiniteDuration = 2.seconds
  val resetDelay: FiniteDuration = 5.seconds

  // External service (simulated for demonstration purposes)
  def serviceCall(): Future[Int] = {
    import context.dispatcher
    Future {
      if (failures() >= maxFailures) {
        404 // CircuitBreaker failed all attempts
      } else {
        // Simulate service failure for demonstration
        if (util.Random.nextBoolean()) {
          failureCount += 1
          ServiceFailure("Service failed.")
        } else {
          failureCount = 0
          ServiceResponse("Service succeeded.")
        }
      }
    }
  }

  def failures(): Int = {
    failureCount
  }

  def reset(): Unit = {
    isClosed = true
    failureCount = 0
  }

  def circuitOpen(): Unit = {
    isClosed = false
    context.become(openState)
  }

  def openState(): ReceiverActor => Either[String, String] = {
    case msg: ReceiverActor => {
      if (isClosed) {
        isClosed = false
        circuitClosed.send("Circuit breaker is now closed.")
      } else if (failures() >= maxFailures) {
        circuitOpen()
      } else {
        serviceCall().onComplete {
          case Success(res) => circuitClosed.send(res)
          case Failure(error) => circuitClosed.send(error)
        }
      }
    }
  }

  override def postStop(): Unit = {
    reset()
  }

  override def receive: ReceiveActor = {
    case CallService =>
      if (isClosed) {
        circuitOpen()
      } else {
        serviceCall().onComplete {
          case Success(res) =>
            sender()! ServiceResponse(res)
          case Failure(error) =>
            sender()! ServiceFailure(error)
        }
      }
    case CircuitOpen =>
      sender()! Circuit