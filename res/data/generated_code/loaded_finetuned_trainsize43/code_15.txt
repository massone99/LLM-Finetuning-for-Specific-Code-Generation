import akka.actor.{Actor, ActorSystem, Props}

// Define the LimitedProcessorActor
class LimitedProcessorActor extends Actor {
  // Initialize the message queue
  var messageQueue: Array[String] = Array.empty

  // Process the next message in the queue if available
  def processNextMessage: Unit = {
    messageQueue match {
      case Array(msg1) =>
        println(s"Processing message: $msg1")
        messageQueue = messageQueue.drop(1)
      case Array(msg2) =>
        println(s"Processing message: $msg2")
        messageQueue = messageQueue.drop(2)
      case _ =>
        println("Message queue is empty. Processing complete.")
    }
  }

  // Schedule processing of the next message in the queue
  override def receive: Receive = {
    case msg: String =>
      messageQueue = messageQueue ++ Array(msg) // Add message to queue
      println(s"Actor received message: $msg. Queue size: ${messageQueue.length}")
      if (messageQueue.length > 0) {
        scheduleNextMessage() // Schedule next message for processing
      }
    case "ScheduleNextMessage" =>
      processNextMessage()
      sender()! "Processing of message queue resumed."
    case _ =>
      println("Actor received unknown message.")
  }

  // Schedule the next message for processing
  def scheduleNextMessage(): Unit =
    context.system.scheduler.scheduleOnce(5000, receiveRef => processNextMessage())

  val receiveRef: Ref[Receive] = Ref receive {}

  override def postStop(): Unit = {
    receiveRef!')
  }
}

// Usage Example
object LimitedProcessorApp extends App {
  val system = ActorSystem("LimitedProcessorSystem")
  val processor = system.actorOf(Props[LimitedProcessorActor](), "processorActor")

  // Send multiple messages to the processor
  processor! "Message 1"
  processor! "Message 2"
  processor! "Message 3"
  processor! "Message 4" // This should be processed next

  // Allow some time for processing before shutdown
  Thread.sleep(20000)
  system.terminate()
}