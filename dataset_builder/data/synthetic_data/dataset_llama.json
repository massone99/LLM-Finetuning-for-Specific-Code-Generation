[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that receives a message and sends the same message back to the sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the EchoActor\nclass EchoActor extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! msg\n  }\n}\n\n// Usage Example\nobject EchoApp extends App {\n  val system = ActorSystem(\"EchoSystem\")\n  val echoActor = system.actorOf(Props[EchoActor](), \"echoActor\")\n\n  echoActor ! \"Hello, Actor!\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that maintains a counter. It should handle two messages: one to increment the counter and another to retrieve its current value."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Messages\ncase object Increment\ncase object GetCount\n\n// Define the CounterActor\nclass CounterActor extends Actor {\n  var count = 0\n\n  def receive: Receive = {\n    case Increment =>\n      count += 1\n    case GetCount =>\n      sender() ! count\n  }\n}\n\n// Usage Example\nobject CounterApp extends App {\n  val system = ActorSystem(\"CounterSystem\")\n  val counter = system.actorOf(Props[CounterActor](), \"counter\")\n\n  counter ! Increment\n  counter ! Increment\n  counter ! GetCount\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Supervisor Actor in Scala that supervises a child actor. The supervisor should restart the child in case of any failure"
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy, Terminated}\nimport akka.actor.SupervisorStrategy._\n\nimport scala.concurrent.duration._\n\n// Define the ChildActor\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case \"fail\" => throw new Exception(\"Child failed!\")\n    case msg    => println(s\"Child received: $msg\")\n  }\n}\n\n// Define the SupervisorActor\nclass SupervisorActor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(\n    maxNrOfRetries = 3,\n    withinTimeRange = 1.minute\n  ) {\n    case _: Exception => Restart\n  }\n\n  val child: ActorRef = context.actorOf(Props[ChildActor](), \"childActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example\nobject SupervisorApp extends App {\n  val system = ActorSystem(\"SupervisorSystem\")\n  val supervisor = system.actorOf(Props[SupervisorActor](), \"supervisor\")\n\n  supervisor ! \"Hello\"\n  supervisor ! \"fail\"\n  supervisor ! \"Are you there?\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Develop an Akka Router Actor in Scala that distributes incoming messages to a pool of worker actors using a round-robin strategy."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\n// Define the WorkerActor\nclass WorkerActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"${self.path.name} processed message: $msg\")\n  }\n}\n\n// Usage Example\nobject RouterApp extends App {\n  val system = ActorSystem(\"RouterSystem\")\n  \n  // Create a router with 5 worker actors\n  val router: ActorRef = system.actorOf(\n    RoundRobinPool(5).props(Props[WorkerActor]()),\n    \"workerRouter\"\n  )\n\n  // Send messages to the router\n  for (i <- 1 to 10) {\n    router ! s\"Message $i\"\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Persistent Actor in Scala that records events to maintain state across restarts. The actor should handle commands to add items and retrieve the current list of items."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{ActorSystem, Props}\nimport akka.persistence.{PersistentActor, SnapshotOffer}\n\n// Commands and Events\nsealed trait Command\ncase class AddItem(item: String) extends Command\ncase object GetItems extends Command\n\nsealed trait Event\ncase class ItemAdded(item: String) extends Event\n\n// Define the Persistent Actor\nclass ShoppingCart extends PersistentActor {\n  override def persistenceId: String = \"shopping-cart-1\"\n\n  var items: List[String] = Nil\n\n  def updateState(event: Event): Unit = event match {\n    case ItemAdded(item) => items ::= item\n  }\n\n  def receiveCommand: Receive = {\n    case AddItem(item) =>\n      persist(ItemAdded(item)) { event =>\n        updateState(event)\n        println(s\"Added item: $item\")\n      }\n    case GetItems =>\n      sender() ! items.reverse\n  }\n\n  def receiveRecover: Receive = {\n    case event: Event => updateState(event)\n    case SnapshotOffer(_, snapshot: List[String]) =>\n      items = snapshot\n  }\n}\n\n// Usage Example\nobject PersistentActorApp extends App {\n  val system = ActorSystem(\"PersistentSystem\")\n  val cart = system.actorOf(Props[ShoppingCart](), \"shoppingCart\")\n\n  cart ! AddItem(\"Apple\")\n  cart ! AddItem(\"Banana\")\n  cart ! GetItems\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that performs a periodic task every 5 seconds, such as printing a heartbeat message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\n\ncase object Tick\n\n// Define the HeartbeatActor\nclass HeartbeatActor extends Actor {\n  import context.dispatcher\n  context.system.scheduler.scheduleWithFixedDelay(0.seconds, 5.seconds, self, Tick)\n\n  def receive: Receive = {\n    case Tick =>\n      println(\"Heartbeat: I'm alive!\")\n  }\n}\n\n// Usage Example\nobject HeartbeatApp extends App {\n  val system = ActorSystem(\"HeartbeatSystem\")\n  val heartbeatActor = system.actorOf(Props[HeartbeatActor](), \"heartbeatActor\")\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that can handle different types of messages, such as strings, integers, and custom case classes, performing different actions based on the message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define custom messages\ncase class Greet(name: String)\ncase class Calculate(a: Int, b: Int)\n\n// Define the MultiMessageActor\nclass MultiMessageActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"Received string message: $msg\")\n    case Greet(name) =>\n      println(s\"Hello, $name!\")\n    case Calculate(a, b) =>\n      println(s\"The sum of $a and $b is ${a + b}\")\n    case _ =>\n      println(\"Unknown message received.\")\n  }\n}\n\n// Usage Example\nobject MultiMessageApp extends App {\n  val system = ActorSystem(\"MultiMessageSystem\")\n  val multiActor = system.actorOf(Props[MultiMessageActor](), \"multiActor\")\n\n  multiActor ! \"A simple string\"\n  multiActor ! Greet(\"Alice\")\n  multiActor ! Calculate(5, 7)\n  multiActor ! 42 // This will trigger the unknown message case\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that communicates with multiple other actors, sending messages and aggregating responses."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define worker actors\nclass Worker(id: Int) extends Actor {\n  def receive: Receive = {\n    case \"work\" =>\n      sender() ! s\"Worker $id completed work.\"\n  }\n}\n\n// Define the ManagerActor\nclass Manager(numWorkers: Int) extends Actor {\n  // Create worker actors\n  val workers: IndexedSeq[ActorRef] = for (i <- 1 to numWorkers) yield {\n    context.actorOf(Props(new Worker(i)), s\"worker$i\")\n  }\n\n  def receive: Receive = {\n    case \"start\" =>\n      workers.foreach(_ ! \"work\")\n    case msg =>\n      println(s\"Manager received: $msg\")\n  }\n}\n\n// Usage Example\nobject ManagerApp extends App {\n  val system = ActorSystem(\"ManagerSystem\")\n  val manager = system.actorOf(Props(new Manager(3)), \"manager\")\n\n  manager ! \"start\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named BatchingActor that collects incoming integer messages and processes them in batches of three. Upon receiving the third message, it should calculate and print the sum of the batch and then reset to collect the next batch. Demonstrate the batching behavior by sending multiple messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the BatchingActor\nclass BatchingActor extends Actor {\n  var buffer: List[Int] = List.empty\n\n  def receive: Receive = {\n    case num: Int =>\n      buffer = num :: buffer\n      println(s\"BatchingActor received: $num (Buffer size: ${buffer.size})\")\n      if (buffer.size >= 3) {\n        val sum = buffer.sum\n        println(s\"BatchingActor processing batch: ${buffer.reverse} with sum: $sum\")\n        buffer = List.empty\n      }\n    case _ =>\n      println(\"BatchingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BatchingActorApp extends App {\n  val system = ActorSystem(\"BatchingActorSystem\")\n  val batchingActor = system.actorOf(Props[BatchingActor](), \"batchingActor\")\n\n  // Send multiple integer messages\n  batchingActor ! 5\n  batchingActor ! 10\n  batchingActor ! 15  // This should trigger batch processing\n  batchingActor ! 20\n  batchingActor ! 25\n  batchingActor ! 30  // Another batch processing\n  batchingActor ! 35  // Partial batch\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named SlidingWindowRateLimiter that limits the number of messages it processes to 5 per 10-second sliding window. If the rate exceeds this limit, the actor should respond with \"Rate limit exceeded\" instead of processing the message. Refill the bucket with 5 tokens every 10 seconds. Demonstrate sending messages at varying rates and observing the rate limiter in action."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.collection.mutable.Queue\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext\n\n// Define messages\ncase class Request(id: Int)\ncase class Response(message: String)\n\n// Define the SlidingWindowRateLimiter Actor\nclass SlidingWindowRateLimiter extends Actor {\n  import context.dispatcher\n\n  val maxTokens: Int = 5\n  var tokens: Int = maxTokens\n  val requestQueue: Queue[(ActorRef, Request)] = Queue.empty\n\n  // Schedule token refill every 10 seconds\n  val refillInterval: FiniteDuration = 10.seconds\n  val refillTask: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = refillInterval,\n    delay = refillInterval,\n    receiver = self,\n    message = \"Refill\"\n  )\n\n  def receive: Receive = {\n    case \"Refill\" =>\n      tokens = maxTokens\n      println(s\"RateLimiterActor: Tokens refilled to $tokens\")\n      processQueue()\n\n    case req @ Request(id) =>\n      if (tokens > 0) {\n        tokens -= 1\n        println(s\"RateLimiterActor: Processed request $id (Tokens left: $tokens)\")\n        sender() ! Response(s\"Processed request $id\")\n      } else {\n        println(s\"RateLimiterActor: Rate limit exceeded for request $id. Queuing request.\")\n        requestQueue.enqueue((sender(), req))\n      }\n\n    case _ =>\n      println(\"RateLimiterActor received unknown message.\")\n  }\n\n  def processQueue(): Unit = {\n    while (tokens > 0 && requestQueue.nonEmpty) {\n      val (senderRef, Request(id)) = requestQueue.dequeue()\n      tokens -= 1\n      println(s\"RateLimiterActor: Processed queued request $id (Tokens left: $tokens)\")\n      senderRef ! Response(s\"Processed request $id\")\n    }\n  }\n\n  override def postStop(): Unit = {\n    refillTask.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SlidingWindowRateLimiterApp extends App {\n  import akka.pattern.ask\n  import akka.util.Timeout\n  import scala.concurrent.Await\n\n  val system = ActorSystem(\"SlidingWindowRateLimiterSystem\")\n  val rateLimiter = system.actorOf(Props[SlidingWindowRateLimiter](), \"rateLimiterActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to send a request and print the response\n  def sendRequest(id: Int): Unit = {\n    val future = rateLimiter ? Request(id)\n    val result = Await.result(future, timeout.duration).asInstanceOf[Response]\n    println(s\"Request $id: ${result.message}\")\n  }\n\n  // Send 7 requests rapidly (should exceed the limit)\n  for (i <- 1 to 7) {\n    sendRequest(i)\n  }\n\n  // Send 3 requests after 12 seconds (should be allowed)\n  system.scheduler.scheduleOnce(12.seconds) {\n    for (i <- 8 to 10) {\n      sendRequest(i)\n    }\n  }(system.dispatcher)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(15000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Supervisor Actor in Scala named ResumeSupervisor that supervises a child actor named ResumeChildActor. The child actor should throw a RuntimeException when it receives a \"runtime\" message and an IllegalArgumentException when it receives an \"illegal\" message. Configure the supervisor's strategy to resume the child actor on RuntimeException and stop it on IllegalArgumentException. Demonstrate the different outcomes by sending both types of messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy._\nimport scala.concurrent.duration._\n\n// Define the ResumeChildActor\nclass ResumeChildActor extends Actor {\n  def receive: Receive = {\n    case \"runtime\" =>\n      println(s\"${self.path.name} received 'runtime' and will throw RuntimeException.\")\n      throw new RuntimeException(\"Simulated RuntimeException.\")\n    case \"illegal\" =>\n      println(s\"${self.path.name} received 'illegal' and will throw IllegalArgumentException.\")\n      throw new IllegalArgumentException(\"Simulated IllegalArgumentException.\")\n    case msg =>\n      println(s\"${self.path.name} received message: $msg\")\n  }\n}\n\n// Define the ResumeSupervisor Actor\nclass ResumeSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy() {\n    case _: RuntimeException =>\n      println(\"ResumeSupervisor: Resuming child actor after RuntimeException.\")\n      Resume\n    case _: IllegalArgumentException =>\n      println(\"ResumeSupervisor: Stopping child actor after IllegalArgumentException.\")\n      Stop\n    case _: Exception =>\n      println(\"ResumeSupervisor: Escalating unknown exception.\")\n      Escalate\n  }\n\n  // Create the child actor\n  val child: ActorRef = context.actorOf(Props[ResumeChildActor](), \"resumeChildActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ResumeSupervisorApp extends App {\n  val system = ActorSystem(\"ResumeSupervisorSystem\")\n  val supervisor = system.actorOf(Props[ResumeSupervisor](), \"resumeSupervisor\")\n\n  // Send a message that causes RuntimeException (should resume)\n  supervisor ! \"runtime\"\n  supervisor ! \"Post-runtime message\"\n\n  // Send a message that causes IllegalArgumentException (should stop)\n  supervisor ! \"illegal\"\n  supervisor ! \"Post-illegal message\"\n\n  // Allow some time for supervision to take effect before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named InitiatorActor that starts a workflow by sending a StartWorkflow message to WorkflowActor. Upon receiving a WorkflowStarted message from WorkflowActor, InitiatorActor should send a ProcessStep message to StepActor. StepActor processes the step and replies with StepCompleted. Upon receiving StepCompleted, InitiatorActor sends a CompleteWorkflow message back to WorkflowActor. Demonstrate the complete message flow between these actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase object StartWorkflow\ncase object WorkflowStarted\ncase object ProcessStep\ncase object StepCompleted\ncase object CompleteWorkflow\n\n// Define the WorkflowActor\nclass WorkflowActor extends Actor {\n  def receive: Receive = {\n    case StartWorkflow =>\n      println(s\"${self.path.name} received StartWorkflow. Starting workflow...\")\n      sender() ! WorkflowStarted\n    case CompleteWorkflow =>\n      println(s\"${self.path.name} received CompleteWorkflow. Workflow completed.\")\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the StepActor\nclass StepActor extends Actor {\n  def receive: Receive = {\n    case ProcessStep =>\n      println(s\"${self.path.name} processing step...\")\n      // Simulate step processing\n      Thread.sleep(500)\n      println(s\"${self.path.name} completed step.\")\n      sender() ! StepCompleted\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the InitiatorActor\nclass InitiatorActor(workflow: ActorRef, step: ActorRef) extends Actor {\n  def receive: Receive = {\n    case StartWorkflow =>\n      println(s\"${self.path.name} initiating workflow.\")\n      workflow ! StartWorkflow\n    case WorkflowStarted =>\n      println(s\"${self.path.name} received WorkflowStarted. Sending ProcessStep.\")\n      step ! ProcessStep\n    case StepCompleted =>\n      println(s\"${self.path.name} received StepCompleted. Completing workflow.\")\n      workflow ! CompleteWorkflow\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject WorkflowApp extends App {\n  val system = ActorSystem(\"WorkflowSystem\")\n\n  val workflowActor = system.actorOf(Props[WorkflowActor](), \"workflowActor\")\n  val stepActor = system.actorOf(Props[StepActor](), \"stepActor\")\n  val initiator = system.actorOf(Props(new InitiatorActor(workflowActor, stepActor)), \"initiatorActor\")\n\n  // Start the workflow\n  initiator ! StartWorkflow\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CacheActor that acts as an in-memory cache. It should handle Put(key: String, value: String) messages to store key-value pairs and Get(key: String) messages to retrieve values. Upon receiving a Get message, it should respond with ValueFound(key: String, value: String) if the key exists or ValueNotFound(key: String) if it doesn't. Demonstrate storing and retrieving values from the cache."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Put(key: String, value: String)\ncase class Get(key: String)\ncase class ValueFound(key: String, value: String)\ncase class ValueNotFound(key: String)\n\n// Define the CacheActor\nclass CacheActor extends Actor {\n  var cache: Map[String, String] = Map.empty\n\n  def receive: Receive = {\n    case Put(key, value) =>\n      cache += (key -> value)\n      println(s\"CacheActor stored: [$key -> $value]\")\n    case Get(key) =>\n      cache.get(key) match {\n        case Some(value) =>\n          sender() ! ValueFound(key, value)\n        case None =>\n          sender() ! ValueNotFound(key)\n      }\n    case _ =>\n      println(\"CacheActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CacheApp extends App {\n  val system = ActorSystem(\"CacheSystem\")\n  val cacheActor = system.actorOf(Props[CacheActor](), \"cacheActor\")\n\n  // Define a simple responder actor to handle cache responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case ValueFound(key, value) =>\n        println(s\"ResponderActor: Found [$key -> $value] in cache.\")\n      case ValueNotFound(key) =>\n        println(s\"ResponderActor: No entry found for key '$key'.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor)(), \"responderActor\")\n\n  // Store some key-value pairs\n  cacheActor ! Put(\"name\", \"Alice\")\n  cacheActor ! Put(\"city\", \"Wonderland\")\n\n  // Retrieve existing and non-existing keys\n  cacheActor.tell(Get(\"name\"), responder)\n  cacheActor.tell(Get(\"country\"), responder)\n\n  // Delete a record and query again\n  cacheActor ! Delete(\"Bob\")\n  cacheActor.tell(Get(\"Bob\"), responder)\n\n  // Attempt to delete a non-existing record\n  cacheActor ! Delete(\"Charlie\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named LoggingActor that logs incoming messages to a file. It should handle Log(message: String) messages by appending them to a specified log file. Ensure that the actor handles file I/O exceptions gracefully by logging errors to the console. Demonstrate logging multiple messages to a file."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport java.io.{File, FileWriter, BufferedWriter}\nimport scala.util.{Try, Success, Failure}\n\n// Define messages\ncase class Log(message: String)\n\n// Define the LoggingActor\nclass LoggingActor(logFilePath: String) extends Actor {\n  // Initialize the log file\n  val logFile: File = new File(logFilePath)\n  val bw: BufferedWriter = new BufferedWriter(new FileWriter(logFile, true)) // Append mode\n\n  override def postStop(): Unit = {\n    bw.close()\n    super.postStop()\n  }\n\n  def receive: Receive = {\n    case Log(msg) =>\n      Try {\n        bw.write(s\"${java.time.LocalDateTime.now()}: $msg\\n\")\n        bw.flush()\n      } match {\n        case Success(_) =>\n          println(s\"LoggingActor: Logged message to $logFilePath\")\n        case Failure(exception) =>\n          println(s\"LoggingActor encountered an error: ${exception.getMessage}\")\n      }\n    case _ =>\n      println(\"LoggingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LoggingApp extends App {\n  val system = ActorSystem(\"LoggingSystem\")\n  val loggingActor = system.actorOf(Props(new LoggingActor(\"application.log\")), \"loggingActor\")\n\n  // Define a simple logger to send Log messages\n  class Logger extends Actor {\n    def receive: Receive = {\n      case msg: String =>\n        loggingActor ! Log(msg)\n      case _ =>\n        println(\"Logger received unknown message.\")\n    }\n  }\n\n  val logger = system.actorOf(Props[Logger](), \"logger\")\n\n  // Send log messages\n  logger ! \"Application started.\"\n  logger ! \"Performing some operations.\"\n  logger ! \"Application finished successfully.\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AuthenticationActor that manages user authentication. It should handle Login(username: String, password: String) and Logout(username: String) messages. Maintain an internal Set of authenticated users. Upon successful login (assume any password is valid for simplicity), add the user to the set and respond with LoginSuccess(username: String). Upon logout, remove the user and respond with LogoutSuccess(username: String). Demonstrate logging in and out users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Login(username: String, password: String)\ncase class Logout(username: String)\ncase class LoginSuccess(username: String)\ncase class LogoutSuccess(username: String)\ncase class AuthenticationFailure(username: String, reason: String)\n\n// Define the AuthenticationActor\nclass AuthenticationActor extends Actor {\n  var authenticatedUsers: Set[String] = Set.empty\n\n  def receive: Receive = {\n    case Login(username, password) =>\n      // For simplicity, accept any password\n      if (!authenticatedUsers.contains(username)) {\n        authenticatedUsers += username\n        println(s\"AuthenticationActor: User '$username' logged in.\")\n        sender() ! LoginSuccess(username)\n      } else {\n        sender() ! AuthenticationFailure(username, \"User already logged in.\")\n      }\n\n    case Logout(username) =>\n      if (authenticatedUsers.contains(username)) {\n        authenticatedUsers -= username\n        println(s\"AuthenticationActor: User '$username' logged out.\")\n        sender() ! LogoutSuccess(username)\n      } else {\n        sender() ! AuthenticationFailure(username, \"User not logged in.\")\n      }\n\n    case _ =>\n      println(\"AuthenticationActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject AuthenticationApp extends App {\n  val system = ActorSystem(\"AuthenticationSystem\")\n  val authActor = system.actorOf(Props(new AuthenticationActor()), \"authenticationActor\")\n\n  // Define a simple responder actor to handle authentication responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case LoginSuccess(username) =>\n        println(s\"ResponderActor: User '$username' successfully logged in.\")\n      case LogoutSuccess(username) =>\n        println(s\"ResponderActor: User '$username' successfully logged out.\")\n      case AuthenticationFailure(username, reason) =>\n        println(s\"ResponderActor: Authentication failed for '$username'. Reason: $reason\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Perform login and logout operations\n  authActor.tell(Login(\"Alice\", \"password123\"), responder)\n  authActor.tell(Login(\"Bob\", \"securepass\"), responder)\n  authActor.tell(Login(\"Alice\", \"newpassword\"), responder) // Attempt duplicate login\n  authActor.tell(Logout(\"Alice\"), responder)\n  authActor.tell(Logout(\"Charlie\"), responder) // Attempt logout of non-logged-in user\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TopicPublisherActor that publishes messages to specific topics. It should handle Subscribe(topic: String) and Publish(topic: String, message: String) messages. Maintain a mapping of topics to subscriber actors. Upon publishing, send the message only to subscribers of the specified topic wrapped in a TopicMessage(topic: String, message: String) message. Demonstrate subscribing to different topics and publishing messages accordingly."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(topic: String)\ncase class Publish(topic: String, message: String)\ncase class TopicMessage(topic: String, message: String)\n\n// Define the TopicPublisherActor\nclass TopicPublisherActor extends Actor {\n  var topicSubscribers: Map[String, Set[ActorRef]] = Map.empty.withDefaultValue(Set.empty)\n\n  def receive: Receive = {\n    case Subscribe(topic) =>\n      topicSubscribers += topic -> (topicSubscribers(topic) + sender())\n      println(s\"TopicPublisherActor: ${sender().path.name} subscribed to topic '$topic'\")\n    case Publish(topic, message) =>\n      println(s\"TopicPublisherActor: Publishing message to topic '$topic': $message\")\n      topicSubscribers(topic).foreach(_ ! TopicMessage(topic, message))\n    case _ =>\n      println(\"TopicPublisherActor received unknown message.\")\n  }\n}\n\n// Define the SubscriberActor\nclass SubscriberActor(name: String) extends Actor {\n  def receive: Receive = {\n    case TopicMessage(topic, message) =>\n      println(s\"Subscriber [$name] received on '$topic': $message\")\n    case _ =>\n      println(s\"Subscriber [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TopicPubSubApp extends App {\n  val system = ActorSystem(\"TopicPubSubSystem\")\n  val publisher = system.actorOf(Props(new TopicPublisherActor()), \"publisherActor\")\n\n  // Create subscriber actors\n  val subscriber1 = system.actorOf(Props(new SubscriberActor(\"Alice\")), \"subscriber1\")\n  val subscriber2 = system.actorOf(Props(new SubscriberActor(\"Bob\")), \"subscriber2\")\n  val subscriber3 = system.actorOf(Props(new SubscriberActor(\"Charlie\")), \"subscriber3\")\n\n  // Subscribers subscribe to topics\n  subscriber1 ! Subscribe(\"news\")\n  subscriber2 ! Subscribe(\"sports\")\n  subscriber3 ! Subscribe(\"news\")\n  subscriber3 ! Subscribe(\"sports\")\n\n  // Publish messages to topics\n  publisher ! Publish(\"news\", \"Breaking News: Akka Actors are awesome!\")\n  publisher ! Publish(\"sports\", \"Sports Update: Local team wins championship.\")\n  publisher ! Publish(\"entertainment\", \"New movie released this weekend.\") // No subscribers\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named RetryingActor that handles PerformTask(taskId: Int) messages. Upon receiving a task, it attempts to perform it by randomly succeeding or failing. If a task fails, it should retry up to two additional times before giving up and logging \"Task <taskId> failed after retries.\". Demonstrate the retry mechanism by sending multiple tasks."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.util.Random\n\n// Define messages\ncase class PerformTask(taskId: Int)\ncase class TaskResult(taskId: Int, success: Boolean)\ncase class RetryTask(taskId: Int, attempt: Int)\n\n// Define the RetryingActor\nclass RetryingActor extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case PerformTask(taskId) =>\n      println(s\"RetryingActor: Performing task $taskId (Attempt 1)\")\n      performTask(taskId, attempt = 1)\n    case RetryTask(taskId, attempt) =>\n      println(s\"RetryingActor: Retrying task $taskId (Attempt $attempt)\")\n      performTask(taskId, attempt)\n    case TaskResult(taskId, success) =>\n      if (success) {\n        println(s\"RetryingActor: Task $taskId completed successfully.\")\n      } else {\n        println(s\"RetryingActor: Task $taskId failed.\")\n        if (sender().path.name.startsWith(\"retry\")) {\n          val attempt = sender().path.name.split(\"-\")(1).toInt\n          if (attempt < 3) {\n            // Schedule a retry\n            context.system.scheduler.scheduleOnce(1.second, self, RetryTask(taskId, attempt + 1))\n          } else {\n            println(s\"RetryingActor: Task $taskId failed after retries.\")\n          }\n        }\n      }\n    case _ =>\n      println(\"RetryingActor received unknown message.\")\n  }\n\n  def performTask(taskId: Int, attempt: Int): Unit = {\n    val success = Random.nextBoolean()\n    if (success) {\n      self.tell(TaskResult(taskId, success = true), self)\n    } else {\n      // Create a unique sender name for retries\n      val retrySender = context.actorOf(Props(new Actor {\n        def receive: Receive = {\n          case msg => self.tell(msg, self)\n        }\n      }), name = s\"retry-$attempt\")\n      retrySender ! TaskResult(taskId, success = false)\n    }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject RetryingActorApp extends App {\n  val system = ActorSystem(\"RetryingActorSystem\")\n  val retryingActor = system.actorOf(Props[RetryingActor](), \"retryingActor\")\n\n  // Send multiple tasks\n  for (i <- 1 to 5) {\n    retryingActor ! PerformTask(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(10000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named ReceiverActor that listens for messages and responds based on message content. It should handle messages like Ping and custom case classes like Data(data: String). For Ping, respond with Pong, and for Data, respond with DataReceived(data). Demonstrate sending different types of messages and handling responses."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define messages\ncase object Ping\ncase object Pong\ncase class Data(data: String)\ncase class DataReceived(data: String)\n\n// Define the ReceiverActor\nclass ReceiverActor extends Actor {\n  def receive: Receive = {\n    case Ping =>\n      println(s\"ReceiverActor received Ping from ${sender().path.name}\")\n      sender() ! Pong\n    case Data(data) =>\n      println(s\"ReceiverActor received Data: '$data' from ${sender().path.name}\")\n      sender() ! DataReceived(data)\n    case _ =>\n      println(\"ReceiverActor received unknown message.\")\n  }\n}\n\n// Define the SenderActor\nclass SenderActor(receiver: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(3.seconds)\n\n  def receive: Receive = {\n    case msg =>\n      println(s\"SenderActor: Sending message '$msg' to ReceiverActor.\")\n      val future = receiver ? msg\n      future.onComplete {\n        case Success(response) =>\n          println(s\"SenderActor received response: $response\")\n        case Failure(ex) =>\n          println(s\"SenderActor failed to receive response: ${ex.getMessage}\")\n      }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ReceiverApp extends App {\n  val system = ActorSystem(\"ReceiverSystem\")\n  val receiver = system.actorOf(Props[ReceiverActor](), \"receiverActor\")\n  val senderActor = system.actorOf(Props(new SenderActor(receiver)), \"senderActor\")\n\n  // Send different types of messages\n  senderActor ! Ping\n  senderActor ! Data(\"Sample data\")\n  senderActor ! \"Unknown message\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named StreamProcessorActor that consumes a stream of integers. It should handle StreamData(data: Int) messages by accumulating the data and, every time the sum of the accumulated data exceeds 100, emit a ProcessedStream(sum: Int) message with the current sum and reset the accumulator. Demonstrate processing a sequence of StreamData messages and emitting ProcessedStream messages accordingly."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class StreamData(data: Int)\ncase class ProcessedStream(sum: Int)\n\n// Define the StreamProcessorActor\nclass StreamProcessorActor extends Actor {\n  var accumulator: Int = 0\n\n  def receive: Receive = {\n    case StreamData(data) =>\n      accumulator += data\n      println(s\"StreamProcessorActor: Received data $data. Current sum: $accumulator\")\n      if (accumulator > 100) {\n        sender() ! ProcessedStream(accumulator)\n        println(s\"StreamProcessorActor: Sum exceeded 100. Emitting ProcessedStream($accumulator) and resetting accumulator.\")\n        accumulator = 0\n      }\n    case _ =>\n      println(\"StreamProcessorActor received unknown message.\")\n  }\n}\n\n// Define a ListenerActor to handle ProcessedStream messages\nclass ListenerActor extends Actor {\n  def receive: Receive = {\n    case ProcessedStream(sum) =>\n      println(s\"ListenerActor: ProcessedStream received with sum: $sum\")\n    case _ =>\n      println(\"ListenerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject StreamProcessorApp extends App {\n  val system = ActorSystem(\"StreamProcessorSystem\")\n  val streamProcessor = system.actorOf(Props[StreamProcessorActor](), \"streamProcessorActor\")\n  val listener = system.actorOf(Props[ListenerActor](), \"listenerActor\")\n\n  // Send a sequence of StreamData messages\n  val dataStream = List(30, 40, 50, 10, 20, 60)\n\n  dataStream.foreach { data =>\n    streamProcessor.tell(StreamData(data), listener)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named ResponderWithTimeout that replies to any Ping message with a Pong after a delay of 2 seconds. Implement a RequesterWithTimeout actor that sends a Ping message to ResponderWithTimeout and waits for a Pong reply with a timeout of 1 second. Handle the timeout scenario by printing \"Request timed out\" if no reply is received in time."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define messages\ncase object Ping\ncase object Pong\n\n// Define the ResponderWithTimeout Actor\nclass ResponderWithTimeout extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case Ping =>\n      println(s\"${self.path.name} received Ping. Will respond with Pong after delay.\")\n      context.system.scheduler.scheduleOnce(2.seconds, sender(), Pong)\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the RequesterWithTimeout Actor\nclass RequesterWithTimeout(responder: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(1.second)\n\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"${self.path.name} sending Ping to ${responder.path.name}\")\n      val future = responder ? Ping\n      future.onComplete {\n        case Success(Pong) =>\n          println(s\"${self.path.name} received Pong.\")\n        case Failure(_) =>\n          println(s\"${self.path.name} Request timed out.\")\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TimeoutApp extends App {\n  val system = ActorSystem(\"TimeoutSystem\")\n  \n  val responder = system.actorOf(Props[ResponderWithTimeout](), \"responderWithTimeout\")\n  val requester = system.actorOf(Props(new RequesterWithTimeout(responder)), \"requesterWithTimeout\")\n  \n  // Start the request\n  requester ! \"start\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(3000)\n  system.terminate()\n}"
      }
    ]
  }
]
