[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that receives a message and sends the same messageback to the sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the EchoActor\nclass EchoActor extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! msg\n  }\n}\n\n// Usage Example\nobject EchoApp extends App {\n  val system = ActorSystem(\"EchoSystem\")\n  val echoActor = system.actorOf(Props[EchoActor], \"echoActor\")\n\n  echoActor ! \"Hello, Actor!\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that maintains a counter. It should handle two messages: one to increment the counter and another to retrieve its current value."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Messages\ncase object Increment\ncase object GetCount\n\n// Define the CounterActor\nclass CounterActor extends Actor {\n  var count = 0\n\n  def receive: Receive = {\n    case Increment =>\n      count += 1\n    case GetCount =>\n      sender() ! count\n  }\n}\n\n// Usage Example\nobject CounterApp extends App {\n  val system = ActorSystem(\"CounterSystem\")\n  val counter = system.actorOf(Props[CounterActor], \"counter\")\n\n  counter ! Increment\n  counter ! Increment\n  counter ! GetCount\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Supervisor Actor in Scala that supervises a child actor. The supervisor should restart the child in case of any failure"
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy, Terminated}\nimport akka.actor.SupervisorStrategy._\n\nimport scala.concurrent.duration._\n\n// Define the ChildActor\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case \"fail\" => throw new Exception(\"Child failed!\")\n    case msg    => println(s\"Child received: $msg\")\n  }\n}\n\n// Define the SupervisorActor\nclass SupervisorActor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(\n    maxNrOfRetries = 3,\n    withinTimeRange = 1.minute\n  ) {\n    case _: Exception => Restart\n  }\n\n  val child: ActorRef = context.actorOf(Props[ChildActor], \"childActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example\nobject SupervisorApp extends App {\n  val system = ActorSystem(\"SupervisorSystem\")\n  val supervisor = system.actorOf(Props[SupervisorActor], \"supervisor\")\n\n  supervisor ! \"Hello\"\n  supervisor ! \"fail\"\n  supervisor ! \"Are you there?\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Develop an Akka Router Actor in Scala that distributes incoming messages to a pool of worker actors using a round-robin strategy."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\n// Define the WorkerActor\nclass WorkerActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"${self.path.name} processed message: $msg\")\n  }\n}\n\n// Usage Example\nobject RouterApp extends App {\n  val system = ActorSystem(\"RouterSystem\")\n  \n  // Create a router with 5 worker actors\n  val router: ActorRef = system.actorOf(\n    RoundRobinPool(5).props(Props[WorkerActor]),\n    \"workerRouter\"\n  )\n\n  // Send messages to the router\n  for (i <- 1 to 10) {\n    router ! s\"Message $i\"\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Persistent Actor in Scala that records events to maintain state across restarts. The actor should handle commands to add items and retrieve the current list of items."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{ActorSystem, Props}\nimport akka.persistence.{PersistentActor, SnapshotOffer}\n\n// Commands and Events\nsealed trait Command\ncase class AddItem(item: String) extends Command\ncase object GetItems extends Command\n\nsealed trait Event\ncase class ItemAdded(item: String) extends Event\n\n// Define the Persistent Actor\nclass ShoppingCart extends PersistentActor {\n  override def persistenceId: String = \"shopping-cart-1\"\n\n  var items: List[String] = Nil\n\n  def updateState(event: Event): Unit = event match {\n    case ItemAdded(item) => items ::= item\n  }\n\n  def receiveCommand: Receive = {\n    case AddItem(item) =>\n      persist(ItemAdded(item)) { event =>\n        updateState(event)\n        println(s\"Added item: $item\")\n      }\n    case GetItems =>\n      sender() ! items.reverse\n  }\n\n  def receiveRecover: Receive = {\n    case event: Event => updateState(event)\n    case SnapshotOffer(_, snapshot: List[String]) =>\n      items = snapshot\n  }\n}\n\n// Usage Example\nobject PersistentActorApp extends App {\n  val system = ActorSystem(\"PersistentSystem\")\n  val cart = system.actorOf(Props[ShoppingCart], \"shoppingCart\")\n\n  cart ! AddItem(\"Apple\")\n  cart ! AddItem(\"Banana\")\n  cart ! GetItems\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that performs a periodic task every 5 seconds, such as printing a heartbeat message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\n\ncase object Tick\n\n// Define the HeartbeatActor\nclass HeartbeatActor extends Actor {\n  import context.dispatcher\n  context.system.scheduler.scheduleWithFixedDelay(0.seconds, 5.seconds, self, Tick)\n\n  def receive: Receive = {\n    case Tick =>\n      println(\"Heartbeat: I'm alive!\")\n  }\n}\n\n// Usage Example\nobject HeartbeatApp extends App {\n  val system = ActorSystem(\"HeartbeatSystem\")\n  val heartbeatActor = system.actorOf(Props[HeartbeatActor], \"heartbeatActor\")\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that can handle different types of messages, such as strings, integers, and custom case classes, performing different actions based on the message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define custom messages\ncase class Greet(name: String)\ncase class Calculate(a: Int, b: Int)\n\n// Define the MultiMessageActor\nclass MultiMessageActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"Received string message: $msg\")\n    case Greet(name) =>\n      println(s\"Hello, $name!\")\n    case Calculate(a, b) =>\n      println(s\"The sum of $a and $b is ${a + b}\")\n    case _ =>\n      println(\"Unknown message received.\")\n  }\n}\n\n// Usage Example\nobject MultiMessageApp extends App {\n  val system = ActorSystem(\"MultiMessageSystem\")\n  val multiActor = system.actorOf(Props[MultiMessageActor], \"multiActor\")\n\n  multiActor ! \"A simple string\"\n  multiActor ! Greet(\"Alice\")\n  multiActor ! Calculate(5, 7)\n  multiActor ! 42 // This will trigger the unknown message case\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that communicates with multiple other actors, sending messages and aggregating responses."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define worker actors\nclass Worker(id: Int) extends Actor {\n  def receive: Receive = {\n    case \"work\" =>\n      sender() ! s\"Worker $id completed work.\"\n  }\n}\n\n// Define the ManagerActor\nclass Manager(numWorkers: Int) extends Actor {\n  // Create worker actors\n  val workers: IndexedSeq[ActorRef] = for (i <- 1 to numWorkers) yield {\n    context.actorOf(Props(new Worker(i)), s\"worker$i\")\n  }\n\n  def receive: Receive = {\n    case \"start\" =>\n      workers.foreach(_ ! \"work\")\n    case msg =>\n      println(s\"Manager received: $msg\")\n  }\n}\n\n// Usage Example\nobject ManagerApp extends App {\n  val system = ActorSystem(\"ManagerSystem\")\n  val manager = system.actorOf(Props(new Manager(3)), \"manager\")\n\n  manager ! \"start\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that changes its behavior based on the messages it receives using context.become"
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the ToggleActor\nclass ToggleActor extends Actor {\n  def active: Receive = {\n    case \"toggle\" =>\n      println(\"Switching to inactive state.\")\n      context.become(inactive)\n    case msg =>\n      println(s\"Active state received: $msg\")\n  }\n\n  def inactive: Receive = {\n    case \"toggle\" =>\n      println(\"Switching to active state.\")\n      context.become(active)\n    case msg =>\n      println(s\"Inactive state received: $msg\")\n  }\n\n  def receive: Receive = active\n}\n\n// Usage Example\nobject ToggleApp extends App {\n  val system = ActorSystem(\"ToggleSystem\")\n  val toggleActor = system.actorOf(Props[ToggleActor], \"toggleActor\")\n\n  toggleActor ! \"Hello\"\n  toggleActor ! \"toggle\"\n  toggleActor ! \"World\"\n  toggleActor ! \"toggle\"\n  toggleActor ! \"Back to active\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that uses the ask pattern to send a message and wait for a response asynchronously."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\n\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      sender() ! s\"Received your message: $msg\"\n  }\n}\n\n// Usage Example\nobject AskPatternApp extends App {\n  val system = ActorSystem(\"AskPatternSystem\")\n  val responder = system.actorOf(Props[ResponderActor], \"responder\")\n\n  implicit val timeout: Timeout = Timeout(5.seconds)\n  val future = responder ? \"Hello via ask pattern\"\n\n  val result = Await.result(future, timeout.duration).asInstanceOf[String]\n  println(result)\n\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named DynamicParentActor that can dynamically create child actors upon receiving a CreateChild(name: String) message. Each child actor should be named according to the provided name and simply print any message it receives. Demonstrate creating multiple children and sending messages to them through the parent."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class CreateChild(name: String)\ncase class SendMessageToChild(childName: String, message: String)\n\n// Define the ChildActor\nclass ChildActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ChildActor [$name] received message: $msg\")\n  }\n}\n\n// Define the DynamicParentActor\nclass DynamicParentActor extends Actor {\n  var children: Map[String, ActorRef] = Map.empty\n\n  def receive: Receive = {\n    case CreateChild(name) =>\n      if (!children.contains(name)) {\n        val child = context.actorOf(Props(new ChildActor(name)), name)\n        children += (name -> child)\n        println(s\"ParentActor created child actor with name: $name\")\n      } else {\n        println(s\"Child actor with name '$name' already exists.\")\n      }\n\n    case SendMessageToChild(childName, message) =>\n      children.get(childName) match {\n        case Some(child) =>\n          child ! message\n        case None =>\n          println(s\"No child actor found with name: $childName\")\n      }\n\n    case msg =>\n      println(s\"ParentActor received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DynamicParentApp extends App {\n  val system = ActorSystem(\"DynamicParentSystem\")\n  val parent = system.actorOf(Props[DynamicParentActor], \"parentActor\")\n\n  // Create child actors\n  parent ! CreateChild(\"child1\")\n  parent ! CreateChild(\"child2\")\n  parent ! CreateChild(\"child1\") // Attempt to create an existing child\n\n  // Send messages to child actors\n  parent ! SendMessageToChild(\"child1\", \"Hello Child 1!\")\n  parent ! SendMessageToChild(\"child2\", \"Hello Child 2!\")\n  parent ! SendMessageToChild(\"child3\", \"Hello Child 3!\") // Non-existent child\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named BufferedActor that buffers incoming messages and processes them at a controlled rate of one message every 500 milliseconds. Implement buffering such that incoming messages are stored in a queue if the actor is busy processing. Demonstrate sending multiple messages rapidly and observing the controlled processing rate."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.Queue\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext\n\n// Define the BufferedActor\nclass BufferedActor extends Actor {\n  import context.dispatcher\n\n  // Internal message queue\n  val messageQueue: Queue[String] = Queue.empty\n\n  // Processing state\n  var isProcessing: Boolean = false\n  var timer: Option[Cancellable] = None\n\n  def receive: Receive = {\n    case msg: String =>\n      messageQueue.enqueue(msg)\n      processNext()\n\n    case \"process\" =>\n      if (messageQueue.nonEmpty) {\n        val msg = messageQueue.dequeue()\n        println(s\"BufferedActor processing message: $msg\")\n        // Simulate processing delay\n        timer = Some(context.system.scheduler.scheduleOnce(500.milliseconds, self, \"process\"))\n      } else {\n        isProcessing = false\n      }\n  }\n\n  def processNext(): Unit = {\n    if (!isProcessing && messageQueue.nonEmpty) {\n      isProcessing = true\n      self ! \"process\"\n    }\n  }\n\n  override def postStop(): Unit = {\n    timer.foreach(_.cancel())\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BufferedActorApp extends App {\n  val system = ActorSystem(\"BufferedActorSystem\")\n  val bufferedActor = system.actorOf(Props[BufferedActor], \"bufferedActor\")\n\n  // Send multiple messages rapidly\n  for (i <- 1 to 5) {\n    bufferedActor ! s\"Message $i\"\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(4000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SelfTerminator that monitors the number of messages it has processed. After processing 10 messages, it should gracefully stop itself by sending a \"shutdown\" message to itself. Demonstrate the actor processing messages and terminating after the threshold is reached."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the SelfTerminator Actor\nclass SelfTerminator extends Actor {\n  var messageCount: Int = 0\n\n  def receive: Receive = {\n    case msg: String =>\n      messageCount += 1\n      println(s\"SelfTerminator processed message: $msg (Count: $messageCount)\")\n      if (messageCount >= 10) {\n        println(\"SelfTerminator reached message limit. Shutting down.\")\n        self ! \"shutdown\"\n      }\n    case \"shutdown\" =>\n      println(\"SelfTerminator is shutting itself down.\")\n      context.stop(self)\n    case _ =>\n      println(\"SelfTerminator received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelfTerminatorApp extends App {\n  val system = ActorSystem(\"SelfTerminatorSystem\")\n  val terminator = system.actorOf(Props[SelfTerminator], \"terminatorActor\")\n\n  // Send 12 messages to demonstrate termination after 10\n  for (i <- 1 to 12) {\n    terminator ! s\"Message $i\"\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named PriorityHandlerActor that handles high-priority and low-priority messages differently. Without using a custom mailbox, implement the actor such that it always processes high-priority messages (\"HighPriority\") before any pending low-priority messages (\"LowPriority\"), regardless of the order they were received."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Define the PriorityHandlerActor\nclass PriorityHandlerActor extends Actor with Stash {\n  def receive: Receive = {\n    case \"HighPriority\" =>\n      println(\"Processing High Priority message.\")\n      unstashAll()\n      context.become(normal)\n    case \"LowPriority\" =>\n      println(\"Stashing Low Priority message.\")\n      stash()\n    case msg =>\n      println(s\"Received unknown message: $msg\")\n  }\n\n  def normal: Receive = {\n    case \"HighPriority\" =>\n      println(\"Processing High Priority message.\")\n    case \"LowPriority\" =>\n      println(\"Processing Low Priority message.\")\n    case msg =>\n      println(s\"Received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PriorityHandlerApp extends App {\n  val system = ActorSystem(\"PriorityHandlerSystem\")\n  val priorityHandler = system.actorOf(Props[PriorityHandlerActor], \"priorityHandler\")\n\n  // Send messages in mixed order\n  priorityHandler ! \"LowPriority\"   // Should be stashed\n  priorityHandler ! \"LowPriority\"   // Should be stashed\n  priorityHandler ! \"HighPriority\"  // Should process immediately and unstash\n  priorityHandler ! \"HighPriority\"  // Should process immediately\n  priorityHandler ! \"LowPriority\"   // Should process now\n  priorityHandler ! \"LowPriority\"   // Should process now\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named ForwardingActor that forwards any received message to another actor named DestinationActor using the forward method. Ensure that the original sender is preserved when forwarding messages. Demonstrate the forwarding behavior by sending messages through the ForwardingActor and verifying that DestinationActor receives them with the correct sender reference."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the DestinationActor\nclass DestinationActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"DestinationActor received message: $msg from ${sender().path.name}\")\n  }\n}\n\n// Define the ForwardingActor\nclass ForwardingActor(destination: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ForwardingActor forwarding message: $msg\")\n      destination.forward(msg) // Preserves the original sender\n  }\n}\n\n// Define a Simple Sender Actor for demonstration\nclass SenderActor(forwarding: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"SenderActor sending message: $msg\")\n      forwarding ! msg\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ForwardingApp extends App {\n  val system = ActorSystem(\"ForwardingSystem\")\n  \n  val destination = system.actorOf(Props[DestinationActor], \"destinationActor\")\n  val forwarding = system.actorOf(Props(new ForwardingActor(destination)), \"forwardingActor\")\n  val senderActor = system.actorOf(Props(new SenderActor(forwarding)), \"senderActor\")\n  \n  // Send messages through the SenderActor\n  senderActor ! \"Hello via Forwarding!\"\n  senderActor ! \"Another forwarded message.\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TerminatorActor that performs a simple task upon receiving any message. Demonstrate the use of Akka's PoisonPill to forcefully terminate the actor after it processes a few messages. Verify that the actor stops receiving messages post-termination."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, PoisonPill}\n\n// Define the TerminatorActor\nclass TerminatorActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"TerminatorActor received message: $msg\")\n    case _ =>\n      println(\"TerminatorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TerminatorApp extends App {\n  val system = ActorSystem(\"TerminatorSystem\")\n  val terminator = system.actorOf(Props[TerminatorActor], \"terminatorActor\")\n\n  // Send messages to the actor\n  terminator ! \"Message 1\"\n  terminator ! \"Message 2\"\n  terminator ! \"Message 3\"\n\n  // Send PoisonPill to terminate the actor\n  terminator ! PoisonPill\n\n  // Attempt to send more messages after termination\n  terminator ! \"Message after PoisonPill\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named BatchingActor that collects incoming integer messages and processes them in batches of three. Upon receiving the third message, it should calculate and print the sum of the batch and then reset to collect the next batch. Demonstrate the batching behavior by sending multiple messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the BatchingActor\nclass BatchingActor extends Actor {\n  var buffer: List[Int] = List.empty\n\n  def receive: Receive = {\n    case num: Int =>\n      buffer = num :: buffer\n      println(s\"BatchingActor received: $num (Buffer size: ${buffer.size})\")\n      if (buffer.size >= 3) {\n        val sum = buffer.sum\n        println(s\"BatchingActor processing batch: ${buffer.reverse} with sum: $sum\")\n        buffer = List.empty\n      }\n    case _ =>\n      println(\"BatchingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BatchingActorApp extends App {\n  val system = ActorSystem(\"BatchingActorSystem\")\n  val batchingActor = system.actorOf(Props[BatchingActor], \"batchingActor\")\n\n  // Send multiple integer messages\n  batchingActor ! 5\n  batchingActor ! 10\n  batchingActor ! 15  // This should trigger batch processing\n  batchingActor ! 20\n  batchingActor ! 25\n  batchingActor ! 30  // Another batch processing\n  batchingActor ! 35  // Partial batch\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named SlidingWindowRateLimiter that limits the number of messages it processes to 5 per 10-second sliding window. If the rate exceeds this limit, the actor should respond with \"Rate limit exceeded\" instead of processing the message. Demonstrate the rate limiting by sending messages at varying rates."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.Queue\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext\n\n// Define the SlidingWindowRateLimiter Actor\nclass SlidingWindowRateLimiter extends Actor {\n  import context.dispatcher\n\n  val windowSize: FiniteDuration = 10.seconds\n  val maxMessages: Int = 5\n  val timestamps: Queue[Long] = Queue.empty\n\n  // Schedule periodic cleanup of old timestamps\n  val cleaner: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = 1.second,\n    delay = 1.second,\n    receiver = self,\n    message = \"clean\"\n  )\n\n  def receive: Receive = {\n    case \"clean\" =>\n      val cutoff = System.currentTimeMillis() - windowSize.toMillis\n      while (timestamps.nonEmpty && timestamps.head < cutoff) {\n        timestamps.dequeue()\n      }\n\n    case msg: String =>\n      val now = System.currentTimeMillis()\n      val cutoff = now - windowSize.toMillis\n\n      // Remove outdated timestamps\n      while (timestamps.nonEmpty && timestamps.head < cutoff) {\n        timestamps.dequeue()\n      }\n\n      if (timestamps.size < maxMessages) {\n        timestamps.enqueue(now)\n        println(s\"SlidingWindowRateLimiter processing message: $msg\")\n        // Process the message here\n      } else {\n        println(s\"SlidingWindowRateLimiter rate limit exceeded for message: $msg\")\n        sender() ! \"Rate limit exceeded\"\n      }\n\n    case _ =>\n      println(\"SlidingWindowRateLimiter received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    cleaner.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SlidingWindowRateLimiterApp extends App {\n  val system = ActorSystem(\"SlidingWindowRateLimiterSystem\")\n  val rateLimiter = system.actorOf(Props[SlidingWindowRateLimiter], \"rateLimiter\")\n\n  // Function to send messages at a specific interval\n  def sendMessages(interval: FiniteDuration, count: Int): Unit = {\n    import system.dispatcher\n    for (i <- 1 to count) {\n      system.scheduler.scheduleOnce(i * interval) {\n        rateLimiter ! s\"Message $i\"\n      }\n    }\n  }\n\n  // Send 7 messages rapidly (should exceed the limit)\n  sendMessages(1.second, 7)\n\n  // Send 3 messages after 12 seconds (should be allowed)\n  system.scheduler.scheduleOnce(12.seconds) {\n    for (i <- 8 to 10) {\n      rateLimiter ! s\"Message $i\"\n    }\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(15000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Supervisor Actor in Scala named ResumeSupervisor that supervises a child actor named ResumeChildActor. The child actor should throw a RuntimeException when it receives a \"runtime\" message and an IllegalArgumentException when it receives an \"illegal\" message. Configure the supervisor's strategy to resume the child actor on RuntimeException and stop it on IllegalArgumentException. Demonstrate the different outcomes by sending both types of messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy._\nimport scala.concurrent.duration._\n\n// Define the ResumeChildActor\nclass ResumeChildActor extends Actor {\n  def receive: Receive = {\n    case \"runtime\" =>\n      println(s\"${self.path.name} received 'runtime' and will throw RuntimeException.\")\n      throw new RuntimeException(\"Simulated RuntimeException.\")\n    case \"illegal\" =>\n      println(s\"${self.path.name} received 'illegal' and will throw IllegalArgumentException.\")\n      throw new IllegalArgumentException(\"Simulated IllegalArgumentException.\")\n    case msg =>\n      println(s\"${self.path.name} received message: $msg\")\n  }\n}\n\n// Define the ResumeSupervisor Actor\nclass ResumeSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy() {\n    case _: RuntimeException =>\n      println(\"ResumeSupervisor: Resuming child actor after RuntimeException.\")\n      Resume\n    case _: IllegalArgumentException =>\n      println(\"ResumeSupervisor: Stopping child actor after IllegalArgumentException.\")\n      Stop\n    case _: Exception =>\n      println(\"ResumeSupervisor: Escalating unknown exception.\")\n      Escalate\n  }\n\n  // Create the child actor\n  val child: ActorRef = context.actorOf(Props[ResumeChildActor], \"resumeChildActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ResumeSupervisorApp extends App {\n  val system = ActorSystem(\"ResumeSupervisorSystem\")\n  val supervisor = system.actorOf(Props[ResumeSupervisor], \"resumeSupervisor\")\n\n  // Send a message that causes RuntimeException (should resume)\n  supervisor ! \"runtime\"\n  supervisor ! \"Post-runtime message\"\n\n  // Send a message that causes IllegalArgumentException (should stop)\n  supervisor ! \"illegal\"\n  supervisor ! \"Post-illegal message\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor system in Scala with three actors: InitiatorActor, ResponderActor, and LoggerActor. The InitiatorActor sends a Request message to the ResponderActor. Upon receiving a Request, the ResponderActor replies with a Response message. The InitiatorActor then forwards this Response to the LoggerActor for logging. Demonstrate the message flow between these actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase object Request\ncase class Response(content: String)\ncase class LogMessage(message: String)\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Request =>\n      println(s\"${self.path.name} received Request.\")\n      sender() ! Response(\"Here is your response!\")\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the LoggerActor\nclass LoggerActor extends Actor {\n  def receive: Receive = {\n    case LogMessage(msg) =>\n      println(s\"LoggerActor logging message: $msg\")\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the InitiatorActor\nclass InitiatorActor(responder: ActorRef, logger: ActorRef) extends Actor {\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"${self.path.name} sending Request to ResponderActor.\")\n      responder ! Request\n    case Response(content) =>\n      println(s\"${self.path.name} received Response: $content\")\n      logger ! LogMessage(content)\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject MultipleActorsApp extends App {\n  val system = ActorSystem(\"MultipleActorsSystem\")\n\n  val logger = system.actorOf(Props[LoggerActor], \"loggerActor\")\n  val responder = system.actorOf(Props[ResponderActor], \"responderActor\")\n  val initiator = system.actorOf(Props(new InitiatorActor(responder, logger)), \"initiatorActor\")\n\n  // Start the message flow\n  initiator ! \"start\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named MultiTypeActor that handles three different message types: TextMessage(content: String), NumberMessage(value: Int), and Shutdown. For TextMessage, it should print the content. For NumberMessage, it should calculate and print the square of the value. Upon receiving Shutdown, it should gracefully stop itself. Demonstrate handling each message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define messages\ncase class TextMessage(content: String)\ncase class NumberMessage(value: Int)\ncase object Shutdown\n\n// Define the MultiTypeActor\nclass MultiTypeActor extends Actor {\n  def receive: Receive = {\n    case TextMessage(content) =>\n      println(s\"MultiTypeActor received TextMessage: $content\")\n    case NumberMessage(value) =>\n      val square = value * value\n      println(s\"MultiTypeActor received NumberMessage: $value, square: $square\")\n    case Shutdown =>\n      println(\"MultiTypeActor received Shutdown. Stopping...\")\n      context.stop(self)\n    case _ =>\n      println(\"MultiTypeActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject MultiTypeActorApp extends App {\n  val system = ActorSystem(\"MultiTypeActorSystem\")\n  val multiTypeActor = system.actorOf(Props[MultiTypeActor], \"multiTypeActor\")\n\n  // Send different types of messages\n  multiTypeActor ! TextMessage(\"Hello, Akka!\")\n  multiTypeActor ! NumberMessage(7)\n  multiTypeActor ! \"Unknown Message\" // Should trigger unknown message handler\n  multiTypeActor ! Shutdown\n  multiTypeActor ! TextMessage(\"This should not be processed.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CalculatorActor that performs basic arithmetic operations. It should handle messages in the form of Calculate(operation: String, a: Int, b: Int), where operation can be \"add\", \"subtract\", \"multiply\", or \"divide\". The actor should perform the requested operation on the integers a and b and reply with the result. Handle division by zero by replying with an error message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\n\n// Define the Calculate message\ncase class Calculate(operation: String, a: Int, b: Int)\n\n// Define the CalculatorActor\nclass CalculatorActor extends Actor {\n  def receive: Receive = {\n    case Calculate(op, a, b) =>\n      val result = op.toLowerCase match {\n        case \"add\"      => a + b\n        case \"subtract\" => a - b\n        case \"multiply\" => a * b\n        case \"divide\" =>\n          if (b != 0) a.toDouble / b else \"Error: Division by zero\"\n        case _ => \"Error: Unknown operation\"\n      }\n      sender() ! result\n    case _ =>\n      sender() ! \"Error: Unknown message type.\"\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CalculatorActorApp extends App {\n  val system = ActorSystem(\"CalculatorSystem\")\n  val calculator = system.actorOf(Props[CalculatorActor], \"calculatorActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to perform calculation and print result\n  def performCalculation(op: String, a: Int, b: Int): Unit = {\n    val future = calculator ? Calculate(op, a, b)\n    val result = Await.result(future, timeout.duration)\n    println(s\"Calculate($op, $a, $b) = $result\")\n  }\n\n  // Perform various calculations\n  performCalculation(\"add\", 10, 5)        // 15\n  performCalculation(\"subtract\", 10, 5)   // 5\n  performCalculation(\"multiply\", 10, 5)   // 50\n  performCalculation(\"divide\", 10, 5)     // 2.0\n  performCalculation(\"divide\", 10, 0)     // Error: Division by zero\n  performCalculation(\"modulo\", 10, 5)     // Error: Unknown operation\n\n  // Shutdown the system\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named BroadcasterActor that maintains a list of subscriber actors. It should handle Subscribe(subscriber: ActorRef) and Broadcast(message: String) messages. Upon receiving a Subscribe message, it should add the actor to its subscriber list. When a Broadcast message is received, it should send the message to all subscribed actors. Demonstrate subscribing multiple actors and broadcasting messages to them."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(subscriber: ActorRef)\ncase class Broadcast(message: String)\n\n// Define the BroadcasterActor\nclass BroadcasterActor extends Actor {\n  var subscribers: Set[ActorRef] = Set.empty\n\n  def receive: Receive = {\n    case Subscribe(subscriber) =>\n      subscribers += subscriber\n      println(s\"BroadcasterActor added subscriber: ${subscriber.path.name}\")\n    case Broadcast(msg) =>\n      println(s\"BroadcasterActor broadcasting message: $msg to ${subscribers.size} subscribers.\")\n      subscribers.foreach(_ ! msg)\n    case _ =>\n      println(\"BroadcasterActor received unknown message.\")\n  }\n}\n\n// Define a Subscriber Actor\nclass SubscriberActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"Subscriber [$name] received broadcast message: $msg\")\n    case _ =>\n      println(s\"Subscriber [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BroadcasterApp extends App {\n  val system = ActorSystem(\"BroadcasterSystem\")\n  val broadcaster = system.actorOf(Props[BroadcasterActor], \"broadcasterActor\")\n\n  // Create subscriber actors\n  val subscriber1 = system.actorOf(Props(new SubscriberActor(\"Alice\")), \"subscriber1\")\n  val subscriber2 = system.actorOf(Props(new SubscriberActor(\"Bob\")), \"subscriber2\")\n  val subscriber3 = system.actorOf(Props(new SubscriberActor(\"Charlie\")), \"subscriber3\")\n\n  // Subscribers subscribe to the broadcaster\n  broadcaster ! Subscribe(subscriber1)\n  broadcaster ! Subscribe(subscriber2)\n  broadcaster ! Subscribe(subscriber3)\n\n  // Broadcast messages\n  broadcaster ! Broadcast(\"Welcome to the broadcast system!\")\n  broadcaster ! Broadcast(\"This is the second broadcast message.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SelectorActor that uses actor selection to send a message to another actor named TargetActor located at a specific path within the same actor system. Demonstrate selecting the TargetActor and sending a \"Hello Target!\" message using actor selection."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the TargetActor\nclass TargetActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"TargetActor received message: $msg from ${sender().path.name}\")\n    case _ =>\n      println(\"TargetActor received unknown message.\")\n  }\n}\n\n// Define the SelectorActor\nclass SelectorActor extends Actor {\n  def receive: Receive = {\n    case \"sendHello\" =>\n      // Actor selection path\n      val targetPath = \"/user/targetActor\"\n      val target = context.actorSelection(targetPath)\n      println(s\"SelectorActor sending 'Hello Target!' to $targetPath\")\n      target ! \"Hello Target!\"\n    case _ =>\n      println(\"SelectorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelectorApp extends App {\n  val system = ActorSystem(\"SelectorSystem\")\n  \n  // Create TargetActor\n  val target = system.actorOf(Props[TargetActor], \"targetActor\")\n  \n  // Create SelectorActor\n  val selector = system.actorOf(Props[SelectorActor], \"selectorActor\")\n  \n  // Send a message to SelectorActor to send message to TargetActor\n  selector ! \"sendHello\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AcknowledgingActor that acknowledges each received message by replying with \"Ack\". Implement a sender actor named RequesterActor that sends multiple messages to AcknowledgingActor and waits for acknowledgments before sending the next message. Demonstrate the acknowledgment mechanism."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define the AcknowledgingActor\nclass AcknowledgingActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"AcknowledgingActor received message: $msg from ${sender().path.name}\")\n      sender() ! \"Ack\"\n  }\n}\n\n// Define the RequesterActor\nclass RequesterActor(ackActor: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(3.seconds)\n\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"RequesterActor sending message: $msg\")\n      val future = ackActor ? msg\n      future.map {\n        case \"Ack\" =>\n          println(s\"RequesterActor received Ack for message: $msg\")\n          // Optionally, send next message or perform other actions\n      }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject AcknowledgmentApp extends App {\n  val system = ActorSystem(\"AcknowledgmentSystem\")\n  \n  val acknowledgingActor = system.actorOf(Props[AcknowledgingActor], \"acknowledgingActor\")\n  val requesterActor = system.actorOf(Props(new RequesterActor(acknowledgingActor)), \"requesterActor\")\n  \n  // Send multiple messages\n  requesterActor ! \"Message 1\"\n  requesterActor ! \"Message 2\"\n  requesterActor ! \"Message 3\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named TransformerActor that receives messages containing integers, multiplies each integer by 2, and forwards the transformed message to another actor named ReceiverActor. Demonstrate the transformation and forwarding behavior by sending integer messages to the TransformerActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the TransformerActor\nclass TransformerActor(receiver: ActorRef) extends Actor {\n  def receive: Receive = {\n    case num: Int =>\n      val transformed = num * 2\n      println(s\"TransformerActor received: $num, transformed to: $transformed\")\n      receiver ! transformed\n    case _ =>\n      println(\"TransformerActor received unknown message.\")\n  }\n}\n\n// Define the ReceiverActor\nclass ReceiverActor extends Actor {\n  def receive: Receive = {\n    case msg: Int =>\n      println(s\"ReceiverActor received transformed message: $msg\")\n    case _ =>\n      println(\"ReceiverActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TransformerApp extends App {\n  val system = ActorSystem(\"TransformerSystem\")\n  \n  val receiver = system.actorOf(Props[ReceiverActor], \"receiverActor\")\n  val transformer = system.actorOf(Props(new TransformerActor(receiver)), \"transformerActor\")\n  \n  // Send integer messages to TransformerActor\n  transformer ! 5\n  transformer ! 10\n  transformer ! 15\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named ResponderWithTimeout that replies to any Ping message with a Pong after a delay of 2 seconds. Implement a RequesterWithTimeout actor that sends a Ping message to ResponderWithTimeout and waits for a Pong reply with a timeout of 1 second. Handle the timeout scenario by printing \"Request timed out\" if no reply is received in time."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define messages\ncase object Ping\ncase object Pong\n\n// Define the ResponderWithTimeout Actor\nclass ResponderWithTimeout extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case Ping =>\n      println(s\"${self.path.name} received Ping. Will respond with Pong after delay.\")\n      context.system.scheduler.scheduleOnce(2.seconds, sender(), Pong)\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the RequesterWithTimeout Actor\nclass RequesterWithTimeout(responder: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(1.second)\n\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"${self.path.name} sending Ping to ${responder.path.name}\")\n      val future = responder ? Ping\n      future.onComplete {\n        case Success(Pong) =>\n          println(s\"${self.path.name} received Pong.\")\n        case Failure(_) =>\n          println(s\"${self.path.name} Request timed out.\")\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TimeoutApp extends App {\n  val system = ActorSystem(\"TimeoutSystem\")\n  \n  val responder = system.actorOf(Props[ResponderWithTimeout], \"responderWithTimeout\")\n  val requester = system.actorOf(Props(new RequesterWithTimeout(responder)), \"requesterWithTimeout\")\n  \n  // Start the request\n  requester ! \"start\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(3000)\n  system.terminate()\n}"
      }
    ]
  }
]