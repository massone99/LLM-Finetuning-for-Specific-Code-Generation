[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a LoggingActor in Scala that logs any string it receives, ensuring correctness and moderate comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Actor that logs any string message it receives.\nclass LoggingActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      // If the message is a String, log it.\n      println(s\"LoggingActor received: $msg\")\n    case _ =>\n      // For non-string messages, log an error.\n      println(\"LoggingActor: Unknown message type.\")\n  }\n}\n\nobject LoggingActorApp extends App {\n  // Create an ActorSystem named \"LoggingSystem\"\n  val system = ActorSystem(\"LoggingSystem\")\n  // Create an instance of LoggingActor\n  val logger = system.actorOf(Props[LoggingActor](), \"logger\")\n\n  // Send a few string messages\n  logger ! \"Hello, Akka!\"\n  logger ! \"Another log message\"\n\n  // Wait briefly for processing, then shut down.\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named PaymentProcessorActor that simulates payment processing for orders, ensuring correctness."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Message to initiate a payment\ncase class PaymentRequest(orderId: String, amount: Double)\n// Confirmation and Failure messages\ncase class PaymentConfirmation(orderId: String)\ncase class PaymentFailure(orderId: String, reason: String)\n\n// Actor that simulates payment processing\nclass PaymentProcessorActor extends Actor {\n  def receive: Receive = {\n    case PaymentRequest(orderId, amount) =>\n      // Log receipt of the payment request\n      println(s\"PaymentProcessorActor: Processing payment for order $orderId, amount $$ $amount\")\n      // Simulate asynchronous processing with a short delay\n      context.system.scheduler.scheduleOnce(1.second) {\n        if (amount < 1000.0) {\n          println(s\"PaymentProcessorActor: Payment for order $orderId is confirmed.\")\n          sender() ! PaymentConfirmation(orderId)\n        } else {\n          println(s\"PaymentProcessorActor: Payment for order $orderId failed (insufficient funds).\")\n          sender() ! PaymentFailure(orderId, \"Insufficient funds\")\n        }\n      }\n    case _ =>\n      // Log unknown messages.\n      println(\"PaymentProcessorActor: Unknown message.\")\n  }\n}\n\nobject PaymentProcessorApp extends App {\n  // Create an ActorSystem named \"PaymentSystem\"\n  val system = ActorSystem(\"PaymentSystem\")\n  // Create an instance of PaymentProcessorActor\n  val processor = system.actorOf(Props[PaymentProcessorActor](), \"paymentProcessor\")\n\n  // Send payment requests\n  processor ! PaymentRequest(\"Order001\", 500.0)\n  processor ! PaymentRequest(\"Order002\", 1500.0)\n\n  // Wait briefly for processing, then terminate\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a SupervisorActor in Scala that supervises a child actor named FailProneActor, implementing a custom supervision strategy."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, OneForOneStrategy}\nimport akka.actor.SupervisorStrategy.{Restart, Stop}\nimport scala.concurrent.duration._\n\n// Message that triggers failure\ncase object FailNow\n\n// Child actor that throws an exception on FailNow\nclass FailProneActor extends Actor {\n  def receive: Receive = {\n    case FailNow =>\n      println(s\"FailProneActor [${self.path.name}]: Forced failure.\")\n      throw new RuntimeException(\"Simulated failure.\")\n    case msg =>\n      println(s\"FailProneActor [${self.path.name}]: Received message -> $msg\")\n  }\n}\n\n// Supervisor actor with a custom supervision strategy\nclass SupervisorActor extends Actor {\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy(maxNrOfRetries = 2, withinTimeRange = 1.minute) {\n    case _: RuntimeException =>\n      println(\"SupervisorActor: Restarting child due to RuntimeException.\")\n      Restart\n    case _ =>\n      Stop\n  }\n\n  // Create the child actor\n  val child: ActorRef = context.actorOf(Props[FailProneActor](), \"failProneChild\")\n\n  def receive: Receive = {\n    // Forward all messages to the child\n    case msg => child.forward(msg)\n  }\n}\n\nobject SupervisorApp extends App {\n  // Create the ActorSystem\n  val system = ActorSystem(\"SupervisorSystem\")\n  // Create the supervisor actor\n  val supervisor = system.actorOf(Props[SupervisorActor](), \"supervisor\")\n\n  // Send a normal message\n  supervisor ! \"Hello\"\n  // Send a fail message\n  supervisor ! FailNow\n  // Send another message after failure\n  supervisor ! \"Check after failure\"\n\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a ToggleActor that switches between active and inactive states using context.become."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message that toggles the actor state\ncase object Toggle\n\n// Actor that toggles between active and inactive modes\nclass ToggleActor extends Actor {\n  // Define the active state\n  def active: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from active to inactive.\")\n      context.become(inactive)\n    case msg =>\n      println(s\"ToggleActor (active) received: $msg\")\n  }\n\n  // Define the inactive state\n  def inactive: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from inactive to active.\")\n      context.become(active)\n    case msg =>\n      println(s\"ToggleActor (inactive) received: $msg\")\n  }\n\n  // Start in the active state\n  def receive: Receive = active\n}\n\nobject ToggleApp extends App {\n  // Create the ActorSystem\n  val system = ActorSystem(\"ToggleSystem\")\n  // Create an instance of ToggleActor\n  val toggleActor = system.actorOf(Props[ToggleActor](), \"toggle\")\n\n  // Send messages to see how the actor toggles states\n  toggleActor ! \"First message\"\n  toggleActor ! Toggle\n  toggleActor ! \"Second message\"\n  toggleActor ! Toggle\n  toggleActor ! \"Third message\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a RateLimitingActor that processes one message at a time and queues the rest."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.collection.mutable\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Wrapper for requests\ncase class RequestMsg(content: String)\n// Internal message to process the next queued request\ncase object ProcessNext\n\n// Actor that processes only one message at a time, queuing extras\nclass RateLimitingActor extends Actor {\n  private val queue = mutable.Queue[RequestMsg]()\n  private var isBusy = false\n  private var currentSchedule: Option[Cancellable] = None\n\n  def receive: Receive = {\n    case req: RequestMsg =>\n      // Enqueue new request\n      queue.enqueue(req)\n      tryProcessNext()\n\n    case ProcessNext =>\n      if (queue.nonEmpty) {\n        val nextReq = queue.dequeue()\n        println(s\"RateLimitingActor: Processing -> ${nextReq.content}\")\n        isBusy = true\n        // Simulate processing time of 1 second\n        currentSchedule = Some(\n          context.system.scheduler.scheduleOnce(1.second, self, \"done\")\n        )\n      } else {\n        isBusy = false\n      }\n\n    case \"done\" =>\n      isBusy = false\n      tryProcessNext()\n\n    case _ => println(\"RateLimitingActor: Received unknown message.\")\n  }\n\n  // Attempt to process the next queued request if not busy\n  private def tryProcessNext(): Unit = {\n    if (!isBusy && queue.nonEmpty) {\n      self ! ProcessNext\n    }\n  }\n\n  override def postStop(): Unit = {\n    // Cancel any scheduled tasks on shutdown\n    currentSchedule.foreach(_.cancel())\n    super.postStop()\n  }\n}\n\nobject RateLimitingApp extends App {\n  val system = ActorSystem(\"RateLimitSystem\")\n  val rateActor = system.actorOf(Props[RateLimitingActor](), \"rateLimitActor\")\n\n  // Send multiple requests\n  for (i <- 1 to 5) {\n    rateActor ! RequestMsg(s\"Message-$i\")\n  }\n\n  Thread.sleep(6000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a StashingActor that stashes messages until it receives an Initialize message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Message to initialize the actor\ncase object Initialize\n// Sample data message to be stashed pre-initialization\ncase class DataMessage(content: String)\n\n// Actor that stashes incoming data messages until initialized\nclass StashingActor extends Actor with Stash {\n  // Begin in the uninitialized state\n  def receive: Receive = uninitialized\n\n  def uninitialized: Receive = {\n    case Initialize =>\n      println(\"StashingActor: Actor initialized; unstashing all.\")\n      // Unstash all queued messages, then become active\n      unstashAll()\n      context.become(initialized)\n    case msg =>\n      // Stash any message while uninitialized\n      println(s\"StashingActor: Stashing message '$msg'.\")\n      stash()\n  }\n\n  def initialized: Receive = {\n    case DataMessage(content) =>\n      println(s\"StashingActor (initialized): Processing -> $content\")\n    case _ =>\n      println(\"StashingActor (initialized): Received unknown message.\")\n  }\n}\n\nobject StashingApp extends App {\n  val system = ActorSystem(\"StashSystem\")\n  val stasher = system.actorOf(Props[StashingActor](), \"stashingActor\")\n\n  // Send a couple of data messages before initialization\n  stasher ! DataMessage(\"Data 1\")\n  stasher ! DataMessage(\"Data 2\")\n\n  // Now initialize the actor\n  stasher ! Initialize\n\n  // Send another data message after initialization\n  stasher ! DataMessage(\"Data 3\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a CalculatorActor in Scala that supports basic arithmetic, with correct implementation and short comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message to request a calculation\ncase class Calculate(op: String, x: Double, y: Double)\n// Message with the result of a calculation\ncase class CalcResult(value: Double)\n\n// Actor that performs basic arithmetic operations\nclass CalculatorActor extends Actor {\n  def receive: Receive = {\n    case Calculate(op, x, y) =>\n      val result = op.toLowerCase match {\n        case \"add\"      => x + y\n        case \"subtract\" => x - y\n        case \"multiply\" => x * y\n        case \"divide\"   => if (y != 0) x / y else Double.NaN\n        case _           => Double.NaN\n      }\n      // Log the operation and respond\n      println(s\"CalculatorActor: $op on $x and $y -> $result\")\n      sender() ! CalcResult(result)\n    case _ =>\n      println(\"CalculatorActor: Received unknown message.\")\n  }\n}\n\nobject CalculatorApp extends App {\n  val system = ActorSystem(\"CalcSystem\")\n  val calc = system.actorOf(Props[CalculatorActor](), \"calculator\")\n\n  // Perform some operations\n  calc ! Calculate(\"add\", 10, 5)\n  calc ! Calculate(\"divide\", 12, 0)\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a ManagerActor that coordinates two WorkerActors, waiting for both results before replying."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Message requesting a coordinated task\ncase class CoordinatedTask(data: String)\n// Message representing partial result from a worker\ncase class PartialResult(text: String)\n// Message with final aggregated result\ncase class FinalResult(result: String)\n\n// Worker that processes part of the data\nclass WorkerActor(workerId: Int) extends Actor {\n  def receive: Receive = {\n    case CoordinatedTask(data) =>\n      val transformed = s\"Worker-$workerId processed: $data\"\n      println(transformed)\n      sender() ! PartialResult(transformed)\n    case _ => println(s\"Worker-$workerId: Unknown message.\")\n  }\n}\n\n// Manager that coordinates two workers and aggregates their results\nclass ManagerActor(worker1: ActorRef, worker2: ActorRef) extends Actor {\n  private var resultCount = 0\n  private var partials: List[String] = Nil\n  private var originalSender: Option[ActorRef] = None\n\n  def receive: Receive = {\n    case CoordinatedTask(data) =>\n      // Reset state for new request\n      resultCount = 0\n      partials = Nil\n      originalSender = Some(sender())\n      // Send the same data to two workers\n      worker1 ! CoordinatedTask(data)\n      worker2 ! CoordinatedTask(data)\n\n    case PartialResult(text) =>\n      // Collect partial results\n      partials = text :: partials\n      resultCount += 1\n      // If both workers have replied, aggregate\n      if (resultCount == 2) {\n        val aggregated = partials.reverse.mkString(\" | \")\n        println(s\"ManagerActor: Aggregated -> $aggregated\")\n        originalSender.foreach(_ ! FinalResult(aggregated))\n      }\n\n    case _ => println(\"ManagerActor: Unknown message.\")\n  }\n}\n\nobject ManagerApp extends App {\n  val system = ActorSystem(\"ManagerSystem\")\n\n  val w1 = system.actorOf(Props(new WorkerActor(1)), \"worker1\")\n  val w2 = system.actorOf(Props(new WorkerActor(2)), \"worker2\")\n  val manager = system.actorOf(Props(new ManagerActor(w1, w2)), \"manager\")\n\n  // Send a coordinated task\n  manager ! CoordinatedTask(\"some data\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a Hierarchical Actor system in Scala with a ParentActor supervising ChildActor1 and ChildActor2. ChildActor1 can further supervise a GrandchildActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, Terminated, OneForOneStrategy}\nimport akka.actor.SupervisorStrategy.{Restart, Stop, Resume}\nimport scala.concurrent.duration._\n\n// Message types for the actors\ncase object StartProcessing\ncase object Crash\ncase class ProcessData(data: String)\n\n// Grandchild Actor that can fail\nclass GrandchildActor extends Actor {\n  def receive: Receive = {\n    case ProcessData(data) =>\n      println(s\"GrandchildActor [${self.path.name}]: Processing data: $data\")\n    case Crash =>\n      println(s\"GrandchildActor [${self.path.name}]: Received crash signal, throwing exception!\")\n      throw new RuntimeException(\"Grandchild forced to crash\")\n    case _ => println(s\"GrandchildActor [${self.path.name}]: Unknown message.\")\n  }\n}\n\n// Child Actor 1, supervising GrandchildActor\nclass ChildActor1 extends Actor {\n  // Define supervision strategy for GrandchildActor. Restart on exception.\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case _: RuntimeException => Restart // Restart on RuntimeExceptions\n    case _                   => Stop    // Stop for other exceptions\n  }\n\n  // Create the GrandchildActor as a child\n  val grandchildActor: ActorRef = context.actorOf(Props[GrandchildActor](), \"grandchildActor\")\n\n  def receive: Receive = {\n    case StartProcessing =>\n      println(s\"ChildActor1 [${self.path.name}]: Starting processing, sending to grandchild.\")\n      grandchildActor ! ProcessData(\"Data for Grandchild\")\n    case msg: ProcessData =>\n      grandchildActor forward msg // Forward ProcessData messages to grandchild\n    case Crash => grandchildActor ! Crash // Forward Crash message to grandchild\n    case _     => println(s\"ChildActor1 [${self.path.name}]: Unknown message.\")\n  }\n}\n\n// Child Actor 2, simple worker actor\nclass ChildActor2 extends Actor {\n  def receive: Receive = {\n    case ProcessData(data) =>\n      println(s\"ChildActor2 [${self.path.name}]: Processing data: $data\")\n    case _ => println(s\"ChildActor2 [${self.path.name}]: Unknown message.\")\n  }\n}\n\n// Parent Actor, supervising ChildActor1 and ChildActor2\nclass ParentActor extends Actor {\n  // Supervisor strategy for ChildActors: Restart on any exception.\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case _: Exception => Restart // Restart children on any Exception\n    case _            => Stop    // Stop for other errors (not explicitly defined for simplicity)\n  }\n\n  // Create Child Actors\n  val childActor1: ActorRef = context.actorOf(Props[ChildActor1](), \"childActor1\")\n  val childActor2: ActorRef = context.actorOf(Props[ChildActor2](), \"childActor2\")\n\n  // Monitor childActor2's termination.\n  context.watch(childActor2)\n\n  def receive: Receive = {\n    case StartProcessing =>\n      println(s\"ParentActor [${self.path.name}]: Starting processing, sending to children.\")\n      childActor1 ! StartProcessing  // Start processing in ChildActor1\n      childActor2 ! ProcessData(\"Data for Child2\") // Send data to ChildActor2\n    case Crash =>\n      println(s\"ParentActor [${self.path.name}]: Received crash signal, sending to child1.\")\n      childActor1 ! Crash // Trigger crash in grandchild via ChildActor1\n    case Terminated(actor) =>\n      println(s\"ParentActor [${self.path.name}]: Actor ${actor.path.name} has terminated.\")\n    case _ => println(s\"ParentActor [${self.path.name}]: Unknown message.\")\n  }\n}\n\nobject HierarchyApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"HierarchySystem\")\n\n  // Create the Parent Actor, which will create children and grandchildren.\n  val parentActor = system.actorOf(Props[ParentActor](), \"parentActor\")\n\n  // Start the processing flow.\n  parentActor ! StartProcessing\n  Thread.sleep(500)\n\n  // Trigger a crash in the GrandchildActor via Parent.\n  parentActor ! Crash\n  Thread.sleep(1000)\n\n  // Send more processing message after restart, to see supervision in action\n  parentActor ! StartProcessing\n  Thread.sleep(1000)\n\n  // Terminate the actor system\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Illustrate Actor Lifecycle hooks (preStart, postStop, preRestart, postRestart) in a LifecycleActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Simple message for the LifecycleActor\ncase object Action\ncase object RestartActor // Message to trigger a restart\ncase object StopActor    // Message to trigger a stop\n\n// Actor demonstrating lifecycle methods\nclass LifecycleActor extends Actor {\n  println(s\"[${self.path.name}] Constructor called\") // Constructor is called once per actor instance.\n\n  // preStart is called when an Actor starts, after constructor.\n  override def preStart(): Unit = {\n    println(s\"[${self.path.name}] preStart hook is called.\")\n    super.preStart() // Always call super implementation.\n  }\n\n  // postStop is called when an Actor is stopped using context.stop() or system.stop().\n  override def postStop(): Unit = {\n    println(s\"[${self.path.name}] postStop hook is called.\")\n    super.postStop() // Always call super implementation.\n  }\n\n  // preRestart is called before restart upon actor failure.\n  override def preRestart(reason: Throwable, message: Option[Any]): Unit = {\n    println(s\"[${self.path.name}] preRestart hook is called because of ${reason.getMessage}, during message: ${message.getOrElse(\"N/A\")}.\")\n    super.preRestart(reason, message) // Always call super implementation.\n  }\n\n  // postRestart is called after a restart is completed.\n  override def postRestart(reason: Throwable): Unit = {\n    println(s\"[${self.path.name}] postRestart hook is called due to ${reason.getMessage}.\")\n    super.postRestart(reason) // Always call super implementation.\n  }\n\n  def receive: Receive = {\n    case Action =>\n      println(s\"[${self.path.name}] Received Action message, working...\")\n    case RestartActor =>\n      println(s\"[${self.path.name}] Received RestartActor message, throwing exception to simulate failure.\")\n      throw new RuntimeException(\"Simulating actor failure for restart.\")\n    case StopActor =>\n      println(s\"[${self.path.name}] Received StopActor message, stopping itself.\")\n      context.stop(self) // Stop the actor explicitly.\n    case _ =>\n      println(s\"[${self.path.name}] Received unknown message.\")\n  }\n}\n\nobject LifecycleApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"LifecycleSystem\")\n\n  // Create the LifecycleActor\n  val lifecycleActor = system.actorOf(Props[LifecycleActor](), \"lifecycleActor\")\n\n  println(\"Sending Action message\")\n  lifecycleActor ! Action\n  Thread.sleep(500)\n\n  println(\"Sending RestartActor message to trigger restart\")\n  lifecycleActor ! RestartActor // Trigger restart due to exception\n  Thread.sleep(1000)\n\n  println(\"Sending Action message again after restart\")\n  lifecycleActor ! Action // Message after restart.\n  Thread.sleep(500)\n\n  println(\"Sending StopActor message to stop the actor.\")\n  lifecycleActor ! StopActor // Explicitly stop the actor.\n  Thread.sleep(1000)\n\n  // Try to send a message to stopped actor - it will be dead letters.\n  println(\"Sending Action message after actor has been stopped (should go to dead letters).\")\n  lifecycleActor ! Action\n  Thread.sleep(1000)\n\n  // Terminate the actor system\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Demonstrate using Actor Selection to send messages to an actor without having an ActorRef directly, within the same ActorSystem."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, ActorSelection}\n\n// Simple message for actors.\ncase class Greet(message: String)\n\n// Target Actor to be selected.\nclass TargetActor extends Actor {\n  def receive: Receive = {\n    case Greet(message) =>\n      println(s\"TargetActor [${self.path.name}]: Received greeting: $message from ${sender().path.name}\")\n    case _ =>\n      println(s\"TargetActor [${self.path.name}]: Unknown message.\")\n  }\n}\n\n// Selecting Actor that will send a message to TargetActor using ActorSelection\nclass SelectingActor extends Actor {\n  // ActorSelection for TargetActor based on its path. Assumes TargetActor is at /user/targetActor.\n  val targetSelection: ActorSelection = context.actorSelection(\"/user/targetActor\")\n\n  def receive: Receive = {\n    case \"sendGreet\" =>\n      println(s\"SelectingActor [${self.path.name}]: Sending greeting via ActorSelection.\")\n      targetSelection ! Greet(\"Hello from SelectingActor via Selection!\")\n    case _ =>\n      println(s\"SelectingActor [${self.path.name}]: Unknown message.\")\n  }\n}\n\nobject ActorSelectionApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"SelectionSystem\")\n\n  // Create Target Actor - the one we'll select.\n  system.actorOf(Props[TargetActor](), \"targetActor\")\n\n  // Create Selecting Actor - this will select and send message to TargetActor.\n  val selectingActor = system.actorOf(Props[SelectingActor](), \"selectingActor\")\n\n  // Trigger sending of the greeting message using selection.\n  selectingActor ! \"sendGreet\"\n\n  Thread.sleep(1000)\n\n  // Terminate Actor System.\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement Timers within an actor to perform periodic tasks using TimerScheduler."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Timers}\nimport scala.concurrent.duration._\n\n// Key for timer, could be anything unique. Here using a String.\ncase object TickKey\n// Message that the timer will send periodically.\ncase object Tick\n\n// Actor that uses Timers to schedule periodic messages to itself.\nclass TimerActor extends Actor with Timers {\n  // Schedule a 'Tick' message to be sent to self every 1 second, starting after 0 seconds delay.\n  timers.startTimerWithFixedDelay(TickKey, Tick, 1.second)\n\n  override def preStart(): Unit = {\n    println(s\"[${self.path.name}] TimerActor is starting and timer scheduled.\")\n    super.preStart()\n  }\n\n  override def postStop(): Unit = {\n    println(s\"[${self.path.name}] TimerActor is stopping, timers will be cancelled automatically.\")\n    super.postStop()\n  }\n\n  def receive: Receive = {\n    case Tick =>\n      // Handle the Tick message, which is triggered by the timer.\n      println(s\"[${self.path.name}] Received a Tick at ${System.currentTimeMillis()}\")\n    case \"stop\" =>\n      println(s\"[${self.path.name}] Received stop message, stopping self and timers.\")\n      context.stop(self) // Stop the actor - this will cancel timers as well.\n    case _ =>\n      println(s\"[${self.path.name}] Unknown message.\")\n  }\n}\n\nobject TimerApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"TimerSystem\")\n\n  // Create TimerActor\n  val timerActor = system.actorOf(Props[TimerActor](), \"timerActor\")\n\n  // Let it run for a while, timers will be triggering. Log messages should appear.\n  Thread.sleep(5000) // Run for 5 seconds.\n\n  // Send stop message to the actor to stop itself and timers.\n  timerActor ! \"stop\"\n  Thread.sleep(1000) // Wait for stop to process.\n\n  // Terminate Actor System.\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Illustrate using 'Ask' pattern for request-response communication using futures with actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Future\nimport akka.pattern.ask\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Success, Failure}\n\n// Question message that requires an answer.\ncase class Question(query: String)\n// Answer message sent as response.\ncase class Answer(response: String)\n\n// Responder Actor that replies to questions.\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Question(query) =>\n      // Respond to the question by sending an Answer message back to sender.\n      println(s\"ResponderActor [${self.path.name}] received question: '$query', answering...\")\n      sender() ! Answer(s\"The answer to '$query' is... 42! (from ${self.path.name}) \")\n    case _ =>\n      println(s\"ResponderActor [${self.path.name}] Unknown message.\")\n  }\n}\n\n// Questioner Actor that uses 'ask' to send a question and process the answer asynchronously.\nclass QuestionerActor extends Actor {\n  // Get reference to ResponderActor (assuming it's named 'responderActor' at /user path).\n  val responderActor = context.actorSelection(\"/user/responderActor\")\n  implicit val timeout: Timeout = Timeout(5.seconds) // Define timeout for 'ask' operations.\n\n  def receive: Receive = {\n    case \"askQuestion\" =>\n      println(s\"QuestionerActor [${self.path.name}] sending question to ResponderActor using ask...\")\n      // 'ask' sends a message and returns a Future representing the eventual reply.\n      val futureResponse: Future[Any] = responderActor ? Question(\"What is the ultimate question?\")\n\n      // Handle the Future response asynchronously when it becomes available.\n      futureResponse.onComplete {\n        case Success(answer: Answer) =>\n          println(s\"QuestionerActor [${self.path.name}] got asynchronous answer: '${answer.response}' from ${sender().path.name}\")\n        case Success(unexpected) =>\n          println(s\"QuestionerActor [${self.path.name}] got unexpected response type: ${unexpected}\")\n        case Failure(exception) =>\n          println(s\"QuestionerActor [${self.path.name}] ask failed with: ${exception.getMessage}\")\n      }\n    case _ =>\n      println(s\"QuestionerActor [${self.path.name}] Unknown message.\")\n  }\n}\n\nobject AskPatternApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"AskSystem\")\n\n  // Create Responder Actor - to answer questions.\n  system.actorOf(Props[ResponderActor](), \"responderActor\")\n\n  // Create Questioner Actor - to ask questions using 'ask'.\n  val questionerActor = system.actorOf(Props[QuestionerActor](), \"questionerActor\")\n\n  // Trigger the question asking process.\n  questionerActor ! \"askQuestion\"\n\n  Thread.sleep(5000) // Wait for async operations to complete.\n\n  // Terminate Actor System.\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Demonstrate using Actor 'Forward' to pass messages from one actor to another without changing the original sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message to be processed.\ncase class ProcessRequest(data: String)\n\n// First actor in the chain - FrontActor. It receives the initial message and forwards it.\nclass FrontActor extends Actor {\n  // Get a reference to the next actor in chain - WorkerActor (assuming it is named 'workerActor' at /user).\n  val workerActor = context.actorSelection(\"/user/workerActor\")\n\n  def receive: Receive = {\n    case request: ProcessRequest =>\n      println(s\"FrontActor [${self.path.name}]: Received request to process data: '${request.data}', forwarding...\")\n      // 'forward' message to workerActor. The original sender is preserved.\n      workerActor forward request\n    case _ =>\n      println(s\"FrontActor [${self.path.name}]: Unknown message.\")\n  }\n}\n\n// Worker Actor - the actual processor of the request.\nclass WorkerActor extends Actor {\n  def receive: Receive = {\n    case ProcessRequest(data) =>\n      // Process the request.\n      println(s\"WorkerActor [${self.path.name}]: Processing data: '$data', received from ${sender().path.name} (original sender).\")\n      // Note: sender() will be the actor that originally sent to FrontActor, not FrontActor itself.\n    case _ =>\n      println(s\"WorkerActor [${self.path.name}]: Unknown message.\")\n  }\n}\n\n// Client Actor - initiating the process by sending a message to FrontActor.\nclass ClientActor extends Actor {\n  // Get a reference to the FrontActor (assuming it's named 'frontActor' at /user).\n  val frontActor = context.actorSelection(\"/user/frontActor\")\n\n  def receive: Receive = {\n    case \"startProcess\" =>\n      println(s\"ClientActor [${self.path.name}]: Starting the process by sending request to FrontActor.\")\n      frontActor ! ProcessRequest(\"Data to be processed.\")\n    case _ =>\n      println(s\"ClientActor [${self.path.name}]: Unknown message.\")\n  }\n}\n\nobject ForwardPatternApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"ForwardSystem\")\n\n  // Create Worker Actor - to process the forwarded request.\n  system.actorOf(Props[WorkerActor](), \"workerActor\")\n\n  // Create Front Actor - to receive initial request and forward it.\n  system.actorOf(Props[FrontActor](), \"frontActor\")\n\n  // Create Client Actor - to initiate the process.\n  val clientActor = system.actorOf(Props[ClientActor](), \"clientActor\")\n\n  // Start the message flow from ClientActor to FrontActor which forwards to WorkerActor.\n  clientActor ! \"startProcess\"\n\n  Thread.sleep(1000)\n\n  // Terminate Actor System.\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement a basic Pub-Sub pattern using Actors where a PublisherActor sends messages and SubscriberActors receive them."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.collection.mutable\n\n// Message types.\ncase class Publish(message: String) // Message to publish.\ncase class Subscribe()             // Message to subscribe for updates.\ncase class Unsubscribe()           // Message to unsubscribe from updates.\n\n// Publisher Actor - Manages subscribers and publishes messages.\nclass PublisherActor extends Actor {\n  private val subscribers: mutable.Set[ActorRef] = mutable.Set.empty // Keep track of subscribers.\n\n  def receive: Receive = {\n    case Subscribe =>\n      println(s\"PublisherActor [${self.path.name}]: Subscriber ${sender().path.name} subscribed.\")\n      subscribers += sender() // Add new subscriber to the set.\n    case Unsubscribe =>\n      println(s\"PublisherActor [${self.path.name}]: Subscriber ${sender().path.name} unsubscribed.\")\n      subscribers -= sender() // Remove subscriber from the set.\n    case Publish(message) =>\n      println(s\"PublisherActor [${self.path.name}]: Publishing message: '$message' to ${subscribers.size} subscribers.\")\n      // Iterate through subscribers and send the message.\n      subscribers.foreach(subscriber => subscriber ! message)\n    case _ =>\n      println(s\"PublisherActor [${self.path.name}]: Unknown message.\")\n  }\n}\n\n// Subscriber Actor - Receives messages from the Publisher after subscribing.\nclass SubscriberActor(subscriberId: Int) extends Actor {\n  override def preStart(): Unit = {\n    // Subscribe to the PublisherActor on start. Assumes publisherActor is at /user/publisherActor.\n    context.actorSelection(\"/user/publisherActor\") ! Subscribe\n    println(s\"SubscriberActor-$subscriberId [${self.path.name}]: Subscribed to publisher.\")\n    super.preStart()\n  }\n\n  override def postStop(): Unit = {\n    // Unsubscribe from the PublisherActor on stop. Good practice to clean up subscriptions.\n    context.actorSelection(\"/user/publisherActor\") ! Unsubscribe\n    println(s\"SubscriberActor-$subscriberId [${self.path.name}]: Unsubscribed from publisher on stop.\")\n    super.postStop()\n  }\n\n  def receive: Receive = {\n    case message: String =>\n      // Receive and handle published messages.\n      println(s\"SubscriberActor-$subscriberId [${self.path.name}]: Received published message: '$message'\")\n    case _ =>\n      println(s\"SubscriberActor-$subscriberId [${self.path.name}]: Unknown message.\")\n  }\n}\n\nobject PubSubApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"PubSubSystem\")\n\n  // Create Publisher Actor - manages subscriptions and publishes.\n  system.actorOf(Props[PublisherActor](), \"publisherActor\")\n\n  // Create a few Subscriber Actors.\n  val subscriber1 = system.actorOf(Props(new SubscriberActor(1)), \"subscriberActor1\")\n  val subscriber2 = system.actorOf(Props(new SubscriberActor(2)), \"subscriberActor2\")\n  val subscriber3 = system.actorOf(Props(new SubscriberActor(3)), \"subscriberActor3\")\n\n  Thread.sleep(1000)\n\n  // Publish a message through PublisherActor.\n  val publisher = system.actorSelection(\"/user/publisherActor\")\n  publisher ! Publish(\"Hello subscribers! This is a broadcast message.\")\n\n  Thread.sleep(3000)\n\n  // Stop one of the subscribers - subscriber2, it will unsubscribe on stop.\n  println(\"Stopping subscriberActor2...\")\n  system.stop(subscriber2)\n  Thread.sleep(1000)\n\n  // Publish another message - subscriber2 should not receive this one.\n  publisher ! Publish(\"Another message for active subscribers only.\")\n\n  Thread.sleep(3000)\n\n  // Terminate Actor System.\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement a Routing example using a Round Robin Router to distribute messages to a pool of Worker Actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\n// Message to be processed by workers.\ncase class Work(taskId: Int, data: String)\n\n// Worker Actor - performs actual work.\nclass WorkerActor(workerId: Int) extends Actor {\n  def receive: Receive = {\n    case Work(taskId, data) =>\n      println(s\"WorkerActor-$workerId [${self.path.name}]: Processing task $taskId with data: '$data'\")\n      // Simulate some work by sleeping.\n      Thread.sleep(100) // Short simulated work.\n      sender() ! s\"Task $taskId completed by Worker-$workerId\" // Send confirmation back to sender.\n    case _ =>\n      println(s\"WorkerActor-$workerId [${self.path.name}]: Unknown message.\")\n  }\n}\n\n// Master Actor - Uses a Round Robin Router to dispatch work to a pool of Worker Actors.\nclass MasterActor extends Actor {\n  // Define a Round Robin Router with 5 worker instances based on WorkerActor Props.\n  val routerPool: ActorRef = context.actorOf(RoundRobinPool(5).props(Props[WorkerActor]()), \"workerRouter\")\n\n  def receive: Receive = {\n    case task: Work =>\n      println(s\"MasterActor [${self.path.name}]: Received task ${task.taskId}, routing to worker pool.\")\n      // Send the work to the router. Round Robin router will distribute it among workers.\n      routerPool forward task // Use forward to preserve original sender.\n    case result: String =>\n      println(s\"MasterActor [${self.path.name}]: Received result: '$result' from worker.\") // Receive results from workers.\n    case _ =>\n      println(s\"MasterActor [${self.path.name}]: Unknown message.\")\n  }\n}\n\nobject RouterApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"RouterSystem\")\n\n  // Create Master Actor - which manages the worker pool and router.\n  val masterActor = system.actorOf(Props[MasterActor](), \"masterActor\")\n\n  // Send multiple work messages to the Master Actor. These will be routed in Round Robin fashion to worker actors.\n  for (i <- 1 to 10) {\n    masterActor ! Work(i, s\"Data for task $i\")\n    Thread.sleep(50) // Introduce small delay to observe routing.\n  }\n\n  Thread.sleep(5000) // Allow time for tasks to be processed.\n\n  // Terminate Actor System.\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement Actor Persistence using Event Sourcing for a CounterActor to maintain state across restarts."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{ActorSystem, Props}\nimport akka.persistence.PersistentActor\n\n// Define events that modify the counter.\nsealed trait CounterEvent\ncase object Increment extends CounterEvent\ncase object Decrement extends CounterEvent\ncase class PrintValue(id: String) extends CounterEvent\n\n// Define commands that can be sent to the CounterActor.\nsealed trait CounterCommand\ncase object CmdIncrement extends CounterCommand\ncase object CmdDecrement extends CounterCommand\ncase object CmdPrintValue extends CounterCommand\n\n// CounterActor - using Persistence to manage its state.\nclass CounterActor(persistenceIdPrefix: String) extends PersistentActor {\n  override def persistenceId: String = persistenceIdPrefix + \"-counter\"\n\n  var count = 0 // Mutable state - managed by event sourcing.\n\n  // Define receiveRecover to handle events on recovery (actor restart).\n  override def receiveRecover: Receive = {\n    case Increment =>\n      count += 1\n      println(s\"[${self.path.name}] Replayed Increment event, count is now: $count\")\n    case Decrement =>\n      count -= 1\n      println(s\"[${self.path.name}] Replayed Decrement event, count is now: $count\")\n    case PrintValue(id) =>\n        println(s\"[${self.path.name}] Replayed PrintValue event for actor with id: $id. Current count is: $count\")\n    case akka.persistence.RecoveryCompleted =>\n      println(s\"[${self.path.name}] Recovery completed, current count: $count\")\n    case akka.persistence.SnapshotOffer(_, snapshot: Integer) =>\n      println(s\"[${self.path.name}] Recovered snapshot: $snapshot\")\n      count = snapshot\n\n    case event: CounterEvent =>\n        println(s\"[${self.path.name}] Replayed event (unhandled in receiveRecover): ${event.getClass.getSimpleName}\")\n    case _ =>\n        println(s\"[${self.path.name}] Unhandled message in receiveRecover during recovery.\")\n  }\n\n  // Define receiveCommand to handle commands and persist events.\n  override def receiveCommand: Receive = {\n    case CmdIncrement =>\n      // Persist Increment event.\n      persist(Increment) {\n        event =>\n          count += 1 // Update state upon successful persistence.\n          println(s\"[${self.path.name}] Persisted Increment event, count is now: $count\")\n          sender() ! s\"Count incremented to $count\"\n      }\n    case CmdDecrement =>\n      // Persist Decrement event.\n      persist(Decrement) {\n        event =>\n          count -= 1 // Update state on event persistence.\n          println(s\"[${self.path.name}] Persisted Decrement event, count is now: $count\")\n          sender() ! s\"Count decremented to $count\"\n      }\n    case CmdPrintValue =>\n      // No event persistence needed for queries. Directly respond with current count.\n      println(s\"[${self.path.name}] Received CmdPrintValue, current count is: $count\")\n      persist(PrintValue(self.path.name)){\n          event => println(s\"[${self.path.name}] Persisted PrintValue event (informational only). Current value still: $count\")\n      }\n\n      sender() ! s\"Current count is $count\"\n    case \"snap\" => saveSnapshot(count) // Manual snapshot trigger.\n    case akka.persistence.SaveSnapshotSuccess(metadata) =>\n      println(s\"[${self.path.name}] Snapshot saved successfully at timestamp: ${metadata.timestamp}\")\n    case akka.persistence.SaveSnapshotFailure(metadata, cause) =>\n      println(s\"[${self.path.name}] Snapshot save failed for timestamp: ${metadata.timestamp}, cause: ${cause.getMessage}\")\n    case _ =>\n      println(s\"[${self.path.name}] Unknown command received.\")\n  }\n\n  override def onRecoveryFailure(cause: Throwable, event: Option[Any]): Unit = {\n    println(s\"[${self.path.name}] Recovery failed at event: ${event.getOrElse(\"N/A\")}, due to: ${cause.getMessage}\")\n    super.onRecoveryFailure(cause, event)\n  }\n\n  override def onPersistFailure(cause: Throwable, event: Any, seqNr: Long): Unit = {\n    println(s\"[${self.path.name}] Persistence to journal failed for event: ${event.getClass.getSimpleName}, sequence number: $seqNr, cause: ${cause.getMessage}\")\n    super.onPersistFailure(cause, event, seqNr)\n  }\n}\n\nobject PersistenceCounterApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"PersistenceSystem\")\n\n  // Create CounterActor instance\n  val counterActor = system.actorOf(Props(new CounterActor(\"counter1\")), \"persistentCounter\")\n\n  // Perform some operations to change counter state.\n  counterActor ! CmdIncrement\n  Thread.sleep(500)\n  counterActor ! CmdIncrement\n  Thread.sleep(500)\n  counterActor ! CmdDecrement\n  Thread.sleep(500)\n  counterActor ! CmdPrintValue\n  Thread.sleep(500)\n  counterActor ! \"snap\" // Trigger snapshot save.\n  Thread.sleep(1000)\n\n  println(\"Stopping and restarting actor...\")\n  system.stop(counterActor) // Simulate actor stop.\n  Thread.sleep(2000)\n\n  // Re-create actor, it should recover its state from journaled events and snapshot.\n  val recoveredCounterActor = system.actorOf(Props(new CounterActor(\"counter1\")), \"persistentCounter\")\n  Thread.sleep(1000)\n  recoveredCounterActor ! CmdPrintValue // Check if state is recovered correctly.\n  Thread.sleep(1000)\n\n  // Increment again on recovered actor.\n  recoveredCounterActor ! CmdIncrement\n  Thread.sleep(1000)\n  recoveredCounterActor ! CmdPrintValue\n  Thread.sleep(1000)\n\n  // Terminate Actor System.\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Example of implementing Actor Testing using Akka Testkit to verify actor behavior and message handling."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.testkit.{ImplicitSender, TestActorRef, TestKit}\nimport org.scalatest.BeforeAndAfterAll\nimport org.scalatest.wordspec.AnyWordSpecLike\n\n// Test Messages and Expected Responses.\ncase class SimpleMessage(text: String)\ncase class ProcessedMessage(responseText: String)\ncase object GetState\ncase class CurrentState(state: String)\n\n// Actor to be tested.\nclass TestableActor extends Actor {\n  var internalState = \"initial\"\n\n  def receive: Receive = {\n    case SimpleMessage(text) =>\n      internalState = text.toUpperCase // Update internal state on message.\n      sender() ! ProcessedMessage(s\"Processed: $text\") // Send response.\n    case GetState =>\n      sender() ! CurrentState(internalState) // Respond with current state.\n    case _ =>\n      println(s\"[${self.path.name}] Unknown message.\")\n  }\n}\n\n// Test class using TestKit and ScalaTest.\nclass TestableActorSpec extends TestKit(ActorSystem(\"TestSystem\")) // Initialize TestKit with ActorSystem.\n  with ImplicitSender // Implicit sender for replies.\n  with AnyWordSpecLike // Use WordSpec style tests from ScalaTest.\n  with BeforeAndAfterAll {\n\n  override def afterAll(): Unit = {\n    TestKit.shutdownActorSystem(system) // Shutdown ActorSystem after tests.\n  }\n\n  \"TestableActor\" must {\n    \"respond to SimpleMessage and change state\" in {\n      // Create a TestActorRef for synchronous testing.\n      val actorRef = TestActorRef[TestableActor](Props[TestableActor])\n\n      // Send a SimpleMessage and expect a ProcessedMessage response back within default timeout.\n      actorRef ! SimpleMessage(\"hello\")\n      expectMsg(ProcessedMessage(\"Processed: hello\"))\n\n      // Verify that the actor's internal state has changed.\n      actorRef ! GetState\n      expectMsg(CurrentState(\"HELLO\"))\n    }\n\n    \"return its current state when GetState message is sent\" in {\n      val actorRef = TestActorRef[TestableActor](Props[TestableActor])\n\n      // Initially state should be 'initial'.\n      actorRef ! GetState\n      expectMsg(CurrentState(\"initial\"))\n\n      // Change state first, then verify GetState.\n      actorRef ! SimpleMessage(\"teststate\")\n      expectMsgType[ProcessedMessage] // Ignore message content for now, just check type.\n      actorRef ! GetState\n      expectMsg(CurrentState(\"TESTSTATE\")) // State should reflect last processed message.\n    }\n  }\n}\n\n// Object to run the test specification (for manual execution, though tests are usually run by test frameworks).\nobject RunTestSpec extends App {\n  new TestableActorSpec // Creates and runs the test spec.\n  Thread.sleep(2000)\n  system.terminate() // Terminate the ActorSystem after tests run.\n}"
      }
    ]
  },
    {
    "conversations": [
      {
        "from": "human",
        "value": "Showcase actor communication patterns: Request-Response with future, Fire-and-Forget, and Publish-Subscribe in a single application."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.collection.mutable\nimport scala.util.{Success, Failure}\n\n// --- Message Definitions --- //\n// Request-Response messages:\ncase class  MultiplyRequest(a: Int, b: Int) // Request to multiply.\ncase class  MultiplyResult(product: Int)   // Response with result.\n\n// Publish-Subscribe messages:\ncase class  SubscribeTopic(topic: String) // Subscribe to a topic.\ncase class  UnsubscribeTopic(topic: String) // Unsubscribe from a topic.\ncase class  PublishMessage(topic: String, message: String) // Publish message to topic.\ncase class  MessagePublished(topic: String, message: String) // Confirmation of publish.\ncase class  TopicMessage(topic: String, message: String) // Message delivered on topic.\n\n// Fire-and-Forget message:\ncase class LogEvent(event: String) // Log an event.\n\n// --- Actors --- //\n\n// Request-Response Actor: CalculatorActor\nclass CalculatorActor extends Actor {\n  def receive: Receive = {\n    case MultiplyRequest(a, b) =>\n      val product = a * b\n      println(s\"[CalculatorActor] Multiplying $a * $b = $product, responding to ${sender().path.name}\")\n      sender() ! MultiplyResult(product)\n    case _ => println(\"[CalculatorActor] Unknown message.\")\n  }\n}\n\n// Publish-Subscribe Actor: PubSubMediatorActor\nclass PubSubMediatorActor extends Actor {\n  private val subscribers = mutable.Map[String, mutable.Set[ActorRef]]() // Topic -> Subscribers.\n\n  def receive: Receive = {\n    case SubscribeTopic(topic) =>\n      val topicSubscribers = subscribers.getOrElseUpdate(topic, mutable.Set.empty)\n      topicSubscribers += sender()\n      subscribers(topic) = topicSubscribers // Update the map.\n      println(s\"[PubSubMediatorActor] ${sender().path.name} subscribed to topic '$topic', subscribers count: ${subscribers(topic).size}\")\n\n    case UnsubscribeTopic(topic) =>\n      subscribers.get(topic).foreach { topicSubscribers =>\n        topicSubscribers -= sender()\n        if (topicSubscribers.isEmpty) subscribers -= topic // Remove topic if no subscribers.\n        println(s\"[PubSubMediatorActor] ${sender().path.name} unsubscribed from topic '$topic', subscribers count now: ${subscribers.get(topic).map(_.size).getOrElse(0)}\")\n      }\n\n    case PublishMessage(topic, message) =>\n      println(s\"[PubSubMediatorActor] Publishing message: '$message' on topic '$topic'.\")\n      subscribers.get(topic).foreach {\n        _.foreach(subscriber => subscriber ! TopicMessage(topic, message))\n      }\n      sender() ! MessagePublished(topic, message) // Confirmation to publisher.\n    case _ => println(\"[PubSubMediatorActor] Unknown message.\")\n  }\n}\n\n// Fire-and-Forget Actor: LoggerActor\nclass LoggerActor extends Actor {\n  def receive: Receive = {\n    case LogEvent(event) =>\n      // Simulate asynchronous logging, no response expected.\n      println(s\"[LoggerActor] Fire-and-Forget Logging: Event received: '$event'\")\n      Thread.sleep(100) // Simulate logging delay.\n      println(s\"[LoggerActor] Event '$event' logged.\")\n    case _ => println(\"[LoggerActor] Unknown message.\")\n  }\n}\n\n// Client Actor to demonstrate all patterns\nclass ClientActor extends Actor {\n  implicit val timeout: Timeout = Timeout(5.seconds)\n  val calculatorActor = context.actorOf(Props[CalculatorActor](), \"calculatorActor\")\n  val pubSubMediator = context.actorOf(Props[PubSubMediatorActor](), \"pubSubMediatorActor\")\n  val loggerActor = context.actorOf(Props[LoggerActor](), \"loggerActor\")\n\n  override def preStart(): Unit = {\n    // Subscribe to topic \"alerts\" on startup.\n    pubSubMediator ! SubscribeTopic(\"alerts\")\n    super.preStart()\n  }\n\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"[ClientActor] Starting communication pattern demonstration.\")\n\n      // --- 1. Request-Response (Ask Pattern) --- //\n      println(\"[ClientActor] Demonstrating Request-Response (Ask Pattern) with CalculatorActor...\")\n      val futureMultiplyResult = calculatorActor ? MultiplyRequest(5, 6)\n      futureMultiplyResult.onComplete {\n        case Success(MultiplyResult(product)) => println(s\"[ClientActor] Received Multiply Result: $product\")\n        case Failure(ex) => println(s\"[ClientActor] Multiplication failed: ${ex.getMessage}\")\n      }\n\n      // --- 2. Fire-and-Forget --- //\n      println(\"[ClientActor] Demonstrating Fire-and-Forget with LoggerActor...\")\n      loggerActor ! LogEvent(\"Application started event\") // No Future, no expect response.\n      loggerActor ! LogEvent(\"User login event\")      // Just send and forget.\n\n      // --- 3. Publish-Subscribe --- //\n      println(\"[ClientActor] Demonstrating Publish-Subscribe with PubSubMediator and topic 'alerts'...\")\n      pubSubMediator ! PublishMessage(\"alerts\", \"System online, services operational.\") // Publish a message.\n      pubSubMediator ! PublishMessage(\"alerts\", \"Warning: Low disk space on server X.\") // Another message.\n\n      Thread.sleep(2000) // Wait for operations to complete and print outputs.\n      println(\"[ClientActor] Communication pattern demo completed.\")\n\n    case TopicMessage(topic, message) => // Received Topic message from PubSubMediator.\n      println(s\"[ClientActor] Received Topic message on '$topic': '$message'\")\n    case _ => println(\"[ClientActor] Unknown message.\")\n  }\n}\n\nobject CommunicationPatternsApp extends App {\n  // Create Actor System\n  val system = ActorSystem(\"CommunicationSystem\")\n\n  // Create Client Actor - which drives all communication examples.\n  val clientActor = system.actorOf(Props[ClientActor](), \"clientActor\")\n\n  // Start the demo.\n  clientActor ! \"start\"\n\n  Thread.sleep(8000)\n\n  // Terminate Actor System.\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Showcase Akka Streams for building a simple data processing pipeline: Source -> Flow -> Sink. Process strings, convert to uppercase, and log to console."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.ActorSystem\nimport akka.stream.scaladsl.{Sink, Source, Flow}\nimport akka.stream.{ActorMaterializer, Materializer}\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\n\nobject AkkaStreamsPipelineApp extends App {\n  // ActorSystem and Materializer are needed to run Akka Streams.\n  implicit val system: ActorSystem = ActorSystem(\"StreamsSystem\")\n  implicit val materializer: Materializer = ActorMaterializer()\n\n  // --- 1. Define the Source --- //\n  // Source of strings, could be from any data source like a file, queue, HTTP endpoint etc.\n  val stringSource = Source(List(\"hello\", \"akka\", \"streams\", \"pipeline\"))\n  println(\"[StreamApp] Source created with strings: hello, akka, streams, pipeline\")\n\n  // --- 2. Define the Flow --- //\n  // Flow to transform each string to uppercase.\n  val uppercaseFlow: Flow[String, String, akka.NotUsed] = Flow[String].map {\n    str =>\n      val upperStr = str.toUpperCase\n      println(s\"[StreamApp] Flow processing: converting '$str' to '$upperStr'\")\n      upperStr\n  }\n\n  // --- 3. Define the Sink --- //\n  // Sink that prints each processed uppercase string to console.\n  val consoleSink: Sink[String, Future[akka.Done]] = Sink.foreach[String] {\n    upperStr =>\n      println(s\"[StreamApp] Sink processing: printing '$upperStr' to console\")\n  }\n\n  // --- 4. Assemble the pipeline: Source -> Flow -> Sink --- //\n  println(\"[StreamApp] Assembling the stream pipeline: Source -> Flow -> Sink\")\n  val stream = stringSource.via(uppercaseFlow).to(consoleSink)\n\n  // --- 5. Run the stream --- //\n  println(\"[StreamApp] Running the stream...\")\n  val streamRunning: Future[akka.Done] = stream.run()\n\n  // --- 6. Handle stream completion or failure --- //\n  streamRunning.onComplete {\n    case scala.util.Success(_) =>\n      println(\"[StreamApp] Stream pipeline completed successfully.\")\n      system.terminate() // Terminate ActorSystem after stream completion.\n    case scala.util.Failure(ex) =>\n      println(s\"[StreamApp] Stream pipeline failed: ${ex.getMessage}\")\n      system.terminate() // Terminate system even on failure.\n  }\n\n  println(\"[StreamApp] Stream execution initiated. Check console for processed output.\")\n}\n\n// Expected Output (order may slightly vary due to async nature):\n// [StreamApp] Source created with strings: hello, akka, streams, pipeline\n// [StreamApp] Assembling the stream pipeline: Source -> Flow -> Sink\n// [StreamApp] Running the stream...\n// [StreamApp] Stream execution initiated. Check console for processed output.\n// [StreamApp] Flow processing: converting 'hello' to 'HELLO'\n// [StreamApp] Flow processing: converting 'akka' to 'AKKA'\n// [StreamApp] Flow processing: converting 'streams' to 'STREAMS'\n// [StreamApp] Flow processing: converting 'pipeline' to 'PIPELINE'\n// [StreamApp] Sink processing: printing 'HELLO' to console\n// [StreamApp] Sink processing: printing 'AKKA' to console\n// [StreamApp] Sink processing: printing 'STREAMS' to console\n// [StreamApp] Sink processing: printing 'PIPELINE' to console\n// [StreamApp] Stream pipeline completed successfully."
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Demonstrate Akka HTTP for creating a simple REST API endpoint that responds with \"Hello, Akka HTTP!\" to GET requests."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.ActorSystem\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.server.Directives._\nimport akka.http.scaladsl.server.Route\nimport akka.stream.ActorMaterializer\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.io.StdIn\n\nobject AkkaHttpSimpleServerApp extends App {\n  // Akka actors, streams, and HTTP need an ActorSystem and Materializer.\n  implicit val system = ActorSystem(\"SimpleHttpServer\")\n  implicit val materializer = ActorMaterializer()\n\n  // Define the HTTP route.\n  // GET request to root path \"/\" will be handled here.\n  val route: Route = path(\"\") {\n    get {\n      // Responds with plain text message.\n      complete(\"Hello, Akka HTTP!\")\n    }\n  }\n\n  // Start the HTTP server and bind to interface and port.\n  val bindingFuture = Http().bindAndHandle(route, \"localhost\", 8080)\n\n  println(s\"Server online at http://localhost:8080/\\nPress RETURN to stop...\")\n\n  // Handle server binding success or failure.\nbindingFuture.map {\n    binding =>\n      println(s\"Server started at ${binding.localAddress}\")\n  }.recover {\n    case ex =>\n      println(s\"Server binding failed: ${ex.getMessage}\")\n      system.terminate()\n  }\n\n  // Keep the server running until user presses RETURN.\n  StdIn.readLine()\n  bindingFuture\n    .flatMap(_.unbind()) // Triggers the unbinding from the port\n    .onComplete(_ => system.terminate()) // When binding future completes, terminate the actor system.\n\n  println(\"Server stopped and ActorSystem terminated.\")\n}\n\n// To test, you can use a browser or curl:\n// curl http://localhost:8080"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement Akka Typed Actors: Create a typed Counter Actor and demonstrate interaction."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.typed.{ActorSystem, Behavior, Props}\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.scaladsl.ActorContext\n\n// --- Define Message Protocol for Typed Counter Actor --- //\nsealed trait CounterCommand\ncase object Increment extends CounterCommand\ncase object Decrement extends CounterCommand\ncase object GetCount extends CounterCommand\ncase class  RespondCount(count: Int) extends CounterCommand // Response message\n\nobject TypedCounterActor {\n  // --- Behavior Definition for Typed Counter Actor --- //\n  def apply(): Behavior[CounterCommand] = Behaviors.setup { context =>\n    println(s\"[TypedCounterActor - ${context.self.path.name}] Actor instance started.\")\n    var count = 0 // Mutable state, now within Behavior scope.\n\n    Behaviors.receiveMessage {\n      case Increment =>\n        count += 1\n        println(s\"[TypedCounterActor - ${context.self.path.name}] Count incremented to: $count\")\n        Behaviors.same // Stay in the same behavior state.\n      case Decrement =>\n        count -= 1\n        println(s\"[TypedCounterActor - ${context.self.path.name}] Count decremented to: $count\")\n        Behaviors.same\n      case GetCount =>\n        println(s\"[TypedCounterActor - ${context.self.path.name}] GetCount request, responding with current count.\")\n        context.sender() ! RespondCount(count) // Use context.sender() for replies in typed.\n        Behaviors.same\n      case RespondCount(_) =>\n        println(s\"[TypedCounterActor - ${context.self.path.name}] Received RespondCount, should not happen here.\")\n        Behaviors.unhandled // Message unexpected for this actor type.\n    }\n  }\n}\n\nobject AkkaTypedActorApp extends App {\n  // --- Create Typed Actor System --- //\n  val system: ActorSystem[CounterCommand] = ActorSystem(TypedCounterActor(), \"TypedSystem\")\n  println(\"[TypedSystem] Actor system started for Typed Actors.\")\n\n  // --- Create Typed Actor Instance (ref) --- //\n  val typedCounter = system // Root behavior itself becomes the actor ref in this simplified example for CounterCommand typed system.\n  println(s\"[TypedSystem] Typed Counter Actor created: ${typedCounter.path.name}\")\n\n  // --- Interact with Typed Actor by sending Messages --- //\n  println(\"[TypedSystem] Sending Increment messages...\")\n  typedCounter ! Increment\n  typedCounter ! Increment\n  typedCounter ! Increment\n\n  println(\"[TypedSystem] Sending Decrement message...\")\n  typedCounter ! Decrement\n\n  println(\"[TypedSystem] Sending GetCount message and expecting response...\")\n  import akka.util.Timeout\n  import scala.concurrent.duration._\n  import scala.concurrent.Await\n  implicit val timeout: Timeout = Timeout(3.seconds)\n  val countResponseFuture = akka.pattern.Patterns.ask(typedCounter, (ref: akka.actor.ActorRef) => GetCount) //Adapt message with actorRef needed by classic ask\n  val response = Await.result(countResponseFuture, timeout.duration).asInstanceOf[RespondCount]\n  println(s\"[TypedSystem] Current count from Typed Counter Actor: ${response.count}\")\n\n  Thread.sleep(2000)\n  println(\"[TypedSystem] Terminating Actor System...\")\n  system.terminate()\n  println(\"[TypedSystem] Actor System terminated.\")\n}\n\n// Expected Output (order of logs from actors might be interleaved):\n// [TypedSystem] Actor system started for Typed Actors.\n// [TypedCounterActor - /] Actor instance started.\n// [TypedSystem] Typed Counter Actor created: /\n// [TypedSystem] Sending Increment messages...\n// [TypedCounterActor - /] Count incremented to: 1\n// [TypedCounterActor - /] Count incremented to: 2\n// [TypedCounterActor - /] Count incremented to: 3\n// [TypedSystem] Sending Decrement message...\n// [TypedCounterActor - /] Count decremented to: 2\n// [TypedSystem] Sending GetCount message and expecting response...\n// [TypedCounterActor - /] GetCount request, responding with current count.\n// [TypedSystem] Current count from Typed Counter Actor: 2\n// [TypedSystem] Terminating Actor System...\n// [TypedSystem] Actor System terminated."
      }
    ]
  },
    {
    "conversations": [
      {
        "from": "human",
        "value": "Illustrate Akka Cluster usage: Setup a basic cluster with two member nodes, and show inter-node actor communication."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.ActorSystem\nimport akka.actor.Props\nimport akka.cluster.Cluster\nimport akka.actor.Actor\nimport com.typesafe.config.ConfigFactory\nimport scala.io.StdIn\n\n// --- Define Messages --- //\ncase class  ClusterMessage(text: String) // Message to send across cluster.\n\n// --- Define Cluster Actor (to receive and log messages) --- //\nclass ClusterReceiverActor extends Actor {\n  def receive: Receive = {\n    case ClusterMessage(text) =>\n      println(s\"[ClusterReceiverActor - ${self.path.name}] Received cluster message: '$text' from ${sender().path.name}\")\n    case _ =>\n      println(s\"[ClusterReceiverActor - ${self.path.name}] Unknown message.\")\n  }\n}\n\nobject AkkaClusterNodeApp extends App {\n  // --- Define Configuration for Cluster Node --- //\n  // Configuration loaded from application.conf or passed as override.\n  val isSeedNode = args.contains(\"seed\") // Check if started as seed node.\n  val config = if (isSeedNode) {\n    ConfigFactory.parseString(\"\"\"\n      akka {\n        actor {\n          provider = cluster\n        }\n        remote {\n          netty.tcp {\n            hostname = \"127.0.0.1\"\n            port = 2551 // Seed node port, must be consistent for cluster discovery.\n          }\n        }\n        cluster {\n          seed-nodes = [\"akka.tcp://ClusterSystem@127.0.0.1:2551\"]\n        }\n      }\n    \"\"\").withFallback(ConfigFactory.load())\n  } else {\n    ConfigFactory.parseString(\"\"\"\n      akka {\n        actor {\n          provider = cluster\n        }\n        remote {\n          netty.tcp {\n            hostname = \"127.0.0.1\"\n            port = 2552 // Non-seed node port.\n          }\n        }\n      }\n    \"\"\").withFallback(ConfigFactory.load())\n  }\n\n  // --- Create Actor System with Configuration --- //\n  implicit val system = ActorSystem(\"ClusterSystem\", config) // Same name for all cluster nodes.\n  println(s\"[ClusterNodeApp] ActorSystem '${system.name}' started, node address: ${Cluster(system).selfAddress}, seed node? : $isSeedNode\")\n\n  // --- Join Cluster (if not seed node, seed node will automatically form cluster) --- //\n  if (!isSeedNode) {\n    Cluster(system).joinSeedNodes(immutable.Seq(akka.actor.Address(\"akka.tcp\", \"ClusterSystem\", \"127.0.0.1\", 2551))) // Join seed node.\n    println(s\"[ClusterNodeApp] Joining cluster via seed nodes at akka.tcp://ClusterSystem@127.0.0.1:2551\")\n  } else {\n    println(s\"[ClusterNodeApp] Starting as seed node, cluster forming will happen automatically.\")\n  }\n\n  // --- Create a Cluster Receiver Actor on each node --- //\n  val clusterReceiverActor = system.actorOf(Props[ClusterReceiverActor](), \"clusterReceiverActor\")\n  println(s\"[ClusterNodeApp] Cluster receiver actor created at: ${clusterReceiverActor.path.toString}\")\n\n  println(\"Cluster node started, press RETURN to terminate.\")\n  StdIn.readLine()\n  system.terminate()\n  println(\"Cluster node terminated.\")\n}\n\n// To Run in Two Terminal Windows (for example):\n// Terminal 1 (Seed Node):\n// sbt \"runMain com.example.AkkaClusterNodeApp seed\" // 'seed' argument indicates seed node.\n\n// Terminal 2 (Non-Seed Node):\n// sbt \"runMain com.example.AkkaClusterNodeApp\"     // No argument, runs as non-seed.\n\n// After nodes are running:\n// From either terminal, you can send messages to the 'clusterReceiverActor' via actorSelection by knowing its path, e.g.,\n// system.actorSelection(\"akka.tcp://ClusterSystem@127.0.0.1:2552/user/clusterReceiverActor\") ! ClusterMessage(\"Hello from Seed Node to Non-Seed Node!\")\n// or from non-seed to seed:\n// system.actorSelection(\"akka.tcp://ClusterSystem@127.0.0.1:2551/user/clusterReceiverActor\") ! ClusterMessage(\"Hi from Non-Seed Node to Seed Node!\")\n// (Adjust actor path if you changed actor name or deployment location)."
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a Stream that integrates with Actors: Actor as a Source, Actor as a Sink, and Actor as a Flow processor in a stream."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.stream.ActorMaterializer\nimport akka.stream.scaladsl.{Source, Sink, Flow, SourceQueueWithComplete}\nimport akka.util.Timeout\nimport akka.pattern.ask\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\nimport akka.stream.OverflowStrategy\n\n// --- Messages --- //\ncase class  StreamElement(data: String) // Element flowing in stream.\ncase class  StreamInit()           // Initialize stream processing.\ncase class  StreamComplete()       // Signal stream completion.\ncase class  StreamFailure(ex: Throwable) // Signal stream failure.\ncase class  RequestElement()       // Request for next stream element (Actor as Source).\ncase class  ProcessElement(element: StreamElement) // Process stream element (Actor as Flow).\ncase class  ElementProcessed(element: StreamElement, result: String) // Response from Flow processor.\ncase class  SinkElement(element: StreamElement)    // Element to sink (Actor as Sink).\ncase object  Ack                    // Acknowledge processing.\ncase object  StreamStarted          // Stream has started.\ncase object  ProducerRequestsDemand // Producer is requesting demand from source actor.\n\n// --- Actor as Stream Source --- //\nclass StreamSourceActor extends Actor {\n  private var elements = List(\"Element-1\", \"Element-2\", \"Element-3\", \"Element-4\") // Example source data.\n  private var requestedDemand = 0L // Keep track of downstream demand.\n  private var requester: Option[ActorRef] = None // Actor who is requesting elements.\n\n  def receive: Receive = {\n    case StreamStarted =>\n      println(s\"[SourceActor - ${self.path.name}] Stream started, ready to produce elements.\")\n      requester = Some(sender()) // Register the initial requester as the stream's actorRef.\n      requestDemand()          // Initiate demand request right after stream start.\n\n    case ProducerRequestsDemand =>\n      requestDemand() // Called when producer needs more elements.\n\n    case RequestElement => // Demand request from stream consumer.\n      if (elements.nonEmpty && requestedDemand > 0) {\n        val element = elements.head\n        elements = elements.tail\n        println(s\"[SourceActor - ${self.path.name}] Sending element: '$element', remaining elements: ${elements.size}, requested demand: $requestedDemand.\")\n        sender() ! StreamElement(element) // Send element downstream.\n        requestedDemand -= 1\n        if(elements.nonEmpty) requestDemand() // Request more if still elements available.\n      } else if (elements.isEmpty) {\n        println(s\"[SourceActor - ${self.path.name}] No more elements, completing stream.\")\n        sender() ! akka.stream.actor.ActorPublisherMessage.Complete // Signal completion when no elements left.\n      } else {\n        println(s\"[SourceActor - ${self.path.name}] No demand, waiting for demand before sending more elements.\")\n      }\n\n    case akka.stream.actor.ActorPublisherMessage.Request(demand) =>\n      println(s\"[SourceActor - ${self.path.name}] Received demand request: $demand, current demand: $requestedDemand.\")\n      requestedDemand += demand\n      self ! RequestElement // Trigger element production attempt when new demand arrives.\n\n    case akka.stream.actor.ActorPublisherMessage.Cancel =>\n      println(s\"[SourceActor - ${self.path.name}] Stream cancelled by downstream.\")\n      context.stop(self) // Stop actor on stream cancellation.\n  }\n\n  private def requestDemand(): Unit = {\n    requester.foreach(_ ! akka.stream.actor.ActorPublisherMessage.Request(1)) // Request one element at a time for simplicity.\n  }\n}\n\n// --- Actor as Stream Flow Processor --- //\nclass StreamProcessorActor extends Actor {\n  def receive: Receive = {\n    case ProcessElement(element) =>\n      println(s\"[ProcessorActor - ${self.path.name}] Processing element: '${element.data}'...\")\n      Thread.sleep(200) // Simulate processing delay.\n      val result = element.data.toUpperCase\n      println(s\"[ProcessorActor - ${self.path.name}] Element processed, sending result: '$result'.\")\n      sender() ! ElementProcessed(element, result) // Send processed result.\n    case _ =>\n      println(s\"[ProcessorActor - ${self.path.name}] Unknown message.\")\n  }\n}\n\n// --- Actor as Stream Sink --- //\nclass StreamSinkActor extends Actor {\n  def receive: Receive = {\n    case SinkElement(element) =>\n      println(s\"[SinkActor - ${self.path.name}] Sinking element: '${element.data}'.\")\n      Thread.sleep(100) // Simulate sinking operation.\n      sender() ! Ack // Acknowledge element processed.\n    case akka.stream.actor.ActorSubscriberMessage.OnComplete =>\n      println(s\"[SinkActor - ${self.path.name}] Stream completed successfully.\")\n      context.stop(self) // Stop actor on stream completion.\n    case akka.stream.actor.ActorSubscriberMessage.OnError(ex) =>\n      println(s\"[SinkActor - ${self.path.name}] Stream encountered error: ${ex.getMessage}\")\n      context.stop(self) // Stop actor on stream error.\n    case akka.stream.actor.ActorSubscriberMessage.OnNext(element: StreamElement) => // Receive elements from stream.\n      self ! SinkElement(element) // Process internally, forwarding element message to own receive.\n    case Ack => // Handle acknowledgment after element is processed.\n      sender() ! akka.stream.actor.ActorSubscriberMessage.Ack // Send acknowledgment back to stream.\n    case _ =>\n      println(s\"[SinkActor - ${self.path.name}] Unknown message.\")\n  }\n}\n\nobject ActorStreamIntegrationApp extends App {\n  implicit val system = ActorSystem(\"ActorStreamSystem\")\n  implicit val materializer = ActorMaterializer()\n  implicit val timeout: Timeout = Timeout(5.seconds)\n\n  // --- 1. Actor as Source --- //\n  import akka.stream.actor.ActorPublisher\n  val sourceActorRef: ActorRef = system.actorOf(Props[StreamSourceActor](), \"streamSourceActor\")\n  val streamSource = Source.fromPublisher(ActorPublisher[StreamElement](sourceActorRef))\n\n  // --- 2. Actor as Flow Processor --- //\n  import akka.stream.actor.ActorFlow\n  val flowActorRef: ActorRef = system.actorOf(Props[StreamProcessorActor](), \"streamProcessorActor\")\n  val actorFlow = ActorFlow.ask[StreamElement, ElementProcessed, ActorRef](flowActorRef)(parallelism = 2) { (element, replyTo) =>\n    ProcessElement(element)\n  }\n\n  // --- 3. Actor as Sink --- //\n  import akka.stream.actor.ActorSubscriber\n  import akka.stream.actor.RequestStrategy\n  import akka.stream.actor.MaxInFlightRequestStrategy\n\n  class SinkActorSubscription extends ActorSubscriber { // Custom Subscriber Implementation needed to control request.\n    override val requestStrategy: RequestStrategy = MaxInFlightRequestStrategy(max = 5) {\n      case _ => 5 // Request 5 more elements at a time when needed.\n    }\n    override def receive = streamSinkActor.receive // Delegate receive to actual sink actor.\n  }\n\n  val streamSinkActorRef: ActorRef = system.actorOf(Props[StreamSinkActor](), \"streamSinkActor\")\n  val streamSink = Sink.fromSubscriber(ActorSubscriber[StreamElement](streamSinkActorRef))\n\n  // --- 4. Assemble and Run the Stream --- //\n  println(\"[StreamApp] Assembling and running stream: Source (Actor) -> Flow (Actor) -> Sink (Actor).\")\n  val stream = streamSource\n    .via(Flow[StreamElement].map { el => println(s\"[StreamApp] Element passing through stream: ${el.data}\"); el })\n    .via(actorFlow)\n    .map { processed => StreamElement(processed.result) }\n    .runWith(streamSink)\n\n  // Initiate Stream by sending Start message to source actor. Need to do this manually when using ActorPublisher.\n  sourceActorRef ! StreamStarted\n\n  Thread.sleep(10000)\n  system.terminate()\n}\n\n// Run this code and observe logs from SourceActor, ProcessorActor, and SinkActor alongside stream logs.\n// It demonstrates data flowing from actor source, being processed by actor flow, and consumed by actor sink in an Akka Stream."
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create a Replicated Cache using Akka Distributed Data to share state across cluster nodes."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.cluster.Cluster\nimport akka.cluster.ddata._\nimport akka.cluster.ddata.ReplicatedData\nimport akka.cluster.ddata.ReplicatedData._\nimport com.typesafe.config.ConfigFactory\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Success, Failure}\nimport scala.io.StdIn\n\n// --- Define Messages --- //\ncase class  CachePut(key: String, value: String) // Put entry in cache.\ncase class  CacheGet(key: String)               // Get entry from cache.\ncase class  GetResponse(key: String, value: Option[String]) // Response for CacheGet.\ncase class  PrintCacheState()                    // Print current local cache state.\n\n// --- Replicated Cache Actor --- //\nclass ReplicatedCacheActor extends Actor {\n  import ReplicatedCacheActor._\n\n  implicit val node = Cluster(context.system)\n  implicit val selfUniqueAddress = ReplicatedData.selfUniqueAddress(context.system)\n  val dataReplicator = DistributedData(context.system).replicator // Access replicator.\n\n  // Key for CRDT map in Distributed Data, must be unique per data item.\n  private val cacheMapKey = ReplicatedKey[ORMap[String, String]](\"cache-data-1\")\n  private val readConsistency = ReadMajority(timeout = 5.seconds)  // Read majority nodes consistency.\n  private val writeConsistency = WriteMajority(timeout = 5.seconds) // Write to majority.\n\n  def receive: Receive = {\n    case CachePut(key, value) =>\n      println(s\"[CacheActor - ${self.path.name}] Putting key '$key' with value '$value' into cache.\")\n      val update = Update(cacheMapKey, ORMap.empty[String, String], writeConsistency) { existingCache =>\n        existingCache :+ (key -> value) // Update operation using ORMap add.\n      }\n      dataReplicator ! update // Send update request to replicator.\n\n    case CacheGet(key) =>\n      println(s\"[CacheActor - ${self.path.name}] Getting value for key '$key' from cache.\")\n      val getQuery = Get(cacheMapKey, readConsistency, request = Some(CacheGetResponse(key, sender()))) // Query cache.\n      dataReplicator ! getQuery // Send get request to replicator.\n\n    case g @ GetSuccess(cacheMapKey.key, Some(CacheGetResponse(key, originalSender))) =>\n      val cachedMap = g.dataValue.get(selfUniqueAddress) // Retrieve data.\n      val value = cachedMap.flatMap(_.get(key))\n      println(s\"[CacheActor - ${self.path.name}] Successfully retrieved key '$key', value: ${value.getOrElse(\"NotFound\")}.\")\n      originalSender ! GetResponse(key, value)\n\n    case NotFound(cacheMapKey.key, Some(CacheGetResponse(key, originalSender))) =>\n      println(s\"[CacheActor - ${self.path.name}] Key '$key' not found in cache.\")\n      originalSender ! GetResponse(key, None)\n\n    case GetFailure(cacheMapKey.key, Some(CacheGetResponse(key, originalSender))) =>\n      println(s\"[CacheActor - ${self.path.name}] Get operation for key '$key' failed.\")\n      originalSender ! GetResponse(key, None) // Respond with None on failure as well.\n\n    case UpdateSuccess(cacheMapKey.key, _) =>\n      println(s\"[CacheActor - ${self.path.name}] Successfully updated cache.\")\n\n    case UpdateFailure(cacheMapKey.key, cause, _) =>\n      println(s\"[CacheActor - ${self.path.name}] Cache update failed: ${cause.getMessage}\")\n\n    case PrintCacheState => // For debugging and demo purpose.\n      println(s\"[CacheActor - ${self.path.name}] Printing local cache state...\")\n      dataReplicator ! Get(cacheMapKey, ReadLocal, request = Some(PrintLocalResponse))\n\n    case g @ GetSuccess(cacheMapKey.key, Some(PrintLocalResponse)) =>\n      val localCacheState = g.dataValue.entries\n      println(s\"[CacheActor - ${self.path.name}] Local cache state: $localCacheState\")\n\n    case GetFailure(cacheMapKey.key, Some(PrintLocalResponse)) =>\n      println(s\"[CacheActor - ${self.path.name}] Failed to retrieve local cache state.\")\n\n    case _ =>\n      println(s\"[CacheActor - ${self.path.name}] Unknown message.\")\n  }\n}\n\nobject ReplicatedCacheActor {\n  private case class CacheGetResponse(key: String, replyTo: ActorRef)\n  private case object PrintLocalResponse\n}\n\nobject ReplicatedCacheApp extends App {\n  // --- Define Configuration (Cluster enabled) --- //\n  val isSeedNode = args.contains(\"seed\")\n  val config = if (isSeedNode) {\n    ConfigFactory.parseString(\"\"\"\n      akka {\n        actor {\n          provider = cluster\n        }\n        remote {\n          netty.tcp {\n            hostname = \"127.0.0.1\"\n            port = 2551\n          }\n        }\n        cluster {\n          seed-nodes = [\"akka.tcp://CacheSystem@127.0.0.1:2551\"]\n        }\n      }\n    \"\"\").withFallback(ConfigFactory.load())\n  } else {\n    ConfigFactory.parseString(\"\"\"\n      akka {\n        actor {\n          provider = cluster\n        }\n        remote {\n          netty.tcp {\n            hostname = \"127.0.0.1\"\n            port = 2552\n          }\n        }\n      }\n    \"\"\").withFallback(ConfigFactory.load())\n  }\n\n  // --- Create Actor System for Cache Node --- //\n  implicit val system = ActorSystem(\"CacheSystem\", config)\n  println(s\"[CacheApp] ActorSystem '${system.name}' started, node address: ${Cluster(system).selfAddress}, seed node? : $isSeedNode\")\n\n  if (!isSeedNode) {\n    Cluster(system).joinSeedNodes(immutable.Seq(akka.actor.Address(\"akka.tcp\", \"CacheSystem\", \"127.0.0.1\", 2551)))\n    println(s\"[CacheApp] Joining cluster via seed node.\")\n  } else {\n    println(s\"[CacheApp] Starting as seed node.\")\n  }\n\n  // --- Create Replicated Cache Actor --- //\n  val cacheActor = system.actorOf(Props[ReplicatedCacheActor](), \"replicatedCacheActor\")\n\n  // --- Interaction Example (Manual input for demo) --- //\n  println(\"Replicated Cache Node started. Type commands: put <key> <value>, get <key>, print, exit.\")\n  commandLoop(cacheActor)\n\n  def commandLoop(cacheActor: ActorRef): Unit = {\n    var running = true\n    while (running) {\n      StdIn.readLine() match {\n        case line if line.startsWith(\"put \") =>\n          val parts = line.substring(4).split(\" \", 2)\n          if (parts.length == 2) { cacheActor ! CachePut(parts(0), parts(1)) }\n        case line if line.startsWith(\"get \") =>\n          val key = line.substring(4)\n          cacheActor ! CacheGet(key)\n        case \"print\" =>\n          cacheActor ! PrintCacheState\n        case \"exit\" => running = false\n        case _ => println(\"Invalid command.\")\n      }\n    }\n    println(\"Exiting and terminating system.\")\n    system.terminate()\n  }\n}\n\n// To run this example (two terminals):\n// Terminal 1 (Seed Node):\n// sbt \"runMain com.example.ReplicatedCacheApp seed\" // 'seed' argument to start as seed node.\n\n// Terminal 2 (Non-Seed Node):\n// sbt \"runMain com.example.ReplicatedCacheApp\"     // No argument, joins seed node.\n\n// On either node console, you can interact:\n// e.g., on Seed Node, type 'put item1 value1' <Enter>, on Non-Seed node, type 'get item1' <Enter> -> should retrieve 'value1'."
      }
    ]
  }
]