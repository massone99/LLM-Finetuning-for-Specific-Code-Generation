[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Typed Cluster Example: Give an example of a typed cluster where each node logs 'Cluster member up' upon joining the cluster."
      },
      {
        "from": "assistant",
        "value": "// TypedClusterExample.scala\n// This example subscribes to all cluster events using the typed API and logs when a member is marked as Up.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\n// Import cluster events from the proper package\nimport akka.cluster.typed.ClusterEvent.{MemberEvent, MemberUp, MemberRemoved}\nimport akka.cluster.typed.{Cluster, Subscribe}\n\nobject TypedClusterExample {\n  // Define a protocol for our cluster listener\n  sealed trait Command\n  private final case class WrappedMemberEvent(event: MemberEvent) extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { context =>\n    // Obtain the Cluster instance from the typed ActorSystem\n    val cluster = Cluster(context.system)\n\n    // Create a message adapter that wraps MemberEvent into our Command\n    val memberEventAdapter = context.messageAdapter[MemberEvent](WrappedMemberEvent(_))\n\n    // Subscribe to all cluster events (MemberUp, MemberRemoved, etc.)\n    cluster.subscriptions ! Subscribe(memberEventAdapter, classOf[MemberEvent])\n\n    // Process incoming wrapped events\n    Behaviors.receiveMessage {\n      case WrappedMemberEvent(MemberUp(member)) =>\n        context.log.info(s\"Cluster member is Up: ${member.address}\")\n        Behaviors.same\n      case WrappedMemberEvent(MemberRemoved(member, previousStatus)) =>\n        context.log.info(s\"Cluster member removed: ${member.address} (was $previousStatus)\")\n        Behaviors.same\n      case WrappedMemberEvent(event) =>\n        context.log.info(s\"Other cluster event: $event\")\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedClusterExampleApp extends App {\n  // In a real cluster, you would start multiple ActorSystems on different ports\n  val system: ActorSystem[TypedClusterExample.Command] = ActorSystem(TypedClusterExample(), \"MyCluster\")\n  Thread.sleep(10000) // Allow time for cluster events to be logged\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Typed Persistence Example: Create a typed persistence actor that stores and retrieves a counter state."
      },
      {
        "from": "assistant",
        "value": "// TypedPersistenceExample.scala\n// This example uses Akka Persistence Typed to implement a simple counter actor\n\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.persistence.typed.PersistenceId\nimport akka.persistence.typed.scaladsl.{EventSourcedBehavior, Effect, RetentionCriteria}\n\nobject TypedPersistenceExample {\n  // Define commands\n  sealed trait Command\n  case object Increment extends Command\n  case object Decrement extends Command\n  case object PrintState extends Command\n\n  // Define events\n  sealed trait Event\n  case object Incremented extends Event\n  case object Decremented extends Event\n\n  // Define the state\n  final case class CounterState(value: Int)\n\n  // Create the behavior using EventSourcedBehavior\n  def apply(entityId: String): Behavior[Command] = EventSourcedBehavior[\n    Command,\n    Event,\n    CounterState\n  ](\n    persistenceId = PersistenceId.ofUniqueId(entityId),\n    emptyState = CounterState(0),\n    commandHandler = (state, command) => command match {\n      case Increment => Effect.persist(Incremented)\n      case Decrement => Effect.persist(Decremented)\n      case PrintState =>\n        println(s\"Current state: ${state.value}\")\n        Effect.none\n    },\n    eventHandler = (state, event) => event match {\n      case Incremented => state.copy(value = state.value + 1)\n      case Decremented => state.copy(value = state.value - 1)\n    }\n  ).withRetention(\n    RetentionCriteria.snapshotEvery(numberOfEvents = 10, keepNSnapshots = 2)\n  )\n}\n\nobject TypedPersistenceExampleApp extends App {\n  import TypedPersistenceExample._\n  // Start the actor system with our persistent counter\n  val system: ActorSystem[Command] = ActorSystem(TypedPersistenceExample(\"CounterEntity\"), \"TypedPersistenceSystem\")\n  system ! Increment\n  system ! Increment\n  system ! Decrement\n  system ! PrintState\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Typed Actor with Stream: Build a typed actor that, upon receiving a 'StartStream' command, runs a stream that sums numbers and logs the result."
      },
      {
        "from": "assistant",
        "value": "// SumStreamTyped.scala\n// This example demonstrates a typed actor that starts an on-demand stream to sum numbers.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.stream.scaladsl.{Sink, Source}\nimport akka.stream.SystemMaterializer\nimport akka.{Done, NotUsed}\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration._\nimport scala.util.{Success, Failure}\n\nobject OnDemandStreamActor {\n  sealed trait Command\n  case object StartStream extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { context =>\n    // Obtain a Materializer from the typed system\n    implicit val mat = SystemMaterializer(context.system).materializer\n    Behaviors.receiveMessage {\n      case StartStream =>\n        context.log.info(\"Starting summation stream.\")\n        // Create a source of integers\n        val source: Source[Int, NotUsed] = Source(1 to 5)\n        // Create a sink that reduces (sums) the numbers\n        val sink: Sink[Int, Future[Int]] = Sink.reduce[Int](_ + _)\n        // Run the stream and obtain a Future with the result\n        val sumFuture: Future[Int] = source.runWith(sink)\n        sumFuture.onComplete {\n          case Success(sum) => context.log.info(s\"Summation result: $sum\")\n          case Failure(ex) => context.log.error(s\"Stream failed with: ${ex.getMessage}\")\n        }\n        Behaviors.same\n    }\n  }\n}\n\nobject SumStreamTypedApp extends App {\n  val system = ActorSystem(OnDemandStreamActor(), \"SumStreamSystem\")\n  system ! OnDemandStreamActor.StartStream\n  Thread.sleep(2000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Supervised Actor Example: Construct a typed actor that resumes on NumberFormatException but stops on other exceptions."
      },
      {
        "from": "assistant",
        "value": "// ResumableActor.scala\n// This example demonstrates a typed actor with a supervised strategy.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior, SupervisorStrategy}\n\nobject ResumableActor {\n  sealed trait Command\n  case class ParseNumber(input: String) extends Command\n\n  def apply(): Behavior[Command] = Behaviors.receive { (ctx, msg) =>\n    msg match {\n      case ParseNumber(input) =>\n        // This may throw a NumberFormatException if input is not numeric\n        val num = input.toInt\n        ctx.log.info(s\"Parsed number: $num\")\n        Behaviors.same\n    }\n  }\n}\n\nobject ResumableBehavior {\n  import ResumableActor._\n  def apply(): Behavior[Command] =\n    Behaviors.supervise(ResumableActor())\n      .onFailure[NumberFormatException](SupervisorStrategy.resume)\n      .onFailure[Exception](SupervisorStrategy.stop)\n}\n\nobject ResumeOnTypedExceptionExampleApp extends App {\n  val system = ActorSystem(ResumableBehavior(), \"ResumeTypedSystem\")\n  system ! ResumableActor.ParseNumber(\"123\")\n  system ! ResumableActor.ParseNumber(\"abc\") // Triggers NumberFormatException; actor resumes\n  system ! ResumableActor.ParseNumber(\"999\")\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Tagged Persistent Actor: Create a typed persistence actor that uses tagging for events."
      },
      {
        "from": "assistant",
        "value": "// TaggedPersistentActor.scala\n// This example shows a persistent actor that tags events so they can be filtered by projections.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.persistence.typed.PersistenceId\nimport akka.persistence.typed.scaladsl.{EventSourcedBehavior, Effect, RetentionCriteria}\n\nobject TaggedPersistentActor {\n  // Commands\n  sealed trait Command\n  case object Increment extends Command\n  case object PrintState extends Command\n\n  // Events\n  sealed trait Event\n  case object Incremented extends Event\n\n  // State\n  final case class State(count: Int)\n\n  // Define a tag set for this entity\n  val MyTag = Set(\"counter-tag\")\n\n  def apply(entityId: String): Behavior[Command] = EventSourcedBehavior[\n    Command,\n    Event,\n    State\n  ](\n    persistenceId = PersistenceId.ofUniqueId(entityId),\n    emptyState = State(0),\n    commandHandler = (state, cmd) => cmd match {\n      case Increment => Effect.persist(Incremented)\n      case PrintState =>\n        println(s\"TaggedPersistentActor state = ${state.count}\")\n        Effect.none\n    },\n    eventHandler = (state, evt) => evt match {\n      case Incremented => state.copy(count = state.count + 1)\n    }\n  ).withTagger { event =>\n    event match {\n      case Incremented => MyTag\n    }\n  }\n}\n\nobject TaggedPersistentActorApp extends App {\n  val system = ActorSystem(TaggedPersistentActor(\"tag-entity\"), \"TaggedPersistenceSystem\")\n  system ! TaggedPersistentActor.Increment\n  system ! TaggedPersistentActor.Increment\n  system ! TaggedPersistentActor.PrintState\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Partitioned Cluster Sharding: Construct a typed actor using cluster sharding that partitions entities by the numeric mod of their IDs."
      },
      {
        "from": "assistant",
        "value": "// TypedClusterShardingModExample.scala\n// This example initializes cluster sharding for entities of type ModEntity, partitioned by the numeric mod of their ID.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.cluster.sharding.typed.scaladsl.{ClusterSharding, Entity, EntityTypeKey}\n\nobject ModEntity {\n  // Define the commands for the entity\n  sealed trait Command { def entityId: String }\n  case class Process(entityId: String, payload: String) extends Command\n\n  // Simple behavior that logs the received message\n  def apply(entityId: String): Behavior[Command] = Behaviors.receive { (ctx, command) =>\n    command match {\n      case Process(_, payload) =>\n        ctx.log.info(s\"ModEntity [$entityId] processing: $payload\")\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedClusterShardingModExampleApp extends App {\n  import ModEntity._\n  val TypeKey: EntityTypeKey[Command] = EntityTypeKey[Command](\"ModEntity\")\n\n  // Create a typed ActorSystem\n  val system = ActorSystem(Behaviors.empty, \"ModShardCluster\")\n  val sharding = ClusterSharding(system)\n\n  // Initialize the shard region\n  sharding.init(\n    Entity(TypeKey)(createBehavior = entityContext => ModEntity(entityContext.entityId))\n  )\n\n  // In a real cluster, messages would be sent via the shard region\n  Thread.sleep(5000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "GroupBy Streams Example: Demonstrate an Akka Streams GraphDSL that groups elements in groups of 2 and prints them."
      },
      {
        "from": "assistant",
        "value": "// GroupByStreamExample.scala\n// This example groups a stream of key-value pairs by the key and then merges the substreams to print all elements.\n\nimport akka.actor.ActorSystem\nimport akka.stream.ActorMaterializer\nimport akka.stream.scaladsl.{Sink, Source}\nimport scala.concurrent.ExecutionContextExecutor\n\nobject GroupByStreamExample extends App {\n  implicit val system: ActorSystem = ActorSystem(\"GroupBySystem\")\n  implicit val ec: ExecutionContextExecutor = system.dispatcher\n  implicit val mat: ActorMaterializer = ActorMaterializer()(system)\n\n  // Define a source of tuples\n  val source = Source(List((1, \"apple\"), (2, \"banana\"), (1, \"cherry\"), (2, \"date\")))\n\n  // Group the source by key, then merge substreams and print each element\n  val done = source.groupBy(2, _._1)\n    .mergeSubstreams\n    .runForeach { case (key, value) =>\n      println(s\"Group #$key => $value\")\n    }\n\n  done.onComplete(_ => system.terminate())\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Typed Cluster Membership Watcher: Build a typed cluster membership watcher that logs join and removal events using MemberEvent."
      },
      {
        "from": "assistant",
        "value": "// TypedClusterMembershipWatcher.scala\n// This example subscribes to cluster membership events and logs when members join or leave.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.cluster.typed.{Cluster, Subscribe}\nimport akka.cluster.typed.ClusterEvent.{MemberEvent, MemberUp, MemberRemoved}\n\nobject MembershipWatcher {\n  sealed trait Command\n  private final case class WrappedMemberEvent(event: MemberEvent) extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { ctx =>\n    // Create an adapter to wrap MemberEvent messages\n    val adapter = ctx.messageAdapter[MemberEvent](WrappedMemberEvent(_))\n    // Subscribe to all membership events\n    Cluster(ctx.system).subscriptions ! Subscribe(adapter, classOf[MemberEvent])\n\n    Behaviors.receiveMessage {\n      case WrappedMemberEvent(MemberUp(member)) =>\n        ctx.log.info(s\"Member is up: ${member.address}\")\n        Behaviors.same\n      case WrappedMemberEvent(MemberRemoved(member, previousStatus)) =>\n        ctx.log.info(s\"Member removed: ${member.address} (was $previousStatus)\")\n        Behaviors.same\n      case WrappedMemberEvent(other) =>\n        ctx.log.info(s\"Other cluster event: $other\")\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedClusterMembershipExampleApp extends App {\n  val system = ActorSystem(MembershipWatcher(), \"ClusterMembershipSystem\")\n  Thread.sleep(10000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Stdin Stream Example: Construct a typed streams example reading lines from stdin with StreamConverters, logging them in the console."
      },
      {
        "from": "assistant",
        "value": "// StdinStreamTyped.scala\n// This example reads lines from standard input using a stream and prints each line.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.stream.scaladsl.{Framing, Sink, StreamConverters}\nimport akka.util.ByteString\nimport akka.stream.SystemMaterializer\nimport scala.concurrent.ExecutionContext\nimport akka.{Done, NotUsed}\nimport scala.concurrent.Future\n\nobject StdinStreamApp extends App {\n  // Create a simple root behavior that sets up the stream\n  val root: Behavior[Nothing] = Behaviors.setup[Nothing] { context =>\n    implicit val mat = SystemMaterializer(context.system).materializer\n    implicit val ec: ExecutionContext = context.executionContext\n\n    // Create a source from System.in\n    val source: Source[String, NotUsed] = StreamConverters.fromInputStream(() => System.in)\n      .via(\n        Framing.delimiter(\n          ByteString(\"\\n\"),         // Use ByteString for the newline delimiter\n          maximumFrameLength = 256,\n          allowTruncation = true\n        )\n      )\n      .map(_.utf8String)             // Convert bytes to UTF-8 string\n\n    // Sink that prints each line\n    val sink: Sink[String, Future[Done]] = Sink.foreach(line => println(s\"You typed: $line\"))\n\n    // Run the stream\n    val done: Future[Done] = source.runWith(sink)\n    done.onComplete { _ =>\n      context.system.terminate()\n    }\n\n    Behaviors.empty\n  }\n\n  val system = ActorSystem(root, \"StdinStreamSystem\")\n}\n"
      }
    ]
  }
]
