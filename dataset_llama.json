[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Define a simple actor in Akka Typed using Scala that logs a greeting message when it receives a 'SayHello' message."
      },
      {
        "from": "assistant",
        "value": "```scala\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.actor.typed.scaladsl.Behaviors\n\n// Define the messages the actor can handle\nsealed trait Command\ncase object SayHello extends Command\n\n// Define the actor behavior\nval myActor: Behavior[Command] = Behaviors.receive { (context, message) =>\n  message match {\n    case SayHello =>\n      context.log.info(\"Hello, world!\")\n      Behaviors.same\n  }\n}\n\n// Create the actor system\nval system: ActorSystem[Command] = ActorSystem(myActor, \"MyActorSystem\")\n\n// Send a message to the actor\nsystem ! SayHello\n```"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an actor in Akka Typed that maintains an integer counter, increments it upon receiving an 'Increment' message, and logs the current count."
      },
      {
        "from": "assistant",
        "value": "```scala\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.actor.typed.scaladsl.Behaviors\n\n// Define the messages the actor can handle\nsealed trait Command\ncase object Increment extends Command\n\n// Define the actor behavior\nval counter: Behavior[Command] = Behaviors.setup { context =>\n  def updated(count: Int): Behavior[Command] = Behaviors.receiveMessage {\n    case Increment =>\n      val newCount = count + 1\n      context.log.info(s\"Current count: $newCount\")\n      updated(newCount)\n  }\n  updated(0) // Initialize with count 0\n}\n\n// Create the actor system\nval system: ActorSystem[Command] = ActorSystem(counter, \"CounterSystem\")\n\n// Send messages to the actor\nsystem ! Increment\nsystem ! Increment\n```"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Demonstrate how to create a parent actor that spawns a child actor in Akka Typed, and sends a message from the parent to the child."
      },
      {
        "from": "assistant",
        "value": "```scala\nimport akka.actor.typed.{ActorRef, ActorSystem, Behavior}\nimport akka.actor.typed.scaladsl.Behaviors\n\n// Messages for child actor\nsealed trait ChildCommand\ncase object Ping extends ChildCommand\n\n// Messages for parent actor\nsealed trait ParentCommand\ncase object StartChild extends ParentCommand\ncase object PingChild extends ParentCommand\n\n// Child actor behavior\nval childActor: Behavior[ChildCommand] = Behaviors.receive { (context, message) =>\n  message match {\n    case Ping =>\n      context.log.info(\"Child received Ping\")\n      Behaviors.same\n  }\n}\n\n// Parent actor behavior\nval parentActor: Behavior[ParentCommand] = Behaviors.setup { context =>\n  var child: Option[ActorRef[ChildCommand]] = None\n\n  Behaviors.receiveMessage {\n    case StartChild =>\n      val childRef = context.spawn(childActor, \"childActor\")\n      child = Some(childRef)\n      context.log.info(\"Started child actor\")\n      Behaviors.same\n\n    case PingChild =>\n      child.foreach(_ ! Ping)\n      Behaviors.same\n  }\n}\n\n// Create the actor system\nval system: ActorSystem[ParentCommand] = ActorSystem(parentActor, \"ParentChildSystem\")\n\n// Interact with the parent actor\nsystem ! StartChild\nsystem ! PingChild\n```"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement a finite state machine (FSM) in Akka Typed that models a simple traffic light with 'Red', 'Green', and 'Yellow' states, transitioning between them upon receiving a 'Change' message."
      },
      {
        "from": "assistant",
        "value": "```scala\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.actor.typed.scaladsl.Behaviors\n\n// Messages\nsealed trait LightCommand\ncase object Change extends LightCommand\n\n// Define the actor behavior\nval trafficLight: Behavior[LightCommand] = Behaviors.setup { context =>\n  def red: Behavior[LightCommand] = Behaviors.receiveMessage {\n    case Change =>\n      context.log.info(\"Changing to Green\")\n      green\n  }\n\n  def green: Behavior[LightCommand] = Behaviors.receiveMessage {\n    case Change =>\n      context.log.info(\"Changing to Yellow\")\n      yellow\n  }\n\n  def yellow: Behavior[LightCommand] = Behaviors.receiveMessage {\n    case Change =>\n      context.log.info(\"Changing to Red\")\n      red\n  }\n\n  red // Start with the light red\n}\n\n// Create the actor system\nval system: ActorSystem[LightCommand] = ActorSystem(trafficLight, \"TrafficLightSystem\")\n\n// Interact with the actor\nsystem ! Change // Red to Green\nsystem ! Change // Green to Yellow\nsystem ! Change // Yellow to Red\n```"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Show how to schedule a message to self in Akka Typed, where an actor sends itself a 'Tick' message every second."
      },
      {
        "from": "assistant",
        "value": "```scala\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.actor.typed.scaladsl.{Behaviors, TimerScheduler}\n\nimport scala.concurrent.duration._\n\nsealed trait TickCommand\ncase object Tick extends TickCommand\n\n// Define the actor behavior\ndef tickingActor(): Behavior[TickCommand] = Behaviors.withTimers { timers =>\n  timers.startTimerAtFixedRate(Tick, 1.second)\n\n  Behaviors.receive { (context, message) =>\n    message match {\n      case Tick =>\n        context.log.info(\"Tick\")\n        Behaviors.same\n    }\n  }\n}\n\n// Create the actor system\nval system: ActorSystem[TickCommand] = ActorSystem(tickingActor(), \"TickingActorSystem\")\n```"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Define an Akka actor that logs any message it receives."
      },
      {
        "from": "assistant",
        "value": "Here's how to create an Akka actor that logs messages:\n\nclass LoggingActor extends Actor {\n  def receive = {\n    case message =>\n      println(s\"Received: $message\")\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka HTTP route that serves a JSON response for a GET request to '/status'."
      },
      {
        "from": "assistant",
        "value": "Here's how to create an Akka HTTP route for the status endpoint:\n\nimport akka.http.scaladsl.server.Directives._\nimport akka.http.scaladsl.model.StatusCodes\n\nval route = path(\"status\") {\n  get {\n    complete((StatusCodes.OK, \"{\"status\": \"running\"}\"))\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Show how to create an actor system with a router that sends messages to multiple workers."
      },
      {
        "from": "assistant",
        "value": "Here's how to create an actor system with a router for multiple workers:\n\nimport akka.actor.{Actor, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\nclass WorkerActor extends Actor {\n  def receive = {\n    case message =>\n      println(s\"Worker received: $message\")\n  }\n}\n\nval system = ActorSystem(\"RouterSystem\")\nval router = system.actorOf(RoundRobinPool(5).props(Props[WorkerActor]), \"router\")\n\nfor (i <- 1 to 10) {\n  router ! s\"Task $i\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Write an example of a persistent actor in Akka that saves its state after each command."
      },
      {
        "from": "assistant",
        "value": "Here's an example of a persistent actor that maintains its state:\n\nimport akka.persistence.PersistentActor\n\ncase object Increment\ncase object GetCount\ncase object Incremented\n\nclass PersistentCounter extends PersistentActor {\n  var count = 0\n\n  override def persistenceId: String = \"counter-id\"\n\n  override def receiveCommand: Receive = {\n    case Increment =>\n      persist(Incremented) { event =>\n        updateState(event)\n        sender() ! count\n      }\n    case GetCount =>\n      sender() ! count\n  }\n\n  override def receiveRecover: Receive = {\n    case Incremented => updateState(Incremented)\n  }\n\n  private def updateState(event: Incremented.type): Unit = {\n    count += 1\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Explain how to stop an actor system in Akka."
      },
      {
        "from": "assistant",
        "value": "To stop an actor system in Akka, you can call the `terminate` method on the `ActorSystem` instance. Here's an example:\n\nval system = ActorSystem(\"ExampleSystem\")\n// Perform tasks with the actor system\n\n// When done, terminate the system\nsystem.terminate()\n\nThe `terminate` method initiates the shutdown process for the actor system and stops all actors within it."
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Demonstrate how to use Akka Streams to process a simple data flow."
      },
      {
        "from": "assistant",
        "value": "Here's how to create a simple data flow using Akka Streams:\n\nimport akka.actor.ActorSystem\nimport akka.stream.scaladsl.{Flow, Sink, Source}\nimport akka.stream.Materializer\nimport scala.concurrent.ExecutionContextExecutor\n\nimplicit val system: ActorSystem = ActorSystem(\"StreamSystem\")\nimplicit val materializer: Materializer = Materializer(system)\nimplicit val ec: ExecutionContextExecutor = system.dispatcher\n\nval source = Source(1 to 100)\nval flow = Flow[Int].map(_ * 2)\nval sink = Sink.foreach[Int](println)\n\nsource.via(flow).runWith(sink)"
      }
    ]
  }
]
