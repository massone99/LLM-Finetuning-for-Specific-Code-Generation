[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that can handle different types of messages, such as strings, integers, and custom case classes, performing different actions based on the message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define custom messages\ncase class Greet(name: String)\ncase class Calculate(a: Int, b: Int)\n\n// Define the MultiMessageActor\nclass MultiMessageActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"Received string message: $msg\")\n    case Greet(name) =>\n      println(s\"Hello, $name!\")\n    case Calculate(a, b) =>\n      println(s\"The sum of $a and $b is ${a + b}\")\n    case _ =>\n      println(\"Unknown message received.\")\n  }\n}\n\n// Usage Example\nobject MultiMessageApp extends App {\n  val system = ActorSystem(\"MultiMessageSystem\")\n  val multiActor = system.actorOf(Props[MultiMessageActor](), \"multiActor\")\n\n  multiActor ! \"A simple string\"\n  multiActor ! Greet(\"Alice\")\n  multiActor ! Calculate(5, 7)\n  multiActor ! 42 // This will trigger the unknown message case\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that maintains a counter. It should handle two messages: one to increment the counter and another to retrieve its current value."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Messages\ncase object Increment\ncase object GetCount\n\n// Define the CounterActor\nclass CounterActor extends Actor {\n  var count = 0\n\n  def receive: Receive = {\n    case Increment =>\n      count += 1\n    case GetCount =>\n      sender() ! count\n  }\n}\n\n// Usage Example\nobject CounterApp extends App {\n  val system = ActorSystem(\"CounterSystem\")\n  val counter = system.actorOf(Props[CounterActor](), \"counter\")\n\n  counter ! Increment\n  counter ! Increment\n  counter ! GetCount\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Supervisor Actor in Scala that supervises a child actor. The supervisor should restart the child in case of any failure"
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy, Terminated}\nimport akka.actor.SupervisorStrategy._\n\nimport scala.concurrent.duration._\n\n// Define the ChildActor\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case \"fail\" => throw new Exception(\"Child failed!\")\n    case msg    => println(s\"Child received: $msg\")\n  }\n}\n\n// Define the SupervisorActor\nclass SupervisorActor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(\n    maxNrOfRetries = 3,\n    withinTimeRange = 1.minute\n  ) {\n    case _: Exception => Restart\n  }\n\n  val child: ActorRef = context.actorOf(Props[ChildActor](), \"childActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example\nobject SupervisorApp extends App {\n  val system = ActorSystem(\"SupervisorSystem\")\n  val supervisor = system.actorOf(Props[SupervisorActor](), \"supervisor\")\n\n  supervisor ! \"Hello\"\n  supervisor ! \"fail\"\n  supervisor ! \"Are you there?\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Develop an Akka Router Actor in Scala that distributes incoming messages to a pool of worker actors using a round-robin strategy."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\n// Define the WorkerActor\nclass WorkerActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"${self.path.name} processed message: $msg\")\n  }\n}\n\n// Usage Example\nobject RouterApp extends App {\n  val system = ActorSystem(\"RouterSystem\")\n  \n  // Create a router with 5 worker actors\n  val router: ActorRef = system.actorOf(\n    RoundRobinPool(5).props(Props[WorkerActor]()),\n    \"workerRouter\"\n  )\n\n  // Send messages to the router\n  for (i <- 1 to 10) {\n    router ! s\"Message $i\"\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that communicates with multiple other actors, sending messages and aggregating responses."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define worker actors\nclass Worker(id: Int) extends Actor {\n  def receive: Receive = {\n    case \"work\" =>\n      sender() ! s\"Worker $id completed work.\"\n  }\n}\n\n// Define the ManagerActor\nclass Manager(numWorkers: Int) extends Actor {\n  // Create worker actors\n  val workers: IndexedSeq[ActorRef] = for (i <- 1 to numWorkers) yield {\n    context.actorOf(Props(new Worker(i)), s\"worker$i\")\n  }\n\n  def receive: Receive = {\n    case \"start\" =>\n      workers.foreach(_ ! \"work\")\n    case msg =>\n      println(s\"Manager received: $msg\")\n  }\n}\n\n// Usage Example\nobject ManagerApp extends App {\n  val system = ActorSystem(\"ManagerSystem\")\n  val manager = system.actorOf(Props(new Manager(3)), \"manager\")\n\n  manager ! \"start\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that changes its behavior based on the messages it receives using context.become"
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the ToggleActor\nclass ToggleActor extends Actor {\n  def active: Receive = {\n    case \"toggle\" =>\n      println(\"Switching to inactive state.\")\n      context.become(inactive)\n    case msg =>\n      println(s\"Active state received: $msg\")\n  }\n\n  def inactive: Receive = {\n    case \"toggle\" =>\n      println(\"Switching to active state.\")\n      context.become(active)\n    case msg =>\n      println(s\"Inactive state received: $msg\")\n  }\n\n  def receive: Receive = active\n}\n\n// Usage Example\nobject ToggleApp extends App {\n  val system = ActorSystem(\"ToggleSystem\")\n  val toggleActor = system.actorOf(Props[ToggleActor](), \"toggleActor\")\n\n  toggleActor ! \"Hello\"\n  toggleActor ! \"toggle\"\n  toggleActor ! \"World\"\n  toggleActor ! \"toggle\"\n  toggleActor ! \"Back to active\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that uses the ask pattern to send a message and wait for a response asynchronously."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\n\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      sender() ! s\"Received your message: $msg\"\n  }\n}\n\n// Usage Example\nobject AskPatternApp extends App {\n  val system = ActorSystem(\"AskPatternSystem\")\n  val responder = system.actorOf(Props[ResponderActor](), \"responder\")\n\n  implicit val timeout: Timeout = Timeout(5.seconds)\n  val future = responder ? \"Hello via ask pattern\"\n\n  val result = Await.result(future, timeout.duration).asInstanceOf[String]\n  println(result)\n\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named DynamicParentActor that can dynamically create child actors upon receiving a CreateChild(name: String) message. Each child actor should be named according to the provided name and simply print any message it receives. Demonstrate creating multiple children and sending messages to them through the parent."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class CreateChild(name: String)\ncase class SendMessageToChild(childName: String, message: String)\n\n// Define the ChildActor\nclass ChildActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ChildActor [$name] received message: $msg\")\n  }\n}\n\n// Define the DynamicParentActor\nclass DynamicParentActor extends Actor {\n  var children: Map[String, ActorRef] = Map.empty\n\n  def receive: Receive = {\n    case CreateChild(name) =>\n      if (!children.contains(name)) {\n        val child = context.actorOf(Props(new ChildActor(name)), name)\n        children += (name -> child)\n        println(s\"ParentActor created child actor with name: $name\")\n      } else {\n        println(s\"Child actor with name '$name' already exists.\")\n      }\n\n    case SendMessageToChild(childName, message) =>\n      children.get(childName) match {\n        case Some(child) =>\n          child ! message\n        case None =>\n          println(s\"No child actor found with name: $childName\")\n      }\n\n    case msg =>\n      println(s\"ParentActor received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DynamicParentApp extends App {\n  val system = ActorSystem(\"DynamicParentSystem\")\n  val parent = system.actorOf(Props[DynamicParentActor](), \"parentActor\")\n\n  // Create child actors\n  parent ! CreateChild(\"child1\")\n  parent ! CreateChild(\"child2\")\n  parent ! CreateChild(\"child1\") // Attempt to create an existing child\n\n  // Send messages to child actors\n  parent ! SendMessageToChild(\"child1\", \"Hello Child 1!\")\n  parent ! SendMessageToChild(\"child2\", \"Hello Child 2!\")\n  parent ! SendMessageToChild(\"child3\", \"Hello Child 3!\") // Non-existent child\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named BufferedActor that buffers incoming messages and processes them at a controlled rate of one message every 500 milliseconds. Implement buffering such that incoming messages are stored in a queue if the actor is busy processing. Demonstrate sending multiple messages rapidly and observing the controlled processing rate."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.Queue\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext\n\n// Define the BufferedActor\nclass BufferedActor extends Actor {\n  import context.dispatcher\n\n  // Internal message queue\n  val messageQueue: Queue[String] = Queue.empty\n\n  // Processing state\n  var isProcessing: Boolean = false\n  var timer: Option[Cancellable] = None\n\n  def receive: Receive = {\n    case msg: String =>\n      messageQueue.enqueue(msg)\n      processNext()\n\n    case \"process\" =>\n      if (messageQueue.nonEmpty) {\n        val msg = messageQueue.dequeue()\n        println(s\"BufferedActor processing message: $msg\")\n        // Simulate processing delay\n        timer = Some(context.system.scheduler.scheduleOnce(500.milliseconds, self, \"process\"))\n      } else {\n        isProcessing = false\n      }\n  }\n\n  def processNext(): Unit = {\n    if (!isProcessing && messageQueue.nonEmpty) {\n      isProcessing = true\n      self ! \"process\"\n    }\n  }\n\n  override def postStop(): Unit = {\n    timer.foreach(_.cancel())\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BufferedActorApp extends App {\n  val system = ActorSystem(\"BufferedActorSystem\")\n  val bufferedActor = system.actorOf(Props[BufferedActor](), \"bufferedActor\")\n\n  // Send multiple messages rapidly\n  for (i <- 1 to 5) {\n    bufferedActor ! s\"Message $i\"\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(4000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SelfTerminator that monitors the number of messages it has processed. After processing 10 messages, it should gracefully stop itself by sending a \"shutdown\" message to itself. Demonstrate the actor processing messages and terminating after the threshold is reached."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the SelfTerminator Actor\nclass SelfTerminator extends Actor {\n  var messageCount: Int = 0\n\n  def receive: Receive = {\n    case msg: String =>\n      messageCount += 1\n      println(s\"SelfTerminator processed message: $msg (Count: $messageCount)\")\n      if (messageCount >= 10) {\n        println(\"SelfTerminator reached message limit. Shutting down.\")\n        self ! \"shutdown\"\n      }\n    case \"shutdown\" =>\n      println(\"SelfTerminator is shutting itself down.\")\n      context.stop(self)\n    case _ =>\n      println(\"SelfTerminator received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelfTerminatorApp extends App {\n  val system = ActorSystem(\"SelfTerminatorSystem\")\n  val terminator = system.actorOf(Props[SelfTerminator](), \"terminatorActor\")\n\n  // Send 12 messages to demonstrate termination after 10\n  for (i <- 1 to 12) {\n    terminator ! s\"Message $i\"\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named PriorityHandlerActor that handles high-priority and low-priority messages differently. Without using a custom mailbox, implement the actor such that it always processes high-priority messages (\"HighPriority\") before any pending low-priority messages (\"LowPriority\"), regardless of the order they were received."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Define the PriorityHandlerActor\nclass PriorityHandlerActor extends Actor with Stash {\n  def receive: Receive = {\n    case \"HighPriority\" =>\n      println(\"Processing High Priority message.\")\n      unstashAll()\n      context.become(normal)\n    case \"LowPriority\" =>\n      println(\"Stashing Low Priority message.\")\n      stash()\n    case msg =>\n      println(s\"Received unknown message: $msg\")\n  }\n\n  def normal: Receive = {\n    case \"HighPriority\" =>\n      println(\"Processing High Priority message.\")\n    case \"LowPriority\" =>\n      println(\"Processing Low Priority message.\")\n    case msg =>\n      println(s\"Received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PriorityHandlerApp extends App {\n  val system = ActorSystem(\"PriorityHandlerSystem\")\n  val priorityHandler = system.actorOf(Props[PriorityHandlerActor](), \"priorityHandler\")\n\n  // Send messages in mixed order\n  priorityHandler ! \"LowPriority\"   // Should be stashed\n  priorityHandler ! \"LowPriority\"   // Should be stashed\n  priorityHandler ! \"HighPriority\"  // Should process immediately and unstash\n  priorityHandler ! \"HighPriority\"  // Should process immediately\n  priorityHandler ! \"LowPriority\"   // Should process now\n  priorityHandler ! \"LowPriority\"   // Should process now\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named ForwardingActor that forwards any received message to another actor named DestinationActor using the forward method. Ensure that the original sender is preserved when forwarding messages. Demonstrate the forwarding behavior by sending messages through the ForwardingActor and verifying that DestinationActor receives them with the correct sender reference."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the DestinationActor\nclass DestinationActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"DestinationActor received message: $msg from ${sender().path.name}\")\n  }\n}\n\n// Define the ForwardingActor\nclass ForwardingActor(destination: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ForwardingActor forwarding message: $msg\")\n      destination.forward(msg) // Preserves the original sender\n  }\n}\n\n// Define a Simple Sender Actor for demonstration\nclass SenderActor(forwarding: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"SenderActor sending message: $msg\")\n      forwarding ! msg\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ForwardingApp extends App {\n  val system = ActorSystem(\"ForwardingSystem\")\n  \n  val destination = system.actorOf(Props[DestinationActor](), \"destinationActor\")\n  val forwarding = system.actorOf(Props(new ForwardingActor(destination)), \"forwardingActor\")\n  val senderActor = system.actorOf(Props(new SenderActor(forwarding)), \"senderActor\")\n  \n  // Send messages through the SenderActor\n  senderActor ! \"Hello via Forwarding!\"\n  senderActor ! \"Another forwarded message.\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TerminatorActor that performs a simple task upon receiving any message. Demonstrate the use of Akka's PoisonPill to forcefully terminate the actor after it processes a few messages. Verify that the actor stops receiving messages post-termination."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, PoisonPill}\n\n// Define the TerminatorActor\nclass TerminatorActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"TerminatorActor received message: $msg\")\n    case _ =>\n      println(\"TerminatorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TerminatorApp extends App {\n  val system = ActorSystem(\"TerminatorSystem\")\n  val terminator = system.actorOf(Props[TerminatorActor](), \"terminatorActor\")\n\n  // Send messages to the actor\n  terminator ! \"Message 1\"\n  terminator ! \"Message 2\"\n  terminator ! \"Message 3\"\n\n  // Send PoisonPill to terminate the actor\n  terminator ! PoisonPill\n\n  // Attempt to send more messages after termination\n  terminator ! \"Message after PoisonPill\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named BatchingActor that collects incoming integer messages and processes them in batches of three. Upon receiving the third message, it should calculate and print the sum of the batch and then reset to collect the next batch. Demonstrate the batching behavior by sending multiple messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the BatchingActor\nclass BatchingActor extends Actor {\n  var buffer: List[Int] = List.empty\n\n  def receive: Receive = {\n    case num: Int =>\n      buffer = num :: buffer\n      println(s\"BatchingActor received: $num (Buffer size: ${buffer.size})\")\n      if (buffer.size >= 3) {\n        val sum = buffer.sum\n        println(s\"BatchingActor processing batch: ${buffer.reverse} with sum: $sum\")\n        buffer = List.empty\n      }\n    case _ =>\n      println(\"BatchingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BatchingActorApp extends App {\n  val system = ActorSystem(\"BatchingActorSystem\")\n  val batchingActor = system.actorOf(Props[BatchingActor](), \"batchingActor\")\n\n  // Send multiple integer messages\n  batchingActor ! 5\n  batchingActor ! 10\n  batchingActor ! 15  // This should trigger batch processing\n  batchingActor ! 20\n  batchingActor ! 25\n  batchingActor ! 30  // Another batch processing\n  batchingActor ! 35  // Partial batch\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Supervisor Actor in Scala named ResumeSupervisor that supervises a child actor named ResumeChildActor. The child actor should throw a RuntimeException when it receives a \"runtime\" message and an IllegalArgumentException when it receives an \"illegal\" message. Configure the supervisor's strategy to resume the child actor on RuntimeException and stop it on IllegalArgumentException. Demonstrate the different outcomes by sending both types of messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy._\nimport scala.concurrent.duration._\n\n// Define the ResumeChildActor\nclass ResumeChildActor extends Actor {\n  def receive: Receive = {\n    case \"runtime\" =>\n      println(s\"${self.path.name} received 'runtime' and will throw RuntimeException.\")\n      throw new RuntimeException(\"Simulated RuntimeException.\")\n    case \"illegal\" =>\n      println(s\"${self.path.name} received 'illegal' and will throw IllegalArgumentException.\")\n      throw new IllegalArgumentException(\"Simulated IllegalArgumentException.\")\n    case msg =>\n      println(s\"${self.path.name} received message: $msg\")\n  }\n}\n\n// Define the ResumeSupervisor Actor\nclass ResumeSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy() {\n    case _: RuntimeException =>\n      println(\"ResumeSupervisor: Resuming child actor after RuntimeException.\")\n      Resume\n    case _: IllegalArgumentException =>\n      println(\"ResumeSupervisor: Stopping child actor after IllegalArgumentException.\")\n      Stop\n    case _: Exception =>\n      println(\"ResumeSupervisor: Escalating unknown exception.\")\n      Escalate\n  }\n\n  // Create the child actor\n  val child: ActorRef = context.actorOf(Props[ResumeChildActor](), \"resumeChildActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ResumeSupervisorApp extends App {\n  val system = ActorSystem(\"ResumeSupervisorSystem\")\n  val supervisor = system.actorOf(Props[ResumeSupervisor](), \"resumeSupervisor\")\n\n  // Send a message that causes RuntimeException (should resume)\n  supervisor ! \"runtime\"\n  supervisor ! \"Post-runtime message\"\n\n  // Send a message that causes IllegalArgumentException (should stop)\n  supervisor ! \"illegal\"\n  supervisor ! \"Post-illegal message\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor system in Scala with three actors: InitiatorActor, ResponderActor, and LoggerActor. The InitiatorActor sends a Request message to the ResponderActor. Upon receiving a Request, the ResponderActor replies with a Response message. The InitiatorActor then forwards this Response to the LoggerActor for logging. Demonstrate the message flow between these actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase object Request\ncase class Response(content: String)\ncase class LogMessage(message: String)\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Request =>\n      println(s\"${self.path.name} received Request.\")\n      sender() ! Response(\"Here is your response!\")\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the LoggerActor\nclass LoggerActor extends Actor {\n  def receive: Receive = {\n    case LogMessage(msg) =>\n      println(s\"LoggerActor logging message: $msg\")\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the InitiatorActor\nclass InitiatorActor(responder: ActorRef, logger: ActorRef) extends Actor {\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"${self.path.name} sending Request to ResponderActor.\")\n      responder ! Request\n    case Response(content) =>\n      println(s\"${self.path.name} received Response: $content\")\n      logger ! LogMessage(content)\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject MultipleActorsApp extends App {\n  val system = ActorSystem(\"MultipleActorsSystem\")\n\n  val logger = system.actorOf(Props[LoggerActor](), \"loggerActor\")\n  val responder = system.actorOf(Props[ResponderActor](), \"responderActor\")\n  val initiator = system.actorOf(Props(new InitiatorActor(responder, logger)), \"initiatorActor\")\n\n  // Start the message flow\n  initiator ! \"start\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named MultiTypeActor that handles three different message types: TextMessage(content: String), NumberMessage(value: Int), and Shutdown. For TextMessage, it should print the content. For NumberMessage, it should calculate and print the square of the value. Upon receiving Shutdown, it should gracefully stop itself. Demonstrate handling each message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define messages\ncase class TextMessage(content: String)\ncase class NumberMessage(value: Int)\ncase object Shutdown\n\n// Define the MultiTypeActor\nclass MultiTypeActor extends Actor {\n  def receive: Receive = {\n    case TextMessage(content) =>\n      println(s\"MultiTypeActor received TextMessage: $content\")\n    case NumberMessage(value) =>\n      val square = value * value\n      println(s\"MultiTypeActor received NumberMessage: $value, square: $square\")\n    case Shutdown =>\n      println(\"MultiTypeActor received Shutdown. Stopping...\")\n      context.stop(self)\n    case _ =>\n      println(\"MultiTypeActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject MultiTypeActorApp extends App {\n  val system = ActorSystem(\"MultiTypeActorSystem\")\n  val multiTypeActor = system.actorOf(Props[MultiTypeActor](), \"multiTypeActor\")\n\n  // Send different types of messages\n  multiTypeActor ! TextMessage(\"Hello, Akka!\")\n  multiTypeActor ! NumberMessage(7)\n  multiTypeActor ! \"Unknown Message\" // Should trigger unknown message handler\n  multiTypeActor ! Shutdown\n  multiTypeActor ! TextMessage(\"This should not be processed.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CalculatorActor that performs basic arithmetic operations. It should handle messages in the form of Calculate(operation: String, a: Int, b: Int), where operation can be \"add\", \"subtract\", \"multiply\", or \"divide\". The actor should perform the requested operation on the integers a and b and reply with the result. Handle division by zero by replying with an error message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\n\n// Define the Calculate message\ncase class Calculate(operation: String, a: Int, b: Int)\n\n// Define the CalculatorActor\nclass CalculatorActor extends Actor {\n  def receive: Receive = {\n    case Calculate(op, a, b) =>\n      val result = op.toLowerCase match {\n        case \"add\"      => a + b\n        case \"subtract\" => a - b\n        case \"multiply\" => a * b\n        case \"divide\" =>\n          if (b != 0) a.toDouble / b else \"Error: Division by zero\"\n        case _ => \"Error: Unknown operation\"\n      }\n      sender() ! result\n    case _ =>\n      sender() ! \"Error: Unknown message type.\"\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CalculatorActorApp extends App {\n  val system = ActorSystem(\"CalculatorSystem\")\n  val calculator = system.actorOf(Props[CalculatorActor](), \"calculatorActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to perform calculation and print result\n  def performCalculation(op: String, a: Int, b: Int): Unit = {\n    val future = calculator ? Calculate(op, a, b)\n    val result = Await.result(future, timeout.duration)\n    println(s\"Calculate($op, $a, $b) = $result\")\n  }\n\n  // Perform various calculations\n  performCalculation(\"add\", 10, 5)        // 15\n  performCalculation(\"subtract\", 10, 5)   // 5\n  performCalculation(\"multiply\", 10, 5)   // 50\n  performCalculation(\"divide\", 10, 5)     // 2.0\n  performCalculation(\"divide\", 10, 0)     // Error: Division by zero\n  performCalculation(\"modulo\", 10, 5)     // Error: Unknown operation\n\n  // Shutdown the system\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named BroadcasterActor that maintains a list of subscriber actors. It should handle Subscribe(subscriber: ActorRef) and Broadcast(message: String) messages. Upon receiving a Subscribe message, it should add the actor to its subscriber list. When a Broadcast message is received, it should send the message to all subscribed actors. Demonstrate subscribing multiple actors and broadcasting messages to them."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(subscriber: ActorRef)\ncase class Broadcast(message: String)\n\n// Define the BroadcasterActor\nclass BroadcasterActor extends Actor {\n  var subscribers: Set[ActorRef] = Set.empty\n\n  def receive: Receive = {\n    case Subscribe(subscriber) =>\n      subscribers += subscriber\n      println(s\"BroadcasterActor added subscriber: ${subscriber.path.name}\")\n    case Broadcast(msg) =>\n      println(s\"BroadcasterActor broadcasting message: $msg to ${subscribers.size} subscribers.\")\n      subscribers.foreach(_ ! msg)\n    case _ =>\n      println(\"BroadcasterActor received unknown message.\")\n  }\n}\n\n// Define a Subscriber Actor\nclass SubscriberActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"Subscriber [$name] received broadcast message: $msg\")\n    case _ =>\n      println(s\"Subscriber [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BroadcasterApp extends App {\n  val system = ActorSystem(\"BroadcasterSystem\")\n  val broadcaster = system.actorOf(Props[BroadcasterActor](), \"broadcasterActor\")\n\n  // Create subscriber actors\n  val subscriber1 = system.actorOf(Props(new SubscriberActor(\"Alice\")), \"subscriber1\")\n  val subscriber2 = system.actorOf(Props(new SubscriberActor(\"Bob\")), \"subscriber2\")\n  val subscriber3 = system.actorOf(Props(new SubscriberActor(\"Charlie\")), \"subscriber3\")\n\n  // Subscribers subscribe to the broadcaster\n  broadcaster ! Subscribe(subscriber1)\n  broadcaster ! Subscribe(subscriber2)\n  broadcaster ! Subscribe(subscriber3)\n\n  // Broadcast messages\n  broadcaster ! Broadcast(\"Welcome to the broadcast system!\")\n  broadcaster ! Broadcast(\"This is the second broadcast message.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SelectorActor that uses actor selection to send a message to another actor named TargetActor located at a specific path within the same actor system. Demonstrate selecting the TargetActor and sending a \"Hello Target!\" message using actor selection."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the TargetActor\nclass TargetActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"TargetActor received message: $msg from ${sender().path.name}\")\n    case _ =>\n      println(\"TargetActor received unknown message.\")\n  }\n}\n\n// Define the SelectorActor\nclass SelectorActor extends Actor {\n  def receive: Receive = {\n    case \"sendHello\" =>\n      // Actor selection path\n      val targetPath = \"/user/targetActor\"\n      val target = context.actorSelection(targetPath)\n      println(s\"SelectorActor sending 'Hello Target!' to $targetPath\")\n      target ! \"Hello Target!\"\n    case _ =>\n      println(\"SelectorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelectorApp extends App {\n  val system = ActorSystem(\"SelectorSystem\")\n  \n  // Create TargetActor\n  val target = system.actorOf(Props[TargetActor](), \"targetActor\")\n  \n  // Create SelectorActor\n  val selector = system.actorOf(Props[SelectorActor](), \"selectorActor\")\n  \n  // Send a message to SelectorActor to send message to TargetActor\n  selector ! \"sendHello\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AcknowledgingActor that acknowledges each received message by replying with \"Ack\". Implement a sender actor named RequesterActor that sends multiple messages to AcknowledgingActor and waits for acknowledgments before sending the next message. Demonstrate the acknowledgment mechanism."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define the AcknowledgingActor\nclass AcknowledgingActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"AcknowledgingActor received message: $msg from ${sender().path.name}\")\n      sender() ! \"Ack\"\n  }\n}\n\n// Define the RequesterActor\nclass RequesterActor(ackActor: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(3.seconds)\n\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"RequesterActor sending message: $msg\")\n      val future = ackActor ? msg\n      future.map {\n        case \"Ack\" =>\n          println(s\"RequesterActor received Ack for message: $msg\")\n          // Optionally, send next message or perform other actions\n      }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject AcknowledgmentApp extends App {\n  val system = ActorSystem(\"AcknowledgmentSystem\")\n  \n  val acknowledgingActor = system.actorOf(Props[AcknowledgingActor](), \"acknowledgingActor\")\n  val requesterActor = system.actorOf(Props(new RequesterActor(acknowledgingActor)), \"requesterActor\")\n  \n  // Send multiple messages\n  requesterActor ! \"Message 1\"\n  requesterActor ! \"Message 2\"\n  requesterActor ! \"Message 3\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named TransformerActor that receives messages containing integers, multiplies each integer by 2, and forwards the transformed message to another actor named ReceiverActor. Demonstrate the transformation and forwarding behavior by sending integer messages to the TransformerActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the TransformerActor\nclass TransformerActor(receiver: ActorRef) extends Actor {\n  def receive: Receive = {\n    case num: Int =>\n      val transformed = num * 2\n      println(s\"TransformerActor received: $num, transformed to: $transformed\")\n      receiver ! transformed\n    case _ =>\n      println(\"TransformerActor received unknown message.\")\n  }\n}\n\n// Define the ReceiverActor\nclass ReceiverActor extends Actor {\n  def receive: Receive = {\n    case msg: Int =>\n      println(s\"ReceiverActor received transformed message: $msg\")\n    case _ =>\n      println(\"ReceiverActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TransformerApp extends App {\n  val system = ActorSystem(\"TransformerSystem\")\n  \n  val receiver = system.actorOf(Props[ReceiverActor](), \"receiverActor\")\n  val transformer = system.actorOf(Props(new TransformerActor(receiver)), \"transformerActor\")\n  \n  // Send integer messages to TransformerActor\n  transformer ! 5\n  transformer ! 10\n  transformer ! 15\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named ResponderWithTimeout that replies to any Ping message with a Pong after a delay of 2 seconds. Implement a RequesterWithTimeout actor that sends a Ping message to ResponderWithTimeout and waits for a Pong reply with a timeout of 1 second. Handle the timeout scenario by printing \"Request timed out\" if no reply is received in time."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define messages\ncase object Ping\ncase object Pong\n\n// Define the ResponderWithTimeout Actor\nclass ResponderWithTimeout extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case Ping =>\n      println(s\"${self.path.name} received Ping. Will respond with Pong after delay.\")\n      context.system.scheduler.scheduleOnce(2.seconds, sender(), Pong)\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the RequesterWithTimeout Actor\nclass RequesterWithTimeout(responder: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(1.second)\n\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"${self.path.name} sending Ping to ${responder.path.name}\")\n      val future = responder ? Ping\n      future.onComplete {\n        case Success(Pong) =>\n          println(s\"${self.path.name} received Pong.\")\n        case Failure(_) =>\n          println(s\"${self.path.name} Request timed out.\")\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TimeoutApp extends App {\n  val system = ActorSystem(\"TimeoutSystem\")\n  \n  val responder = system.actorOf(Props[ResponderWithTimeout](), \"responderWithTimeout\")\n  val requester = system.actorOf(Props(new RequesterWithTimeout(responder)), \"requesterWithTimeout\")\n  \n  // Start the request\n  requester ! \"start\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(3000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named FileReaderActor that reads the contents of a specified text file upon receiving a ReadFile(path: String) message. After reading the file, it should send the file contents back to the sender wrapped in a FileContents(contents: String) message. Demonstrate reading a sample file and handling the response."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.io.Source\nimport scala.util.{Try, Success, Failure}\n\n// Define messages\ncase class ReadFile(path: String)\ncase class FileContents(contents: String)\ncase class FileReadError(error: String)\n\n// Define the FileReaderActor\nclass FileReaderActor extends Actor {\n  def receive: Receive = {\n    case ReadFile(path) =>\n      println(s\"${self.path.name} received request to read file: $path\")\n      val senderRef = sender()\n      val fileContentTry: Try[String] = Try {\n        Source.fromFile(path).mkString\n      }\n      fileContentTry match {\n        case Success(contents) =>\n          senderRef ! FileContents(contents)\n        case Failure(exception) =>\n          senderRef ! FileReadError(exception.getMessage)\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject FileReaderApp extends App {\n  val system = ActorSystem(\"FileReaderSystem\")\n  val fileReader = system.actorOf(Props(new FileReaderActor()), \"fileReaderActor\")\n\n  // Define a simple responder actor to handle responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case FileContents(contents) =>\n        println(s\"ResponderActor received file contents:\\n$contents\")\n      case FileReadError(error) =>\n        println(s\"ResponderActor encountered an error: $error\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Send a ReadFile message\n  fileReader.tell(ReadFile(\"sample.txt\"), responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named PeriodicReporterActor that sends a Report message to itself every 3 seconds. Upon receiving the Report message, it should print the current timestamp to the console. Demonstrate the periodic reporting behavior and ensure the actor stops reporting after five reports."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport java.time.LocalDateTime\n\n// Define the Report message\ncase object Report\n\n// Define the PeriodicReporterActor\nclass PeriodicReporterActor extends Actor {\n  import context.dispatcher\n\n  var reportCount: Int = 0\n  val maxReports: Int = 5\n\n  // Schedule periodic Report messages\n  val cancellable: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = 0.seconds,\n    delay = 3.seconds,\n    receiver = self,\n    message = Report\n  )\n\n  def receive: Receive = {\n    case Report =>\n      reportCount += 1\n      val timestamp = LocalDateTime.now()\n      println(s\"PeriodicReporterActor Report #$reportCount at $timestamp\")\n      if (reportCount >= maxReports) {\n        println(\"PeriodicReporterActor reached maximum reports. Stopping.\")\n        cancellable.cancel()\n        context.stop(self)\n      }\n    case _ =>\n      println(\"PeriodicReporterActor received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    cancellable.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PeriodicReporterApp extends App {\n  val system = ActorSystem(\"PeriodicReporterSystem\")\n  val reporter = system.actorOf(Props(new PeriodicReporterActor()), \"reporterActor\")\n\n  // Allow some time for reports before shutdown\n  Thread.sleep(16000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CacheActor that acts as an in-memory cache. It should handle Put(key: String, value: String) messages to store key-value pairs and Get(key: String) messages to retrieve values. Upon receiving a Get message, it should respond with ValueFound(key: String, value: String) if the key exists or ValueNotFound(key: String) if it doesn't. Demonstrate storing and retrieving values from the cache."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Put(key: String, value: String)\ncase class Get(key: String)\ncase class ValueFound(key: String, value: String)\ncase class ValueNotFound(key: String)\n\n// Define the CacheActor\nclass CacheActor extends Actor {\n  var cache: Map[String, String] = Map.empty\n\n  def receive: Receive = {\n    case Put(key, value) =>\n      cache += (key -> value)\n      println(s\"CacheActor stored: [$key -> $value]\")\n    case Get(key) =>\n      cache.get(key) match {\n        case Some(value) =>\n          sender() ! ValueFound(key, value)\n        case None =>\n          sender() ! ValueNotFound(key)\n      }\n    case _ =>\n      println(\"CacheActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CacheApp extends App {\n  val system = ActorSystem(\"CacheSystem\")\n  val cacheActor = system.actorOf(Props(new CacheActor()), \"cacheActor\")\n\n  // Define a simple responder actor to handle cache responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case ValueFound(key, value) =>\n        println(s\"ResponderActor: Found [$key -> $value] in cache.\")\n      case ValueNotFound(key) =>\n        println(s\"ResponderActor: No entry found for key '$key'.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Store some key-value pairs\n  cacheActor ! Put(\"name\", \"Alice\")\n  cacheActor ! Put(\"city\", \"Wonderland\")\n\n  // Retrieve existing and non-existing keys\n  cacheActor.tell(Get(\"name\"), responder)\n  cacheActor.tell(Get(\"country\"), responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named LoggingActor that logs incoming messages to a file. It should handle Log(message: String) messages by appending them to a specified log file. Ensure that the actor handles file I/O exceptions gracefully by logging errors to the console. Demonstrate logging multiple messages to a file."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport java.io.{File, FileWriter, BufferedWriter}\nimport scala.util.{Try, Success, Failure}\n\n// Define messages\ncase class Log(message: String)\n\n// Define the LoggingActor\nclass LoggingActor(logFilePath: String) extends Actor {\n  // Initialize the log file\n  val logFile: File = new File(logFilePath)\n  val bw: BufferedWriter = new BufferedWriter(new FileWriter(logFile, true)) // Append mode\n\n  override def postStop(): Unit = {\n    bw.close()\n    super.postStop()\n  }\n\n  def receive: Receive = {\n    case Log(msg) =>\n      Try {\n        bw.write(s\"${java.time.LocalDateTime.now()}: $msg\\n\")\n        bw.flush()\n      } match {\n        case Success(_) =>\n          println(s\"LoggingActor: Logged message to $logFilePath\")\n        case Failure(exception) =>\n          println(s\"LoggingActor encountered an error: ${exception.getMessage}\")\n      }\n    case _ =>\n      println(\"LoggingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LoggingApp extends App {\n  val system = ActorSystem(\"LoggingSystem\")\n  val loggingActor = system.actorOf(Props(new LoggingActor(\"application.log\")), \"loggingActor\")\n\n  // Define a simple logger to send Log messages\n  class Logger extends Actor {\n    def receive: Receive = {\n      case msg: String =>\n        loggingActor ! Log(msg)\n      case _ =>\n        println(\"Logger received unknown message.\")\n    }\n  }\n\n  val logger = system.actorOf(Props[Logger](), \"logger\")\n\n  // Send log messages\n  logger ! \"Application started.\"\n  logger ! \"Performing some operations.\"\n  logger ! \"Application finished successfully.\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named NotificationActor that sends notifications to users. It should handle Notify(user: String, message: String) messages by printing a personalized notification to the console. Implement a UserActor that represents a user and sends Notify messages to the NotificationActor. Demonstrate sending notifications to multiple users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Notify(user: String, message: String)\n\n// Define the NotificationActor\nclass NotificationActor extends Actor {\n  def receive: Receive = {\n    case Notify(user, message) =>\n      println(s\"Notification to $user: $message\")\n    case _ =>\n      println(\"NotificationActor received unknown message.\")\n  }\n}\n\n// Define the UserActor\nclass UserActor(name: String, notifier: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      notifier ! Notify(name, msg)\n    case _ =>\n      println(s\"UserActor [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject NotificationApp extends App {\n  val system = ActorSystem(\"NotificationSystem\")\n  val notificationActor = system.actorOf(Props(new NotificationActor()), \"notificationActor\")\n\n  // Create user actors\n  val user1 = system.actorOf(Props(new UserActor(\"Alice\", notificationActor)), \"userAlice\")\n  val user2 = system.actorOf(Props(new UserActor(\"Bob\", notificationActor)), \"userBob\")\n  val user3 = system.actorOf(Props(new UserActor(\"Charlie\", notificationActor)), \"userCharlie\")\n\n  // Send notifications\n  user1 ! \"Your order has been shipped.\"\n  user2 ! \"You have a new message.\"\n  user3 ! \"Your subscription is about to expire.\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named EventEmitterActor that emits events to subscribed listeners. It should handle Subscribe(listener: ActorRef) and EmitEvent(event: String) messages. Upon receiving EmitEvent, it should send the event to all subscribed listeners wrapped in an Event(event: String) message. Demonstrate subscribing multiple listeners and emitting events."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(listener: ActorRef)\ncase class EmitEvent(event: String)\ncase class Event(event: String)\n\n// Define the EventEmitterActor\nclass EventEmitterActor extends Actor {\n  var listeners: Set[ActorRef] = Set.empty\n\n  def receive: Receive = {\n    case Subscribe(listener) =>\n      listeners += listener\n      println(s\"EventEmitterActor: ${listener.path.name} subscribed.\")\n    case EmitEvent(event) =>\n      println(s\"EventEmitterActor: Emitting event: $event to ${listeners.size} listeners.\")\n      listeners.foreach(_ ! Event(event))\n    case _ =>\n      println(\"EventEmitterActor received unknown message.\")\n  }\n}\n\n// Define the ListenerActor\nclass ListenerActor(name: String) extends Actor {\n  def receive: Receive = {\n    case Event(event) =>\n      println(s\"Listener [$name] received event: $event\")\n    case _ =>\n      println(s\"Listener [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EventEmitterApp extends App {\n  val system = ActorSystem(\"EventEmitterSystem\")\n  val eventEmitter = system.actorOf(Props(new EventEmitterActor()), \"eventEmitterActor\")\n\n  // Create listener actors\n  val listener1 = system.actorOf(Props(new ListenerActor(\"Listener1\")), \"listener1\")\n  val listener2 = system.actorOf(Props(new ListenerActor(\"Listener2\")), \"listener2\")\n  val listener3 = system.actorOf(Props(new ListenerActor(\"Listener3\")), \"listener3\")\n\n  // Subscribe listeners\n  eventEmitter ! Subscribe(listener1)\n  eventEmitter ! Subscribe(listener2)\n  eventEmitter ! Subscribe(listener3)\n\n  // Emit events\n  eventEmitter ! EmitEvent(\"UserLoggedIn\")\n  eventEmitter ! EmitEvent(\"FileUploaded\")\n  eventEmitter ! EmitEvent(\"ErrorOccurred\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named RateLimiterActor that restricts the number of incoming Request messages to 3 per second using the token bucket algorithm. Each Request(id: Int) consumes a token. If tokens are available, process the request by printing \"Processed request <id>\"; otherwise, respond with \"Rate limit exceeded for request <id>\". Refill the bucket with 3 tokens every second. Demonstrate sending multiple requests rapidly and observing the rate limiter in action."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.collection.mutable.Queue\nimport akka.actor.Timers\n\n// Define messages\ncase class Request(id: Int)\ncase class Response(message: String)\n\n// Define the RateLimiterActor\nclass RateLimiterActor extends Actor {\n  import context.dispatcher\n\n  val maxTokens: Int = 3\n  var tokens: Int = maxTokens\n  val requestQueue: Queue[(ActorRef, Request)] = Queue.empty\n\n  // Schedule token refill every second\n  val refillInterval: FiniteDuration = 1.second\n  val refillTask: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = refillInterval,\n    delay = refillInterval,\n    receiver = self,\n    message = \"Refill\"\n  )\n\n  def receive: Receive = {\n    case \"Refill\" =>\n      tokens = maxTokens\n      println(s\"RateLimiterActor: Tokens refilled to $tokens\")\n      processQueue()\n\n    case req @ Request(id) =>\n      if (tokens > 0) {\n        tokens -= 1\n        println(s\"RateLimiterActor: Processed request $id (Tokens left: $tokens)\")\n        sender() ! Response(s\"Processed request $id\")\n      } else {\n        println(s\"RateLimiterActor: Rate limit exceeded for request $id. Queuing request.\")\n        requestQueue.enqueue((sender(), req))\n      }\n\n    case _ =>\n      println(\"RateLimiterActor received unknown message.\")\n  }\n\n  def processQueue(): Unit = {\n    while (tokens > 0 && requestQueue.nonEmpty) {\n      val (senderRef, Request(id)) = requestQueue.dequeue()\n      tokens -= 1\n      println(s\"RateLimiterActor: Processed queued request $id (Tokens left: $tokens)\")\n      senderRef ! Response(s\"Processed request $id\")\n    }\n  }\n\n  override def postStop(): Unit = {\n    refillTask.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject RateLimiterApp extends App {\n  import akka.pattern.ask\n  import akka.util.Timeout\n  import scala.concurrent.Await\n\n  val system = ActorSystem(\"RateLimiterSystem\")\n  val rateLimiter = system.actorOf(Props[RateLimiterActor](), \"rateLimiterActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to send a request and print the response\n  def sendRequest(id: Int): Unit = {\n    val future = rateLimiter ? Request(id)\n    val result = Await.result(future, timeout.duration).asInstanceOf[Response]\n    println(s\"Request $id: ${result.message}\")\n  }\n\n  // Send 5 requests rapidly\n  for (i <- 1 to 5) {\n    sendRequest(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named WorkerPoolActor that manages a pool of worker actors. It should handle Task(taskId: Int) messages by forwarding them to workers in a round-robin fashion. Each WorkerActor processes the task by printing \"Worker <name> processing task <taskId>\". Demonstrate the worker pool handling multiple tasks efficiently."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Task(taskId: Int)\n\n// Define the WorkerActor\nclass WorkerActor(name: String) extends Actor {\n  def receive: Receive = {\n    case Task(id) =>\n      println(s\"Worker [$name] processing task $id\")\n    case _ =>\n      println(s\"Worker [$name] received unknown message.\")\n  }\n}\n\n// Define the WorkerPoolActor\nclass WorkerPoolActor(workers: Seq[ActorRef]) extends Actor {\n  var nextWorkerIndex: Int = 0\n  val numberOfWorkers: Int = workers.size\n\n  def receive: Receive = {\n    case task: Task =>\n      val worker = workers(nextWorkerIndex)\n      println(s\"WorkerPoolActor delegating Task ${task.taskId} to Worker ${worker.path.name}\")\n      worker ! task\n      nextWorkerIndex = (nextWorkerIndex + 1) % numberOfWorkers\n    case _ =>\n      println(\"WorkerPoolActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject WorkerPoolApp extends App {\n  val system = ActorSystem(\"WorkerPoolSystem\")\n\n  // Create worker actors\n  val worker1 = system.actorOf(Props(new WorkerActor(\"worker1\")), \"worker1\")\n  val worker2 = system.actorOf(Props(new WorkerActor(\"worker2\")), \"worker2\")\n  val worker3 = system.actorOf(Props(new WorkerActor(\"worker3\")), \"worker3\")\n\n  // Create WorkerPoolActor with the workers\n  val workerPool = system.actorOf(Props(new WorkerPoolActor(Seq(worker1, worker2, worker3))), \"workerPoolActor\")\n\n  // Send multiple tasks to the pool\n  for (i <- 1 to 9) {\n    workerPool ! Task(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named HealthCheckerActor that performs periodic health checks of a simulated service. It should send a CheckHealth message to itself every 4 seconds. Upon receiving CheckHealth, it should randomly determine if the service is healthy or unhealthy and respond accordingly with Healthy or Unhealthy. Demonstrate the health checking mechanism."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.util.Random\n\n// Define messages\ncase object CheckHealth\ncase object Healthy\ncase object Unhealthy\n\n// Define the HealthCheckerActor\nclass HealthCheckerActor extends Actor {\n  import context.dispatcher\n\n  // Schedule periodic health checks\n  val checkInterval: FiniteDuration = 4.seconds\n  val scheduler: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = 0.seconds,\n    delay = checkInterval,\n    receiver = self,\n    message = CheckHealth\n  )\n\n  def receive: Receive = {\n    case CheckHealth =>\n      val status = if (Random.nextBoolean()) Healthy else Unhealthy\n      println(s\"HealthCheckerActor: Service status is $status\")\n    case _ =>\n      println(\"HealthCheckerActor received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    scheduler.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject HealthCheckerApp extends App {\n  val system = ActorSystem(\"HealthCheckerSystem\")\n  val healthChecker = system.actorOf(Props(new HealthCheckerActor()), \"healthCheckerActor\")\n\n  // Let the health checker run for 20 seconds before shutdown\n  Thread.sleep(20000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named RetryingActor that handles PerformTask(taskId: Int) messages. Upon receiving a task, it attempts to perform it by randomly succeeding or failing. If a task fails, it should retry up to two additional times before giving up and logging \"Task <taskId> failed after retries.\". Demonstrate the retry mechanism by sending multiple tasks."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.util.Random\n\n// Define messages\ncase class PerformTask(taskId: Int)\ncase class TaskResult(taskId: Int, success: Boolean)\ncase class RetryTask(taskId: Int, attempt: Int)\n\n// Define the RetryingActor\nclass RetryingActor extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case PerformTask(taskId) =>\n      println(s\"RetryingActor: Performing task $taskId (Attempt 1)\")\n      performTask(taskId, attempt = 1)\n    case RetryTask(taskId, attempt) =>\n      println(s\"RetryingActor: Retrying task $taskId (Attempt $attempt)\")\n      performTask(taskId, attempt)\n    case TaskResult(taskId, success) =>\n      if (success) {\n        println(s\"RetryingActor: Task $taskId completed successfully.\")\n      } else {\n        println(s\"RetryingActor: Task $taskId failed.\")\n        if (sender().path.name.startsWith(\"retry\")) {\n          val attempt = sender().path.name.split(\"-\")(1).toInt\n          if (attempt < 3) {\n            // Schedule a retry\n            context.system.scheduler.scheduleOnce(1.second, self, RetryTask(taskId, attempt + 1))\n          } else {\n            println(s\"RetryingActor: Task $taskId failed after retries.\")\n          }\n        }\n      }\n    case _ =>\n      println(\"RetryingActor received unknown message.\")\n  }\n\n  def performTask(taskId: Int, attempt: Int): Unit = {\n    val success = Random.nextBoolean()\n    if (success) {\n      self.tell(TaskResult(taskId, success = true), self)\n    } else {\n      // Create a unique sender name for retries\n      val retrySender = context.actorOf(Props(new Actor {\n        def receive: Receive = {\n          case msg => self.tell(msg, self)\n        }\n      }), name = s\"retry-$attempt\")\n      retrySender ! TaskResult(taskId, success = false)\n    }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject RetryingActorApp extends App {\n  val system = ActorSystem(\"RetryingActorSystem\")\n  val retryingActor = system.actorOf(Props(new RetryingActor()), \"retryingActor\")\n\n  // Send multiple tasks\n  for (i <- 1 to 5) {\n    retryingActor ! PerformTask(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(10000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named DatabaseSimulatorActor that simulates basic database operations. It should handle Insert(record: String), Delete(record: String), and Query(record: String) messages. Maintain an internal Set to store records. Upon Insert, add the record; upon Delete, remove it; and upon Query, respond with RecordFound(record: String) or RecordNotFound(record: String). Demonstrate inserting, deleting, and querying records."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Insert(record: String)\ncase class Delete(record: String)\ncase class Query(record: String)\ncase class RecordFound(record: String)\ncase class RecordNotFound(record: String)\n\n// Define the DatabaseSimulatorActor\nclass DatabaseSimulatorActor extends Actor {\n  var records: Set[String] = Set.empty\n\n  def receive: Receive = {\n    case Insert(record) =>\n      records += record\n      println(s\"DatabaseSimulatorActor: Inserted record '$record'\")\n    case Delete(record) =>\n      if (records.contains(record)) {\n        records -= record\n        println(s\"DatabaseSimulatorActor: Deleted record '$record'\")\n      } else {\n        println(s\"DatabaseSimulatorActor: Record '$record' not found for deletion.\")\n      }\n    case Query(record) =>\n      if (records.contains(record)) {\n        sender() ! RecordFound(record)\n      } else {\n        sender() ! RecordNotFound(record)\n      }\n    case _ =>\n      println(\"DatabaseSimulatorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DatabaseSimulatorApp extends App {\n  val system = ActorSystem(\"DatabaseSimulatorSystem\")\n  val dbSimulator = system.actorOf(Props(new DatabaseSimulatorActor()), \"dbSimulatorActor\")\n\n  // Define a simple responder actor to handle query responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case RecordFound(record) =>\n        println(s\"ResponderActor: Record '$record' found in database.\")\n      case RecordNotFound(record) =>\n        println(s\"ResponderActor: Record '$record' not found in database.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Insert records\n  dbSimulator ! Insert(\"Alice\")\n  dbSimulator ! Insert(\"Bob\")\n\n  // Query existing and non-existing records\n  dbSimulator.tell(Query(\"Alice\"), responder)\n  dbSimulator.tell(Query(\"Charlie\"), responder)\n\n  // Delete a record and query again\n  dbSimulator ! Delete(\"Bob\")\n  dbSimulator.tell(Query(\"Bob\"), responder)\n\n  // Attempt to delete a non-existing record\n  dbSimulator ! Delete(\"Charlie\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TaskSchedulerActor that schedules tasks to be executed after a specified delay. It should handle ScheduleTask(task: String, delay: FiniteDuration) messages by scheduling the task to be executed after the given delay. Upon execution, it should print \"Executed task: <task>\". Demonstrate scheduling multiple tasks with different delays."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport akka.actor.Timers\n\n// Define messages\ncase class ScheduleTask(task: String, delay: FiniteDuration)\n\n// Define the TaskSchedulerActor\nclass TaskSchedulerActor extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case ScheduleTask(task, delay) =>\n      println(s\"TaskSchedulerActor: Scheduling task '$task' to execute in $delay.\")\n      context.system.scheduler.scheduleOnce(delay, self, (\"ExecuteTask\", task))\n    case (\"ExecuteTask\", task: String) =>\n      println(s\"TaskSchedulerActor: Executed task: $task\")\n    case _ =>\n      println(\"TaskSchedulerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TaskSchedulerApp extends App {\n  val system = ActorSystem(\"TaskSchedulerSystem\")\n  val schedulerActor = system.actorOf(Props(new TaskSchedulerActor()), \"schedulerActor\")\n\n  // Schedule multiple tasks with different delays\n  schedulerActor ! ScheduleTask(\"Backup Database\", 2.seconds)\n  schedulerActor ! ScheduleTask(\"Send Report\", 4.seconds)\n  schedulerActor ! ScheduleTask(\"Cleanup Logs\", 6.seconds)\n\n  // Allow some time for task execution before shutdown\n  Thread.sleep(8000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AuthenticationActor that manages user authentication. It should handle Login(username: String, password: String) and Logout(username: String) messages. Maintain an internal Set of authenticated users. Upon successful login (assume any password is valid for simplicity), add the user to the set and respond with LoginSuccess(username: String). Upon logout, remove the user and respond with LogoutSuccess(username: String). Demonstrate logging in and out users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Login(username: String, password: String)\ncase class Logout(username: String)\ncase class LoginSuccess(username: String)\ncase class LogoutSuccess(username: String)\ncase class AuthenticationFailure(username: String, reason: String)\n\n// Define the AuthenticationActor\nclass AuthenticationActor extends Actor {\n  var authenticatedUsers: Set[String] = Set.empty\n\n  def receive: Receive = {\n    case Login(username, password) =>\n      // For simplicity, accept any password\n      if (!authenticatedUsers.contains(username)) {\n        authenticatedUsers += username\n        println(s\"AuthenticationActor: User '$username' logged in.\")\n        sender() ! LoginSuccess(username)\n      } else {\n        sender() ! AuthenticationFailure(username, \"User already logged in.\")\n      }\n\n    case Logout(username) =>\n      if (authenticatedUsers.contains(username)) {\n        authenticatedUsers -= username\n        println(s\"AuthenticationActor: User '$username' logged out.\")\n        sender() ! LogoutSuccess(username)\n      } else {\n        sender() ! AuthenticationFailure(username, \"User not logged in.\")\n      }\n\n    case _ =>\n      println(\"AuthenticationActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject AuthenticationApp extends App {\n  val system = ActorSystem(\"AuthenticationSystem\")\n  val authActor = system.actorOf(Props(new AuthenticationActor()), \"authenticationActor\")\n\n  // Define a simple responder actor to handle authentication responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case LoginSuccess(username) =>\n        println(s\"ResponderActor: User '$username' successfully logged in.\")\n      case LogoutSuccess(username) =>\n        println(s\"ResponderActor: User '$username' successfully logged out.\")\n      case AuthenticationFailure(username, reason) =>\n        println(s\"ResponderActor: Authentication failed for '$username'. Reason: $reason\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Perform login and logout operations\n  authActor.tell(Login(\"Alice\", \"password123\"), responder)\n  authActor.tell(Login(\"Bob\", \"securepass\"), responder)\n  authActor.tell(Login(\"Alice\", \"newpassword\"), responder) // Attempt duplicate login\n  authActor.tell(Logout(\"Alice\"), responder)\n  authActor.tell(Logout(\"Charlie\"), responder) // Attempt logout of non-logged-in user\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TopicPublisherActor that publishes messages to specific topics. It should handle Subscribe(topic: String) and Publish(topic: String, message: String) messages. Maintain a mapping of topics to subscriber actors. Upon publishing, send the message only to subscribers of the specified topic wrapped in TopicMessage(topic: String, message: String). Demonstrate subscribing to different topics and publishing messages accordingly."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(topic: String)\ncase class Publish(topic: String, message: String)\ncase class TopicMessage(topic: String, message: String)\n\n// Define the TopicPublisherActor\nclass TopicPublisherActor extends Actor {\n  var topicSubscribers: Map[String, Set[ActorRef]] = Map.empty.withDefaultValue(Set.empty)\n\n  def receive: Receive = {\n    case Subscribe(topic) =>\n      topicSubscribers += topic -> (topicSubscribers(topic) + sender())\n      println(s\"TopicPublisherActor: ${sender().path.name} subscribed to topic '$topic'\")\n    case Publish(topic, message) =>\n      println(s\"TopicPublisherActor: Publishing message to topic '$topic': $message\")\n      topicSubscribers(topic).foreach(_ ! TopicMessage(topic, message))\n    case _ =>\n      println(\"TopicPublisherActor received unknown message.\")\n  }\n}\n\n// Define the SubscriberActor\nclass SubscriberActor(name: String) extends Actor {\n  def receive: Receive = {\n    case TopicMessage(topic, message) =>\n      println(s\"Subscriber [$name] received on '$topic': $message\")\n    case _ =>\n      println(s\"Subscriber [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TopicPubSubApp extends App {\n  val system = ActorSystem(\"TopicPubSubSystem\")\n  val publisher = system.actorOf(Props(new TopicPublisherActor()), \"publisherActor\")\n\n  // Create subscriber actors\n  val subscriber1 = system.actorOf(Props(new SubscriberActor(\"Subscriber1\")), \"subscriber1\")\n  val subscriber2 = system.actorOf(Props(new SubscriberActor(\"Subscriber2\")), \"subscriber2\")\n  val subscriber3 = system.actorOf(Props(new SubscriberActor(\"Subscriber3\")), \"subscriber3\")\n\n  // Subscribers subscribe to topics\n  subscriber1 ! Subscribe(\"news\")\n  subscriber2 ! Subscribe(\"sports\")\n  subscriber3 ! Subscribe(\"news\")\n  subscriber3 ! Subscribe(\"sports\")\n\n  // Publish messages to topics\n  publisher ! Publish(\"news\", \"Breaking News: Akka Actors are awesome!\")\n  publisher ! Publish(\"sports\", \"Sports Update: Local team wins championship.\")\n  publisher ! Publish(\"entertainment\", \"New movie released this weekend.\") // No subscribers\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TransactionManagerActor that manages simple financial transactions. It should handle Deposit(amount: Double), Withdraw(amount: Double), and GetBalance messages. Maintain an internal balance starting at 0.0. Upon Deposit, add the amount to the balance; upon Withdraw, subtract the amount if sufficient funds exist, otherwise respond with InsufficientFunds(amount: Double). Upon GetBalance, respond with CurrentBalance(balance: Double). Demonstrate performing deposits, withdrawals, and querying the balance."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Deposit(amount: Double)\ncase class Withdraw(amount: Double)\ncase object GetBalance\ncase class CurrentBalance(balance: Double)\ncase class InsufficientFunds(amount: Double)\n\n// Define the TransactionManagerActor\nclass TransactionManagerActor extends Actor {\n  var balance: Double = 0.0\n\n  def receive: Receive = {\n    case Deposit(amount) =>\n      if (amount > 0) {\n        balance += amount\n        println(s\"TransactionManagerActor: Deposited $$${amount}. New balance: $$${balance}.\")\n      } else {\n        println(\"TransactionManagerActor: Deposit amount must be positive.\")\n      }\n    case Withdraw(amount) =>\n      if (amount > 0) {\n        if (balance >= amount) {\n          balance -= amount\n          println(s\"TransactionManagerActor: Withdrew $$${amount}. New balance: $$${balance}.\")\n        } else {\n          println(s\"TransactionManagerActor: Insufficient funds for withdrawal of $$${amount}.\")\n          sender() ! InsufficientFunds(amount)\n        }\n      } else {\n        println(\"TransactionManagerActor: Withdrawal amount must be positive.\")\n      }\n    case GetBalance =>\n      sender() ! CurrentBalance(balance)\n    case _ =>\n      println(\"TransactionManagerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TransactionManagerApp extends App {\n  val system = ActorSystem(\"TransactionManagerSystem\")\n  val transactionManager = system.actorOf(Props(new TransactionManagerActor()), \"transactionManagerActor\")\n\n  // Define a simple responder actor to handle balance queries and errors\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case CurrentBalance(balance) =>\n        println(f\"ResponderActor: Current balance is $$${balance}%.2f\")\n      case InsufficientFunds(amount) =>\n        println(f\"ResponderActor: Cannot withdraw $$${amount}%.2f due to insufficient funds.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Perform transactions\n  transactionManager ! Deposit(500.0)\n  transactionManager ! Withdraw(200.0)\n  transactionManager ! Withdraw(400.0) // Should fail\n  transactionManager.tell(GetBalance, responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named EmailNotificationActor that sends email notifications. It should handle SendEmail(to: String, subject: String, body: String) messages by printing the email details to the console. Implement a UserActor that represents a user and sends SendEmail messages to the EmailNotificationActor. Demonstrate sending emails to multiple users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class SendEmail(to: String, subject: String, body: String)\n\n// Define the EmailNotificationActor\nclass EmailNotificationActor extends Actor {\n  def receive: Receive = {\n    case SendEmail(to, subject, body) =>\n      println(s\"EmailNotificationActor: Sending email to '$to'\")\n      println(s\"Subject: $subject\")\n      println(s\"Body: $body\")\n      println(\"----- Email Sent -----\")\n    case _ =>\n      println(\"EmailNotificationActor received unknown message.\")\n  }\n}\n\n// Define the UserActor\nclass UserActor(name: String, emailNotifier: ActorRef) extends Actor {\n  def receive: Receive = {\n    case (subject: String, body: String) =>\n      val to = s\"$name@example.com\"\n      emailNotifier ! SendEmail(to, subject, body)\n    case _ =>\n      println(s\"UserActor [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EmailNotificationApp extends App {\n  val system = ActorSystem(\"EmailNotificationSystem\")\n  val emailNotifier = system.actorOf(Props(new EmailNotificationActor()), \"emailNotifierActor\")\n\n  // Create user actors\n  val user1 = system.actorOf(Props(new UserActor(\"Alice\", emailNotifier)), \"userAlice\")\n  val user2 = system.actorOf(Props(new UserActor(\"Bob\", emailNotifier)), \"userBob\")\n  val user3 = system.actorOf(Props(new UserActor(\"Charlie\", emailNotifier)), \"userCharlie\")\n\n  // Send emails\n  user1 ! (\"Welcome to our service!\", \"Hello Alice, welcome aboard!\")\n  user2 ! (\"Your account has been updated.\", \"Hi Bob, your account settings have been updated.\")\n  user3 ! (\"Password Reset\", \"Dear Charlie, please reset your password using the link provided.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TaskCompletionListenerActor that listens for TaskCompleted(taskId: Int) messages. Upon receiving such a message, it should print \"Task <taskId> has been completed successfully.\". Implement a WorkerActor that performs tasks and sends TaskCompleted messages to the listener upon completion. Demonstrate task execution and listener notification."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Task(taskId: Int)\ncase class TaskCompleted(taskId: Int)\n\n// Define the TaskCompletionListenerActor\nclass TaskCompletionListenerActor extends Actor {\n  def receive: Receive = {\n    case TaskCompleted(taskId) =>\n      println(s\"TaskCompletionListenerActor: Task $taskId has been completed successfully.\")\n    case _ =>\n      println(\"TaskCompletionListenerActor received unknown message.\")\n  }\n}\n\n// Define the WorkerActor\nclass WorkerActor(listener: ActorRef) extends Actor {\n  def receive: Receive = {\n    case Task(taskId) =>\n      println(s\"WorkerActor: Processing task $taskId.\")\n      // Simulate task processing\n      Thread.sleep(500)\n      println(s\"WorkerActor: Task $taskId completed.\")\n      listener ! TaskCompleted(taskId)\n    case _ =>\n      println(\"WorkerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TaskCompletionApp extends App {\n  val system = ActorSystem(\"TaskCompletionSystem\")\n  \n  val listener = system.actorOf(Props(new TaskCompletionListenerActor()), \"listenerActor\")\n  val worker = system.actorOf(Props(new WorkerActor(listener)), \"workerActor\")\n\n  // Send tasks to the worker\n  worker ! Task(101)\n  worker ! Task(102)\n  worker ! Task(103)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TemperatureMonitorActor that receives temperature readings and alerts if the temperature exceeds a specified threshold. It should handle TemperatureReading(sensorId: String, temperature: Double) messages. If the temperature is above 30.0\u00b0C, respond with Alert(sensorId: String, temperature: Double); otherwise, acknowledge with ReadingAccepted(sensorId: String). Demonstrate monitoring temperatures from multiple sensors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class TemperatureReading(sensorId: String, temperature: Double)\ncase class Alert(sensorId: String, temperature: Double)\ncase class ReadingAccepted(sensorId: String)\n\n// Define the TemperatureMonitorActor\nclass TemperatureMonitorActor extends Actor {\n  val threshold: Double = 30.0\n\n  def receive: Receive = {\n    case TemperatureReading(sensorId, temp) =>\n      if (temp > threshold) {\n        println(s\"TemperatureMonitorActor: Temperature alert from $sensorId: $temp\u00b0C\")\n        sender() ! Alert(sensorId, temp)\n      } else {\n        println(s\"TemperatureMonitorActor: Temperature reading from $sensorId: $temp\u00b0C accepted.\")\n        sender() ! ReadingAccepted(sensorId)\n      }\n    case _ =>\n      println(\"TemperatureMonitorActor received unknown message.\")\n  }\n}\n\n// Define the SensorActor\nclass SensorActor(sensorId: String, monitor: ActorRef) extends Actor {\n  def receive: Receive = {\n    case temp: Double =>\n      println(s\"SensorActor [$sensorId]: Sending temperature reading: $temp\u00b0C\")\n      monitor ! TemperatureReading(sensorId, temp)\n    case _ =>\n      println(s\"SensorActor [$sensorId] received unknown message.\")\n  }\n}\n\n// Define the ResponderActor to handle monitor responses\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Alert(sensorId, temp) =>\n      println(s\"ResponderActor: ALERT! Sensor $sensorId reported high temperature: $temp\u00b0C\")\n    case ReadingAccepted(sensorId) =>\n      println(s\"ResponderActor: Temperature reading from $sensorId accepted.\")\n    case _ =>\n      println(\"ResponderActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TemperatureMonitorApp extends App {\n  val system = ActorSystem(\"TemperatureMonitorSystem\")\n\n  val monitor = system.actorOf(Props(new TemperatureMonitorActor()), \"temperatureMonitorActor\")\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Create sensor actors\n  val sensor1 = system.actorOf(Props(new SensorActor(\"Sensor1\", monitor)), \"sensor1\")\n  val sensor2 = system.actorOf(Props(new SensorActor(\"Sensor2\", monitor)), \"sensor2\")\n  val sensor3 = system.actorOf(Props(new SensorActor(\"Sensor3\", monitor)), \"sensor3\")\n\n  // Send temperature readings\n  sensor1.tell(25.5, responder)\n  sensor2.tell(32.0, responder)\n  sensor3.tell(28.3, responder)\n  sensor1.tell(31.2, responder)\n  sensor2.tell(29.8, responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named OrderProcessorActor that handles online orders. It should handle PlaceOrder(orderId: String, item: String) messages by processing the order and responding with OrderConfirmed(orderId: String) or OrderFailed(orderId: String, reason: String) based on simulated processing logic. Implement a CustomerActor that places orders and handles confirmations or failures. Demonstrate placing multiple orders with varying outcomes."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.util.Random\n\n// Define messages\ncase class PlaceOrder(orderId: String, item: String)\ncase class OrderConfirmed(orderId: String)\ncase class OrderFailed(orderId: String, reason: String)\n\n// Define the OrderProcessorActor\nclass OrderProcessorActor extends Actor {\n  def receive: Receive = {\n    case PlaceOrder(orderId, item) =>\n      println(s\"OrderProcessorActor: Processing order $orderId for item '$item'\")\n      // Simulate order processing with random success/failure\n      if (Random.nextBoolean()) {\n        println(s\"OrderProcessorActor: Order $orderId confirmed.\")\n        sender() ! OrderConfirmed(orderId)\n      } else {\n        println(s\"OrderProcessorActor: Order $orderId failed due to stock unavailability.\")\n        sender() ! OrderFailed(orderId, \"Stock unavailable.\")\n      }\n    case _ =>\n      println(\"OrderProcessorActor received unknown message.\")\n  }\n}\n\n// Define the CustomerActor\nclass CustomerActor(orderProcessor: ActorRef) extends Actor {\n  def receive: Receive = {\n    case PlaceOrder(orderId, item) =>\n      println(s\"CustomerActor: Placing order $orderId for item '$item'\")\n      orderProcessor ! PlaceOrder(orderId, item)\n    case OrderConfirmed(orderId) =>\n      println(s\"CustomerActor: Order $orderId has been confirmed. Thank you!\")\n    case OrderFailed(orderId, reason) =>\n      println(s\"CustomerActor: Order $orderId failed. Reason: $reason\")\n    case _ =>\n      println(\"CustomerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject OrderProcessingApp extends App {\n  val system = ActorSystem(\"OrderProcessingSystem\")\n\n  val orderProcessor = system.actorOf(Props(new OrderProcessorActor()), \"orderProcessorActor\")\n  val customer = system.actorOf(Props(new CustomerActor(orderProcessor)), \"customerActor\")\n\n  // Place multiple orders\n  customer ! PlaceOrder(\"Order001\", \"Laptop\")\n  customer ! PlaceOrder(\"Order002\", \"Smartphone\")\n  customer ! PlaceOrder(\"Order003\", \"Headphones\")\n  customer ! PlaceOrder(\"Order004\", \"Monitor\")\n  customer ! PlaceOrder(\"Order005\", \"Keyboard\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named DataAggregatorActor that collects numerical data from multiple sources and computes the average. It should handle DataPoint(value: Double) messages by adding them to an internal list. Upon receiving a ComputeAverage message, it should calculate and respond with AverageResult(average: Double). Demonstrate collecting data from multiple sources and computing the average."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class DataPoint(value: Double)\ncase object ComputeAverage\ncase class AverageResult(average: Double)\n\n// Define the DataAggregatorActor\nclass DataAggregatorActor extends Actor {\n  var dataPoints: List[Double] = List.empty\n\n  def receive: Receive = {\n    case DataPoint(value) =>\n      dataPoints = value :: dataPoints\n      println(s\"DataAggregatorActor: Received data point $value\")\n    case ComputeAverage =>\n      if (dataPoints.nonEmpty) {\n        val average = dataPoints.sum / dataPoints.size\n        println(f\"DataAggregatorActor: Computed average = $$${average}%.2f\")\n        sender() ! AverageResult(average)\n      } else {\n        println(\"DataAggregatorActor: No data points to compute average.\")\n        sender() ! AverageResult(0.0)\n      }\n    case _ =>\n      println(\"DataAggregatorActor received unknown message.\")\n  }\n}\n\n// Define the DataSourceActor\nclass DataSourceActor(aggregator: ActorRef) extends Actor {\n  def receive: Receive = {\n    case value: Double =>\n      println(s\"DataSourceActor sending data point: $value\")\n      aggregator ! DataPoint(value)\n    case _ =>\n      println(\"DataSourceActor received unknown message.\")\n  }\n}\n\n// Define the ResponderActor to handle average results\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case AverageResult(avg) =>\n      println(f\"ResponderActor: The average of collected data points is $$${avg}%.2f\")\n    case _ =>\n      println(\"ResponderActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DataAggregatorApp extends App {\n  val system = ActorSystem(\"DataAggregatorSystem\")\n\n  val aggregator = system.actorOf(Props(new DataAggregatorActor()), \"aggregatorActor\")\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Create data source actors\n  val source1 = system.actorOf(Props(new DataSourceActor(aggregator)), \"source1\")\n  val source2 = system.actorOf(Props(new DataSourceActor(aggregator)), \"source2\")\n  val source3 = system.actorOf(Props(new DataSourceActor(aggregator)), \"source3\")\n\n  // Send data points from sources\n  source1 ! 10.5\n  source2 ! 20.0\n  source3 ! 30.5\n  source1 ! 25.0\n  source2 ! 15.5\n\n  // Compute average\n  aggregator.tell(ComputeAverage, responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Generate a Scala application using Akka Typed that simulates the Dining Philosophers problem. The application should include:\n\n    Chopstick Actor in the sample package:\n        Handles Take(ref: ActorRef[ChopstickAnswer]) and Put(ref: ActorRef[ChopstickAnswer]) messages.\n        Responds with Taken(chopstick: ActorRef[ChopstickMessage]) when taken successfully or Busy(chopstick: ActorRef[ChopstickMessage]) if already in use.\n        Maintains available and takenBy states to manage chopstick availability.\n\n    Hakker Actor:\n        Handles Think, Eat, and HandleChopstickAnswer(msg: ChopstickAnswer) commands.\n        Transitions through waiting, thinking, hungry, and eating behaviors.\n        Attempts to take left and right chopsticks to eat and handles cases where chopsticks are busy.\n\n    DiningHakkers (Main Application):\n        Initializes five Chopstick actors.\n        Initializes five Hakker actors, each assigned a unique name and two chopsticks (left and right).\n        Starts the simulation by sending the Think message to all hakkers.\n\nEnsure the application uses ConfigFactory for configuration, includes proper logging for tracking states and actions, handles concurrency to avoid deadlocks, and contains comments explaining each component and significant code blocks. Provide the complete Scala code with all necessary imports, package declarations, and actor implementations following best practices."
      },
      {
        "from": "assistant",
        "value": "package sample\n\nimport akka.NotUsed\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.ActorContext\nimport akka.actor.typed.scaladsl.Behaviors\nimport sample.Chopstick.Busy\nimport sample.Chopstick.ChopstickAnswer\nimport sample.Chopstick.ChopstickMessage\nimport sample.Chopstick.Put\nimport sample.Chopstick.Take\nimport sample.Chopstick.Taken\nimport sample.Hakker.Command\n\nimport scala.concurrent.duration._\n\n// Akka adaptation of\n// http://www.dalnefre.com/wp/2010/08/dining-philosophers-in-humus/\n\n/*\n * A Chopstick is an actor, it can be taken, and put back\n */\nobject Chopstick {\n  sealed trait ChopstickMessage\n  final case class Take(ref: ActorRef[ChopstickAnswer]) extends ChopstickMessage\n  final case class Put(ref: ActorRef[ChopstickAnswer]) extends ChopstickMessage\n\n  sealed trait ChopstickAnswer\n  final case class Taken(chopstick: ActorRef[ChopstickMessage])\n      extends ChopstickAnswer\n  final case class Busy(chopstick: ActorRef[ChopstickMessage])\n      extends ChopstickAnswer\n\n  def apply(): Behavior[ChopstickMessage] = available()\n\n  //When a Chopstick is taken by a hakker\n  //It will refuse to be taken by other hakkers\n  //But the owning hakker can put it back\n  private def takenBy(\n    hakker: ActorRef[ChopstickAnswer]\n  ): Behavior[ChopstickMessage] = {\n    Behaviors.receive {\n      case (ctx, Take(otherHakker)) =>\n        otherHakker ! Busy(ctx.self)\n        Behaviors.same\n      case (_, Put(`hakker`)) =>\n        available()\n      case _ =>\n        // here and below it's left to be explicit about partial definition,\n        // but can be omitted when Behaviors.receiveMessagePartial is in use\n        Behaviors.unhandled\n    }\n  }\n\n  //When a Chopstick is available, it can be taken by a hakker\n  private def available(): Behavior[ChopstickMessage] = {\n    Behaviors.receivePartial {\n      case (ctx, Take(hakker)) =>\n        hakker ! Taken(ctx.self)\n        takenBy(hakker)\n    }\n  }\n}\n\n/*\n * A hakker is an awesome dude or dudette who either thinks about hacking or has to eat ;-)\n */\nobject Hakker {\n  sealed trait Command\n  case object Think extends Command\n  case object Eat extends Command\n  final case class HandleChopstickAnswer(msg: ChopstickAnswer)\n      extends Command\n\n  def apply(name: String, left: ActorRef[ChopstickMessage], right: ActorRef[ChopstickMessage]): Behavior[Command] =\n    Behaviors.setup { ctx =>\n      new Hakker(ctx, name, left, right).waiting\n    }\n}\n\nclass Hakker(ctx: ActorContext[Command],\n             name: String,\n             left: ActorRef[ChopstickMessage],\n             right: ActorRef[ChopstickMessage]) {\n\n  import Hakker._\n\n  private val adapter = ctx.messageAdapter(HandleChopstickAnswer)\n\n  val waiting: Behavior[Command] =\n    Behaviors.receiveMessagePartial {\n      case Think =>\n        ctx.log.info(\"{} starts to think\", name)\n        startThinking(ctx, 5.seconds)\n    }\n\n  //When a hakker is thinking it can become hungry\n  //and try to pick up its chopsticks and eat\n  private val thinking: Behavior[Command] = {\n    Behaviors.receiveMessagePartial {\n      case Eat =>\n        left ! Chopstick.Take(adapter)\n        right ! Chopstick.Take(adapter)\n        hungry\n    }\n  }\n\n  //When a hakker is hungry it tries to pick up its chopsticks and eat\n  //When it picks one up, it goes into wait for the other\n  //If the hakkers first attempt at grabbing a chopstick fails,\n  //it starts to wait for the response of the other grab\n  private lazy val hungry: Behavior[Command] =\n    Behaviors.receiveMessagePartial {\n      case HandleChopstickAnswer(Taken(`left`)) =>\n        waitForOtherChopstick(chopstickToWaitFor = right, takenChopstick = left)\n\n      case HandleChopstickAnswer(Taken(`right`)) =>\n        waitForOtherChopstick(chopstickToWaitFor = left, takenChopstick = right)\n\n      case HandleChopstickAnswer(Busy(_)) =>\n        firstChopstickDenied\n    }\n\n  //When a hakker is waiting for the last chopstick it can either obtain it\n  //and start eating, or the other chopstick was busy, and the hakker goes\n  //back to think about how he should obtain his chopsticks :-)\n  private def waitForOtherChopstick(\n    chopstickToWaitFor: ActorRef[ChopstickMessage],\n    takenChopstick: ActorRef[ChopstickMessage]\n  ): Behavior[Command] = {\n    Behaviors.receiveMessagePartial {\n      case HandleChopstickAnswer(Taken(`chopstickToWaitFor`)) =>\n        ctx.log.info(\n          \"{} has picked up {} and {} and starts to eat\",\n          name,\n          left.path.name,\n          right.path.name\n        )\n        startEating(ctx, 5.seconds)\n\n      case HandleChopstickAnswer(Busy(`chopstickToWaitFor`)) =>\n        takenChopstick ! Put(adapter)\n        startThinking(ctx, 10.milliseconds)\n    }\n  }\n\n  //When a hakker is eating, he can decide to start to think,\n  //then he puts down his chopsticks and starts to think\n  private lazy val eating: Behavior[Command] = {\n    Behaviors.receiveMessagePartial {\n      case Think =>\n        ctx.log.info(\"{} puts down his chopsticks and starts to think\", name)\n        left ! Put(adapter)\n        right ! Put(adapter)\n        startThinking(ctx, 5.seconds)\n    }\n  }\n\n  //When the results of the other grab comes back,\n  //he needs to put it back if he got the other one.\n  //Then go back and think and try to grab the chopsticks again\n  private lazy val firstChopstickDenied: Behavior[Command] = {\n    Behaviors.receiveMessagePartial {\n      case HandleChopstickAnswer(Taken(chopstick)) =>\n        chopstick ! Put(adapter)\n        startThinking(ctx, 10.milliseconds)\n      case HandleChopstickAnswer(Busy(_)) =>\n        startThinking(ctx, 10.milliseconds)\n    }\n  }\n\n  private def startThinking(ctx: ActorContext[Command],\n                            duration: FiniteDuration) = {\n    Behaviors.withTimers[Command] { timers =>\n      timers.startSingleTimer(Eat, Eat, duration)\n      thinking\n    }\n  }\n\n  private def startEating(ctx: ActorContext[Command],\n                          duration: FiniteDuration) = {\n    Behaviors.withTimers[Command] { timers =>\n      timers.startSingleTimer(Think, Think, duration)\n      eating\n    }\n  }\n}\n\nobject DiningHakkers {\n\n  def apply(): Behavior[NotUsed] = Behaviors.setup { context =>\n    //Create 5 chopsticks\n    val chopsticks = for (i <- 1 to 5)\n      yield context.spawn(Chopstick(), \"Chopstick\" + i)\n\n    //Create 5 awesome hakkers and assign them their left and right chopstick\n    val hakkers = for {\n      (name, i) <- List(\"Ghosh\", \"Boner\", \"Klang\", \"Krasser\", \"Manie\").zipWithIndex\n    } yield\n      context.spawn(Hakker(name, chopsticks(i), chopsticks((i + 1) % 5)), name)\n\n    //Signal all hakkers that they should start thinking, and watch the show\n    hakkers.foreach(_ ! Hakker.Think)\n\n    Behaviors.empty\n  }\n\n  def main(args: Array[String]): Unit = {\n    ActorSystem(DiningHakkers(), \"DiningHakkers\")\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Write a Scala application using Akka Typed that sets up a simple Akka Cluster. The application should include an `App` object with a `main` method that initializes the Actor System on specified ports and spawns a `ClusterListener` actor to monitor cluster events."
      },
      {
        "from": "assistant",
        "value": "package sample.cluster.simple\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport com.typesafe.config.ConfigFactory\n\nobject App {\n\n  object RootBehavior {\n    def apply(): Behavior[Nothing] = Behaviors.setup[Nothing] { context =>\n      // Create an actor that handles cluster domain events\n      context.spawn(ClusterListener(), \"ClusterListener\")\n\n      Behaviors.empty\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val ports =\n      if (args.isEmpty)\n        Seq(25251, 25252, 0)\n      else\n        args.toSeq.map(_.toInt)\n    ports.foreach(startup)\n  }\n\n  def startup(port: Int): Unit = {\n    // Override the configuration of the port\n    val config = ConfigFactory.parseString(\n      s\"\"\"\n      akka.remote.artery.canonical.port=$port\n      \"\"\"\n    ).withFallback(ConfigFactory.load())\n\n    // Create an Akka system\n    ActorSystem[Nothing](RootBehavior(), \"ClusterSystem\", config)\n  }\n\n  object ClusterListener {\n    import akka.actor.typed.ActorRef\n    import akka.cluster.ClusterEvent\n    import akka.cluster.ClusterEvent.MemberEvent\n    import akka.cluster.ClusterEvent.ReachabilityEvent\n    import akka.actor.typed.scaladsl.LoggerOps\n\n    sealed trait Event\n    final case class WrappedMemberEvent(event: MemberEvent) extends Event\n    final case class WrappedReachabilityEvent(event: ReachabilityEvent) extends Event\n\n    def apply(): Behavior[Event] = {\n      Behaviors.setup { context =>\n        val memberEventAdapter: ActorRef[MemberEvent] =\n          context.messageAdapter(WrappedMemberEvent)\n        val reachabilityEventAdapter: ActorRef[ReachabilityEvent] =\n          context.messageAdapter(WrappedReachabilityEvent)\n\n        val cluster = akka.cluster.typed.Cluster(context.system)\n        cluster.subscriptions ! akka.cluster.typed.Subscribe(memberEventAdapter, classOf[ClusterEvent.MemberEvent])\n        cluster.subscriptions ! akka.cluster.typed.Subscribe(reachabilityEventAdapter, classOf[ClusterEvent.ReachabilityEvent])\n\n        Behaviors.receiveMessage {\n          case WrappedMemberEvent(memberEvent) =>\n            context.log.info2(\"MemberEvent: {}\", memberEvent)\n            Behaviors.same\n          case WrappedReachabilityEvent(reachabilityEvent) =>\n            context.log.info2(\"ReachabilityEvent: {}\", reachabilityEvent)\n            Behaviors.same\n        }\n      }\n    }\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TrafficLightActor that cycles between Red, Green, and Yellow states with timed transitions. Use context.become to manage state transitions and log the current state to the console."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\n\nobject TrafficLightActor {\n  case object Change\n}\n\nclass TrafficLightActor extends Actor {\n  import TrafficLightActor._\n  import context.dispatcher\n\n  def red: Receive = {\n    case Change =>\n      println(\"Transitioning from RED to GREEN\")\n      context.become(green)\n      context.system.scheduler.scheduleOnce(5.seconds, self, Change)\n  }\n\n  def green: Receive = {\n    case Change =>\n      println(\"Transitioning from GREEN to YELLOW\")\n      context.become(yellow)\n      context.system.scheduler.scheduleOnce(2.seconds, self, Change)\n  }\n\n  def yellow: Receive = {\n    case Change =>\n      println(\"Transitioning from YELLOW to RED\")\n      context.become(red)\n      context.system.scheduler.scheduleOnce(3.seconds, self, Change)\n  }\n\n  override def preStart(): Unit = {\n    println(\"Starting Traffic Light in RED state\")\n    context.system.scheduler.scheduleOnce(3.seconds, self, Change)\n  }\n\n  def receive: Receive = red\n}\n\nobject TrafficLightApp extends App {\n  val system = ActorSystem(\"TrafficLightSystem\")\n  val trafficLight = system.actorOf(Props[TrafficLightActor](), \"trafficLight\")\n  Thread.sleep(20000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Cluster Singleton in Scala using Akka Typed. The singleton actor should manage configuration updates by handling UpdateConfig and GetConfig commands. Provide code that initializes the cluster system and spawns the singleton actor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.typed.{ActorSystem, Behavior}\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.cluster.typed.{ClusterSingleton, SingletonActor}\nimport com.typesafe.config.ConfigFactory\n\nobject ConfigManager {\n  sealed trait Command\n  final case class UpdateConfig(config: String) extends Command\n  case object GetConfig extends Command\n\n  def apply(): Behavior[Command] = Behaviors.receive { (context, message) =>\n    message match {\n      case UpdateConfig(config) =>\n        context.log.info(s\"Config updated to: $config\")\n        Behaviors.same\n      case GetConfig =>\n        context.log.info(\"Returning current config\")\n        Behaviors.same\n    }\n  }\n}\n\nobject ClusterSingletonApp extends App {\n  val config = ConfigFactory.load()\n  val system: ActorSystem[Nothing] = ActorSystem(Behaviors.empty, \"ClusterSystem\", config)\n\n  val singletonManager = ClusterSingleton(system)\n  val configManagerProxy = singletonManager.init(\n    SingletonActor(\n      Behaviors.supervise(ConfigManager()).onFailure[Exception](\n        akka.actor.typed.SupervisorStrategy.restart\n      ),\n      \"ConfigManager\"\n    )\n  )\n\n  // Interact with the singleton\n  configManagerProxy ! ConfigManager.UpdateConfig(\"NewConfigValue\")\n\n  Thread.sleep(5000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named StreamProcessingActor that integrates with Akka Streams. The actor should materialize a stream of numbers from 1 to 10 and print each number to the console when it receives a \"start\" message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.stream.ActorMaterializer\nimport akka.stream.scaladsl.{Source, Sink}\n\nclass StreamProcessingActor extends Actor {\n  implicit val materializer: ActorMaterializer = ActorMaterializer()(context.system)\n  def receive: Receive = {\n    case \"start\" =>\n      Source(1 to 10).runWith(Sink.foreach(n => println(s\"StreamProcessingActor received: $n\")))\n  }\n}\n\nobject StreamProcessingApp extends App {\n  val system = ActorSystem(\"StreamProcessingSystem\")\n  val streamActor = system.actorOf(Props[StreamProcessingActor](), \"streamActor\")\n  streamActor ! \"start\"\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named ChatRoomActor that simulates a chat room where users can join, leave, and send messages. Each user is represented as a separate actor that registers with the ChatRoomActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Messages for ChatRoom communication\ncase class Join(userRef: ActorRef, username: String)\ncase class Leave(username: String)\ncase class ChatMessage(username: String, message: String)\ncase class BroadcastMessage(content: String)\n\n// Actor that implements a simple chat room\nclass ChatRoomActor extends Actor {\n  // Map from username to the corresponding ActorRef for the user\n  var participants: Map[String, ActorRef] = Map.empty\n\n  def receive: Receive = {\n    case Join(userRef, username) =>\n      participants += (username -> userRef)\n      println(s\"ChatRoom: $username has joined the chat.\")\n      broadcast(s\"$username has entered the chat.\")\n\n    case Leave(username) =>\n      participants.get(username) match {\n        case Some(_) =>\n          participants -= username\n          println(s\"ChatRoom: $username has left the chat.\")\n          broadcast(s\"$username has left the chat.\")\n        case None =>\n          println(s\"ChatRoom: Unable to remove $username, user not found.\")\n      }\n\n    case ChatMessage(username, message) =>\n      val chatLine = s\"[$username]: $message\"\n      broadcast(chatLine)\n\n    case _ =>\n      println(\"ChatRoomActor: Received unknown message.\")\n  }\n\n  private def broadcast(msg: String): Unit = {\n    participants.values.foreach(_ ! BroadcastMessage(msg))\n  }\n}\n\n// Actor representing an individual user\nclass ChatUserActor(username: String) extends Actor {\n  def receive: Receive = {\n    case BroadcastMessage(content) =>\n      println(s\"($username) Received broadcast message: $content\")\n    case _ =>\n      println(s\"($username) Received an unknown message.\")\n  }\n}\n\nobject ChatRoomApp extends App {\n  val system = ActorSystem(\"ChatRoomSystem\")\n  val chatRoom = system.actorOf(Props[ChatRoomActor](), \"chatRoomActor\")\n\n  // Create two users\n  val userAlice = system.actorOf(Props(new ChatUserActor(\"Alice\")), \"aliceActor\")\n  val userBob   = system.actorOf(Props(new ChatUserActor(\"Bob\")), \"bobActor\")\n\n  // Users join the chat room\n  chatRoom ! Join(userAlice, \"Alice\")\n  chatRoom ! Join(userBob, \"Bob\")\n\n  // Alice sends a message\n  chatRoom ! ChatMessage(\"Alice\", \"Hello everyone!\")\n  // Bob replies\n  chatRoom ! ChatMessage(\"Bob\", \"Hi Alice!\")\n\n  // Bob leaves the chat\n  chatRoom ! Leave(\"Bob\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named RateLimitingActor that processes only one message at a time, queueing any excess messages. The actor should become busy while processing and then free up after a short period."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.collection.mutable\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase class RequestMsg(content: String)\ncase object ProcessNext\n\nclass RateLimitingActor extends Actor {\n  private val queue = mutable.Queue[RequestMsg]()\n  private var isProcessing = false\n  private var schedule: Option[Cancellable] = None\n\n  def receive: Receive = {\n    case req: RequestMsg =>\n      queue.enqueue(req)\n      tryProcessNext()\n\n    case ProcessNext =>\n      if (queue.nonEmpty) {\n        val msg = queue.dequeue()\n        println(s\"RateLimitingActor: Processing -> ${msg.content}\")\n        isProcessing = true\n        // Simulate processing time: after 1 second, the actor becomes free\n        schedule = Some(context.system.scheduler.scheduleOnce(1.second, self, \"done\"))\n      } else {\n        isProcessing = false\n      }\n\n    case \"done\" =>\n      isProcessing = false\n      tryProcessNext()\n\n    case _ =>\n      println(\"RateLimitingActor: Received unknown message.\")\n  }\n\n  private def tryProcessNext(): Unit = {\n    if (!isProcessing && queue.nonEmpty) {\n      self ! ProcessNext\n    }\n  }\n\n  override def postStop(): Unit = {\n    schedule.foreach(_.cancel())\n    super.postStop()\n  }\n}\n\nobject RateLimitingApp extends App {\n  val system = ActorSystem(\"RateLimitingSystem\")\n  val limiter = system.actorOf(Props[RateLimitingActor](), \"rateLimitingActor\")\n\n  // Send multiple messages in quick succession\n  for (i <- 1 to 5) {\n    limiter ! RequestMsg(s\"request-$i\")\n  }\n\n  Thread.sleep(7000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TrafficLightFSMActor that behaves like a traffic light, transitioning between Red, Yellow, and Green states at specific intervals using internal messages for state changes."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nsealed trait TrafficLightState\ncase object Red extends TrafficLightState\ncase object Yellow extends TrafficLightState\ncase object Green extends TrafficLightState\n\ncase object Switch // Internal message to change state\n\nclass TrafficLightFSMActor extends Actor {\n  var currentState: TrafficLightState = Red\n  var schedule: Option[Cancellable] = None\n\n  override def preStart(): Unit = {\n    // On startup, set the initial timer\n    scheduleNextSwitch(2.seconds)\n  }\n\n  def receive: Receive = {\n    case Switch =>\n      currentState match {\n        case Red =>\n          currentState = Green\n          println(\"Traffic Light: Switching from RED to GREEN.\")\n          scheduleNextSwitch(3.seconds)\n        case Green =>\n          currentState = Yellow\n          println(\"Traffic Light: Switching from GREEN to YELLOW.\")\n          scheduleNextSwitch(1.second)\n        case Yellow =>\n          currentState = Red\n          println(\"Traffic Light: Switching from YELLOW to RED.\")\n          scheduleNextSwitch(2.seconds)\n      }\n\n    case _ =>\n      println(\"TrafficLightFSMActor: Received unknown message.\")\n  }\n\n  private def scheduleNextSwitch(after: FiniteDuration): Unit = {\n    schedule.foreach(_.cancel())\n    schedule = Some(context.system.scheduler.scheduleOnce(after, self, Switch))\n  }\n\n  override def postStop(): Unit = {\n    schedule.foreach(_.cancel())\n    super.postStop()\n  }\n}\n\nobject TrafficLightApp extends App {\n  val system = ActorSystem(\"TrafficLightSystem\")\n  val trafficLight = system.actorOf(Props[TrafficLightFSMActor](), \"trafficLightActor\")\n\n  Thread.sleep(10000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named AggregationActor that sends WorkRequest messages to multiple WorkerActors and waits to receive all corresponding WorkResult messages, then aggregates them and returns a combined result to the original sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase class WorkRequest(data: String)\ncase class WorkResult(result: String)\n\n// Worker actor that performs a simple operation\nclass WorkerActor(workerId: Int) extends Actor {\n  def receive: Receive = {\n    case WorkRequest(data) =>\n      val processed = s\"Worker-$workerId processed: $data\"\n      println(processed)\n      sender() ! WorkResult(processed)\n    case _ =>\n      println(s\"Worker-$workerId: Received unknown message.\")\n  }\n}\n\n// Actor that aggregates results from workers\nclass AggregationActor(workers: Seq[ActorRef]) extends Actor {\n  var pendingResults: List[String] = Nil\n  var awaiting: Int = 0\n  var originalSender: Option[ActorRef] = None\n\n  def receive: Receive = {\n    case req: WorkRequest =>\n      println(\"AggregationActor: Sending WorkRequest to all workers.\")\n      awaiting = workers.size\n      pendingResults = Nil\n      originalSender = Some(sender())\n\n      workers.foreach(_ ! req)\n\n    case WorkResult(res) =>\n      pendingResults = res :: pendingResults\n      awaiting -= 1\n      if (awaiting == 0) {\n        val aggregated = pendingResults.reverse.mkString(\" | \")\n        println(s\"AggregationActor: Collected all results:\\n$aggregated\")\n        originalSender.foreach(_ ! WorkResult(s\"Aggregated: $aggregated\"))\n      }\n\n    case _ =>\n      println(\"AggregationActor: Received unknown message.\")\n  }\n}\n\nobject AggregationApp extends App {\n  val system = ActorSystem(\"AggregationSystem\")\n\n  val workers = (1 to 3).map(i => system.actorOf(Props(new WorkerActor(i)), s\"worker-$i\"))\n  val aggregator = system.actorOf(Props(new AggregationActor(workers)), \"aggregatorActor\")\n\n  // Send a WorkRequest through aggregator to all workers\n  aggregator ! WorkRequest(\"Perform calculation\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Show an example in Akka Typed using TimerScheduler by defining a ReminderActor that sends periodic reminder messages, along with a test application that issues Start and Stop commands."
      },
      {
        "from": "assistant",
        "value": "package sample\n\nimport akka.actor.typed.scaladsl.{Behaviors, TimerScheduler, ActorContext}\nimport akka.actor.typed.{ActorRef, ActorSystem, Behavior}\nimport scala.concurrent.duration._\n\nobject ReminderActor {\n  sealed trait Command\n  case object Start extends Command\n  case object Reminder extends Command\n  case object Stop extends Command\n\n  def apply(): Behavior[Command] = Behaviors.withTimers { timers =>\n    Behaviors.setup { context =>\n      new ReminderBehavior(timers, context).idle\n    }\n  }\n}\n\nclass ReminderBehavior(timers: TimerScheduler[ReminderActor.Command],\n                       context: ActorContext[ReminderActor.Command]) {\n  import ReminderActor._\n\n  val Interval: FiniteDuration = 2.seconds\n\n  // Idle state: waiting for the Start command\n  def idle: Behavior[Command] = Behaviors.receiveMessage {\n    case Start =>\n      context.log.info(\"ReminderActor: Starting reminders every 2 seconds...\")\n      timers.startTimerWithFixedDelay(Reminder, Reminder, Interval)\n      active\n    case _ =>\n      Behaviors.same\n  }\n\n  // Active state: sending periodic reminders\n  def active: Behavior[Command] = Behaviors.receiveMessage {\n    case Reminder =>\n      context.log.info(\"Here is your periodic reminder!\")\n      Behaviors.same\n    case Stop =>\n      context.log.info(\"ReminderActor: Received Stop, stopping reminders and returning to idle.\")\n      timers.cancel(Reminder)\n      idle\n    case _ =>\n      Behaviors.same\n  }\n}\n\nobject ReminderApp extends App {\n  // Create the typed actor system\n  val system: ActorSystem[ReminderActor.Command] =\n    ActorSystem(ReminderActor(), \"ReminderSystem\")\n\n  // Start the reminders\n  system ! ReminderActor.Start\n\n  // After a few seconds, stop the reminders\n  Thread.sleep(7000)\n  system ! ReminderActor.Stop\n\n  // Wait a couple more seconds then terminate\n  Thread.sleep(2000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named StockMonitorActor that receives StockPrice messages and sends an Alert to a NotificationActor if the price exceeds a threshold."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Messages for stock monitoring\ncase class StockPrice(ticker: String, price: Double)\ncase class Alert(ticker: String, price: Double)\n\n// Notification actor that logs alerts\nclass NotificationActor extends Actor {\n  def receive: Receive = {\n    case Alert(ticker, price) =>\n      println(s\"ALERT: $ticker has reached a price of $$ $price\")\n    case _ => println(\"NotificationActor: Received unknown message.\")\n  }\n}\n\n// StockMonitorActor checks incoming stock prices\nclass StockMonitorActor(notificationActor: ActorRef) extends Actor {\n  val threshold: Double = 100.0\n  def receive: Receive = {\n    case StockPrice(ticker, price) =>\n      println(s\"StockMonitorActor: Received $$ $price for $ticker\")\n      if (price > threshold) {\n        notificationActor ! Alert(ticker, price)\n      }\n    case _ => println(\"StockMonitorActor: Received unknown message.\")\n  }\n}\n\nobject StockMonitorApp extends App {\n  val system = ActorSystem(\"StockMonitorSystem\")\n  val notification = system.actorOf(Props[NotificationActor](), \"notificationActor\")\n  val monitor = system.actorOf(Props(new StockMonitorActor(notification)), \"stockMonitorActor\")\n\n  monitor ! StockPrice(\"AAPL\", 95.0)\n  monitor ! StockPrice(\"GOOG\", 150.0)\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named VendingMachineActor that simulates a vending machine. It should accept InsertCoin and SelectItem messages, dispense items if sufficient funds are available, and return change if necessary."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Messages for vending machine operations\ncase class InsertCoin(amount: Double)\ncase class SelectItem(item: String)\ncase class DispenseItem(item: String)\ncase class ReturnChange(amount: Double)\n\nclass VendingMachineActor extends Actor {\n  var balance: Double = 0.0\n  // Inventory: item -> (price, stock)\n  var inventory: Map[String, (Double, Int)] = Map(\n    \"Soda\" -> (1.5, 5),\n    \"Chips\" -> (2.0, 3)\n  )\n\n  def receive: Receive = {\n    case InsertCoin(amount) =>\n      balance += amount\n      println(s\"VendingMachine: Inserted $$ $amount, current balance is $$ $balance\")\n\n    case SelectItem(item) =>\n      inventory.get(item) match {\n        case Some((price, stock)) if stock > 0 =>\n          if (balance >= price) {\n            balance -= price\n            inventory += (item -> (price, stock - 1))\n            println(s\"VendingMachine: Dispensing $item\")\n            sender() ! DispenseItem(item)\n            if (balance > 0) {\n              println(s\"VendingMachine: Returning change $$ $balance\")\n              sender() ! ReturnChange(balance)\n              balance = 0.0\n            }\n          } else {\n            println(s\"VendingMachine: Insufficient funds for $item\")\n          }\n        case Some((_, stock)) if stock == 0 =>\n          println(s\"VendingMachine: $item is out of stock\")\n        case None =>\n          println(s\"VendingMachine: Unknown item $item\")\n      }\n\n    case _ => println(\"VendingMachine: Received unknown message\")\n  }\n}\n\nobject VendingMachineApp extends App {\n  val system = ActorSystem(\"VendingMachineSystem\")\n  val vendingMachine = system.actorOf(Props[VendingMachineActor](), \"vendingMachineActor\")\n\n  vendingMachine ! InsertCoin(2.0)\n  vendingMachine ! SelectItem(\"Soda\")\n  vendingMachine ! InsertCoin(1.0)\n  vendingMachine ! SelectItem(\"Chips\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named StashingActor that uses the stash to buffer incoming messages until an Initialize message is received. After initialization, process all stashed messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Messages for stashing\ncase object Initialize\ncase class DataMessage(data: String)\n\nclass StashingActor extends Actor with Stash {\n  def receive: Receive = uninitialized\n\n  def uninitialized: Receive = {\n    case Initialize =>\n      println(\"StashingActor: Initialized. Unstashing messages.\")\n      unstashAll()\n      context.become(initialized)\n    case msg =>\n      println(\"StashingActor: Stashing message until initialization.\")\n      stash()\n  }\n\n  def initialized: Receive = {\n    case DataMessage(data) =>\n      println(s\"StashingActor: Processing data -> $data\")\n    case _ => println(\"StashingActor: Received unknown message in initialized state.\")\n  }\n}\n\nobject StashingActorApp extends App {\n  val system = ActorSystem(\"StashingActorSystem\")\n  val stasher = system.actorOf(Props[StashingActor](), \"stashingActor\")\n\n  stasher ! DataMessage(\"Message 1\")\n  stasher ! DataMessage(\"Message 2\")\n  stasher ! Initialize\n  stasher ! DataMessage(\"Message 3\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named SupervisionDemoActor that spawns a child actor which fails when receiving a specific message. The parent actor should use a custom supervision strategy to restart the child actor upon failure."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy}\nimport akka.actor.SupervisorStrategy.{Restart}\nimport scala.concurrent.duration._\n\ncase object Fail\n\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case Fail =>\n      println(\"ChildActor: Failing as requested.\")\n      throw new RuntimeException(\"Child failure\")\n    case msg => println(s\"ChildActor: Received message $msg\")\n  }\n}\n\nclass SupervisionDemoActor extends Actor {\n  override val supervisorStrategy = OneForOneStrategy(maxNrOfRetries = 3, withinTimeRange = 1.minute) {\n    case _: RuntimeException =>\n      println(\"SupervisionDemoActor: Restarting child actor due to failure.\")\n      Restart\n  }\n\n  val child = context.actorOf(Props[ChildActor](), \"childActor\")\n\n  def receive: Receive = {\n    case msg => child.forward(msg)\n  }\n}\n\nobject SupervisionDemoApp extends App {\n  val system = ActorSystem(\"SupervisionSystem\")\n  val supervisor = system.actorOf(Props[SupervisionDemoActor](), \"supervisorActor\")\n\n  supervisor ! \"Hello\"\n  supervisor ! Fail\n  supervisor ! \"After failure\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CarActor that simulates a car's behavior. It should handle commands such as Accelerate, Brake, and Park, and use context.become to change its behavior based on whether the car is moving or parked."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Car commands\nsealed trait CarCommand\ncase object Accelerate extends CarCommand\ncase object Brake extends CarCommand\ncase object Park extends CarCommand\n\nclass CarActor extends Actor {\n  def parked: Receive = {\n    case Accelerate =>\n      println(\"CarActor: Starting to accelerate from parked state.\")\n      context.become(moving(10))\n    case _ => println(\"CarActor: In parked state, only Accelerate is valid.\")\n  }\n\n  def moving(speed: Int): Receive = {\n    case Accelerate =>\n      val newSpeed = speed + 10\n      println(s\"CarActor: Accelerating to $newSpeed.\")\n      context.become(moving(newSpeed))\n    case Brake =>\n      val newSpeed = math.max(speed - 10, 0)\n      println(s\"CarActor: Braking to $newSpeed.\")\n      if (newSpeed == 0) context.become(parked) else context.become(moving(newSpeed))\n    case Park =>\n      println(\"CarActor: Parking the car.\")\n      context.become(parked)\n    case _ => println(\"CarActor: Received unknown command.\")\n  }\n\n  def receive: Receive = parked\n}\n\nobject CarActorApp extends App {\n  val system = ActorSystem(\"CarSystem\")\n  val car = system.actorOf(Props[CarActor](), \"carActor\")\n\n  car ! Accelerate\n  car ! Accelerate\n  car ! Brake\n  car ! Park\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Develop an Akka Actor in Scala named OrderQueueActor that queues incoming orders (PlaceOrder) and processes them one at a time. It should also handle cancellation of orders (CancelOrder)."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.Queue\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase class PlaceOrder(orderId: String, details: String)\ncase class CancelOrder(orderId: String)\ncase object ProcessOrder\n\nclass OrderQueueActor extends Actor {\n  val orderQueue: Queue[(String, String)] = Queue.empty\n  var processing: Boolean = false\n\n  def receive: Receive = {\n    case PlaceOrder(id, details) =>\n      orderQueue.enqueue((id, details))\n      println(s\"OrderQueueActor: Order $id placed.\")\n      tryProcessNext()\n\n    case CancelOrder(id) =>\n      val initialSize = orderQueue.size\n      orderQueue.dequeueAll(_._1 == id)\n      if (orderQueue.size < initialSize) println(s\"OrderQueueActor: Order $id cancelled.\")\n      else println(s\"OrderQueueActor: Order $id not found.\")\n\n    case ProcessOrder =>\n      if (orderQueue.nonEmpty) {\n        val (id, details) = orderQueue.dequeue()\n        println(s\"OrderQueueActor: Processing order $id with details: $details\")\n        processing = true\n        context.system.scheduler.scheduleOnce(500.milliseconds, self, \"orderDone\")\n      } else {\n        processing = false\n      }\n\n    case \"orderDone\" =>\n      println(\"OrderQueueActor: Finished processing an order.\")\n      processing = false\n      tryProcessNext()\n\n    case _ => println(\"OrderQueueActor: Received unknown message.\")\n  }\n\n  private def tryProcessNext(): Unit = {\n    if (!processing && orderQueue.nonEmpty) {\n      self ! ProcessOrder\n    }\n  }\n}\n\nobject OrderQueueApp extends App {\n  val system = ActorSystem(\"OrderQueueSystem\")\n  val orderQueue = system.actorOf(Props[OrderQueueActor](), \"orderQueueActor\")\n\n  orderQueue ! PlaceOrder(\"Order1\", \"Item A\")\n  orderQueue ! PlaceOrder(\"Order2\", \"Item B\")\n  orderQueue ! CancelOrder(\"Order1\")\n  orderQueue ! PlaceOrder(\"Order3\", \"Item C\")\n\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SystemHealthMonitor that periodically checks the health of system components and sends HealthStatus messages to a LoggerActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase object CheckHealth\ncase class HealthStatus(component: String, status: String)\n\nclass SystemHealthMonitor(logger: ActorRef) extends Actor {\n  val scheduler = context.system.scheduler.scheduleWithFixedDelay(0.seconds, 3.seconds, self, CheckHealth)\n\n  def receive: Receive = {\n    case CheckHealth =>\n      val components = List(\"Database\", \"WebServer\")\n      components.foreach { comp =>\n        val status = if (scala.util.Random.nextBoolean()) \"Healthy\" else \"Unhealthy\"\n        println(s\"SystemHealthMonitor: $comp is $status.\")\n        logger ! HealthStatus(comp, status)\n      }\n    case _ => println(\"SystemHealthMonitor: Received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    scheduler.cancel()\n    super.postStop()\n  }\n}\n\nclass LoggerActor extends Actor {\n  def receive: Receive = {\n    case HealthStatus(comp, status) => println(s\"Logger: $comp status: $status\")\n    case _ => println(\"Logger: Received unknown message.\")\n  }\n}\n\nobject SystemHealthMonitorApp extends App {\n  val system = ActorSystem(\"HealthMonitorSystem\")\n  val logger = system.actorOf(Props[LoggerActor](), \"loggerActor\")\n  val monitor = system.actorOf(Props(new SystemHealthMonitor(logger)), \"healthMonitorActor\")\n\n  Thread.sleep(10000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named RouterDemoActor that uses a RoundRobinPool router to distribute Job messages to a pool of Worker actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\ncase class Job(data: String)\n\nclass Worker extends Actor {\n  def receive: Receive = {\n    case Job(data) => println(s\"${self.path.name} processing job: $data\")\n    case _ => println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\nobject RouterDemoApp extends App {\n  val system = ActorSystem(\"RouterDemoSystem\")\n  \n  // Create a router with 5 workers using RoundRobinPool\n  val router = system.actorOf(RoundRobinPool(5).props(Props[Worker]()), \"workerRouter\")\n  \n  for (i <- 1 to 10) {\n    router ! Job(s\"Job-$i\")\n  }\n  \n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named BankAccountActor that simulates a bank account. It should handle Deposit, Withdraw, and GetBalance messages, ensuring that withdrawals do not exceed the available balance."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Deposit(amount: Double)\ncase class Withdraw(amount: Double)\ncase object GetBalance\ncase class CurrentBalance(balance: Double)\ncase class InsufficientFunds(amount: Double)\n\nclass BankAccountActor extends Actor {\n  var balance: Double = 0.0\n\n  def receive: Receive = {\n    case Deposit(amount) =>\n      if (amount > 0) {\n        balance += amount\n        println(s\"BankAccountActor: Deposited $$ $amount. New balance: $$ $balance.\")\n      } else {\n        println(\"BankAccountActor: Deposit amount must be positive.\")\n      }\n    case Withdraw(amount) =>\n      if (amount > 0) {\n        if (balance >= amount) {\n          balance -= amount\n          println(s\"BankAccountActor: Withdrew $$ $amount. New balance: $$ $balance.\")\n        } else {\n          println(s\"BankAccountActor: Insufficient funds for withdrawal of $$ $amount.\")\n          sender() ! InsufficientFunds(amount)\n        }\n      } else {\n        println(\"BankAccountActor: Withdrawal amount must be positive.\")\n      }\n    case GetBalance =>\n      sender() ! CurrentBalance(balance)\n    case _ => println(\"BankAccountActor: Received unknown message.\")\n  }\n}\n\nobject BankAccountApp extends App {\n  val system = ActorSystem(\"BankAccountSystem\")\n  val account = system.actorOf(Props[BankAccountActor](), \"bankAccountActor\")\n\n  account ! Deposit(1000)\n  account ! Withdraw(300)\n  account ! Withdraw(800) // This should trigger insufficient funds\n  account ! GetBalance\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AskPatternExampleActor that uses the ask pattern to query a DataActor and prints the response."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase object QueryData\ncase class DataResponse(data: String)\n\nclass DataActor extends Actor {\n  def receive: Receive = {\n    case QueryData =>\n      println(\"DataActor: Received QueryData.\")\n      sender() ! DataResponse(\"Here is your data.\")\n    case _ => println(\"DataActor: Received unknown message.\")\n  }\n}\n\nobject AskPatternExampleApp extends App {\n  val system = ActorSystem(\"AskPatternSystem\")\n  val dataActor = system.actorOf(Props[DataActor](), \"dataActor\")\n\n  implicit val timeout: Timeout = Timeout(3.seconds)\n  val future = dataActor ? QueryData\n  val result = Await.result(future, timeout.duration).asInstanceOf[DataResponse]\n  println(s\"AskPatternExample: Received response -> ${result.data}\")\n\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TemperatureSensorActor that periodically sends temperature readings to a TemperatureAggregatorActor, which calculates and prints the average temperature."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, ActorRef, Props}\nimport scala.concurrent.duration._\nimport scala.util.Random\n\n// Messages for temperature readings and aggregation\ncase class TemperatureReading(sensorId: String, temperature: Double)\ncase object ComputeAverage\n\n// Actor that simulates a temperature sensor by sending random readings\nclass TemperatureSensorActor(sensorId: String, aggregator: ActorRef) extends Actor {\n  import context.dispatcher\n  override def preStart(): Unit = {\n    // Schedule a temperature reading every second\n    context.system.scheduler.scheduleWithFixedDelay(0.seconds, 1.second, self, \"read\")\n  }\n\n  def receive: Receive = {\n    case \"read\" =>\n      val temp = 20 + Random.nextDouble() * 15  // Temperature between 20 and 35\n      println(s\"Sensor $sensorId: Reading temperature: $temp\")\n      aggregator ! TemperatureReading(sensorId, temp)\n    case _ => println(s\"Sensor $sensorId: Received unknown message\")\n  }\n}\n\n// Actor that aggregates temperature readings and computes the average\nclass TemperatureAggregatorActor extends Actor {\n  var readings: List[Double] = Nil\n\n  def receive: Receive = {\n    case TemperatureReading(sensorId, temp) =>\n      readings = temp :: readings\n      println(s\"Aggregator: Received reading from $sensorId: $temp\")\n    case ComputeAverage =>\n      if (readings.nonEmpty) {\n        val avg = readings.sum / readings.size\n        println(f\"Aggregator: Average temperature = $avg%.2f\")\n        readings = Nil  // reset after computing average\n      } else {\n        println(\"Aggregator: No readings to compute average.\")\n      }\n    case _ => println(\"Aggregator: Received unknown message.\")\n  }\n}\n\nobject TemperatureSensorApp extends App {\n  val system = ActorSystem(\"TemperatureSensorSystem\")\n  val aggregator = system.actorOf(Props[TemperatureAggregatorActor](), \"tempAggregator\")\n\n  // Create two temperature sensor actors\n  val sensor1 = system.actorOf(Props(new TemperatureSensorActor(\"Sensor1\", aggregator)), \"sensor1\")\n  val sensor2 = system.actorOf(Props(new TemperatureSensorActor(\"Sensor2\", aggregator)), \"sensor2\")\n\n  // Schedule average computation every 5 seconds\n  import system.dispatcher\n  system.scheduler.scheduleWithFixedDelay(5.seconds, 5.seconds)(new Runnable {\n    def run(): Unit = aggregator ! ComputeAverage\n  })\n\n  Thread.sleep(20000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named FileLoggerActor that logs messages to a file named 'app.log'. It should handle LogMessage messages and append them to the file."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport java.io.{File, FileWriter, BufferedWriter}\nimport scala.util.{Try, Success, Failure}\n\ncase class LogMessage(message: String)\n\nclass FileLoggerActor(logFilePath: String) extends Actor {\n  // Open file in append mode\n  val file = new File(logFilePath)\n  val bw = new BufferedWriter(new FileWriter(file, true))\n\n  def receive: Receive = {\n    case LogMessage(msg) =>\n      Try {\n        bw.write(s\"${java.time.LocalDateTime.now()}: $msg\\n\")\n        bw.flush()\n      } match {\n        case Success(_) => println(s\"FileLoggerActor: Logged message -> $msg\")\n        case Failure(ex) => println(s\"FileLoggerActor: Failed to log message: ${ex.getMessage}\")\n      }\n    case _ => println(\"FileLoggerActor: Received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    bw.close()\n    super.postStop()\n  }\n}\n\nobject FileLoggerApp extends App {\n  val system = ActorSystem(\"FileLoggerSystem\")\n  val fileLogger = system.actorOf(Props(new FileLoggerActor(\"app.log\")), \"fileLogger\")\n\n  fileLogger ! LogMessage(\"Application started\")\n  fileLogger ! LogMessage(\"Processing data...\")\n  fileLogger ! LogMessage(\"Application finished successfully\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named ChatbotActor that changes its behavior using context.become. The actor should respond differently based on whether it is in a greeting state or a conversation state."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class UserMessage(message: String)\ncase object Greet\n\nclass ChatbotActor extends Actor {\n  def receive: Receive = greeting\n\n  def greeting: Receive = {\n    case Greet =>\n      println(\"Chatbot: Hello! How can I assist you today?\")\n      context.become(conversation)\n    case _ => println(\"Chatbot: Please start by greeting me.\")\n  }\n\n  def conversation: Receive = {\n    case UserMessage(msg) => println(s\"Chatbot: You said '$msg'. Let me process that.\")\n    case _ => println(\"Chatbot: I don't understand.\")\n  }\n}\n\nobject ChatbotApp extends App {\n  val system = ActorSystem(\"ChatbotSystem\")\n  val chatbot = system.actorOf(Props[ChatbotActor](), \"chatbotActor\")\n\n  chatbot ! Greet\n  chatbot ! UserMessage(\"I need help with my order.\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named InventoryManagerActor that manages stock for items. It should handle AddStock, RemoveStock, and GetStock messages, replying with StockCount."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class AddStock(item: String, count: Int)\ncase class RemoveStock(item: String, count: Int)\ncase class GetStock(item: String)\ncase class StockCount(item: String, count: Int)\n\nclass InventoryManagerActor extends Actor {\n  var inventory: Map[String, Int] = Map.empty.withDefaultValue(0)\n\n  def receive: Receive = {\n    case AddStock(item, count) =>\n      inventory += (item -> (inventory(item) + count))\n      println(s\"InventoryManager: Added $count of $item. New count: ${inventory(item)}\")\n    case RemoveStock(item, count) =>\n      if (inventory(item) >= count) {\n        inventory += (item -> (inventory(item) - count))\n        println(s\"InventoryManager: Removed $count of $item. New count: ${inventory(item)}\")\n      } else {\n        println(s\"InventoryManager: Not enough $item in stock to remove $count.\")\n      }\n    case GetStock(item) => sender() ! StockCount(item, inventory(item))\n    case _ => println(\"InventoryManager: Received unknown message.\")\n  }\n}\n\nobject InventoryManagerApp extends App {\n  val system = ActorSystem(\"InventorySystem\")\n  val inventoryManager = system.actorOf(Props[InventoryManagerActor](), \"inventoryManager\")\n\n  inventoryManager ! AddStock(\"Widget\", 10)\n  inventoryManager ! RemoveStock(\"Widget\", 3)\n  inventoryManager ! GetStock(\"Widget\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named DirectoryWatcherActor that simulates monitoring a directory for new files. It should handle CheckDirectory messages and simulate detecting new files."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.util.Random\nimport scala.concurrent.duration._\n\ncase object CheckDirectory\ncase class NewFileDetected(fileName: String)\n\nclass DirectoryWatcherActor extends Actor {\n  import context.dispatcher\n  override def preStart(): Unit = {\n    // Schedule a directory check every 2 seconds\n    context.system.scheduler.scheduleWithFixedDelay(0.seconds, 2.seconds, self, CheckDirectory)\n  }\n\n  def receive: Receive = {\n    case CheckDirectory =>\n      // Simulate file detection with a random chance\n      if (Random.nextBoolean()) {\n        val fileName = s\"file_${System.currentTimeMillis()}.txt\"\n        println(s\"DirectoryWatcher: Detected new file: $fileName\")\n        context.parent ! NewFileDetected(fileName)\n      } else {\n        println(\"DirectoryWatcher: No new files detected.\")\n      }\n    case _ => println(\"DirectoryWatcher: Received unknown message.\")\n  }\n}\n\nobject DirectoryWatcherApp extends App {\n  val system = ActorSystem(\"DirectoryWatcherSystem\")\n  val watcher = system.actorOf(Props[DirectoryWatcherActor](), \"directoryWatcher\")\n\n  Thread.sleep(8000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named RandomQuoteActor that responds to GetQuote messages by returning a random quote from a predefined list."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.util.Random\n\ncase object GetQuote\ncase class Quote(text: String)\n\nclass RandomQuoteActor extends Actor {\n  val quotes = List(\n    \"The only limit to our realization of tomorrow is our doubts of today.\",\n    \"Life is 10% what happens to us and 90% how we react to it.\",\n    \"Change your thoughts and you change your world.\"\n  )\n\n  def receive: Receive = {\n    case GetQuote =>\n      val randomQuote = quotes(Random.nextInt(quotes.size))\n      println(s\"RandomQuoteActor: Sending quote: $randomQuote\")\n      sender() ! Quote(randomQuote)\n    case _ => println(\"RandomQuoteActor: Received unknown message.\")\n  }\n}\n\nobject RandomQuoteApp extends App {\n  val system = ActorSystem(\"QuoteSystem\")\n  val quoteActor = system.actorOf(Props[RandomQuoteActor](), \"quoteActor\")\n\n  quoteActor ! GetQuote\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named MergeActor that receives messages from two different sources (Source1Message and Source2Message) and, when it has received one message from each source, merges them and sends a MergedResult message to the original sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase class Source1Message(content: String)\ncase class Source2Message(content: String)\ncase class MergedResult(result: String)\n\nclass MergeActor extends Actor {\n  var source1Data: Option[String] = None\n  var source2Data: Option[String] = None\n  var originalSender: Option[ActorRef] = None\n\n  def receive: Receive = {\n    case Source1Message(content) =>\n      source1Data = Some(content)\n      originalSender = Some(sender())\n      attemptMerge()\n    case Source2Message(content) =>\n      source2Data = Some(content)\n      originalSender = Some(sender())\n      attemptMerge()\n    case _ => println(\"MergeActor: Received unknown message.\")\n  }\n\n  def attemptMerge(): Unit = {\n    (source1Data, source2Data) match {\n      case (Some(data1), Some(data2)) =>\n        val merged = s\"$data1 - $data2\"\n        println(s\"MergeActor: Merged result: $merged\")\n        originalSender.foreach(_ ! MergedResult(merged))\n        // Reset state\n        source1Data = None\n        source2Data = None\n      case _ => // Wait for both messages\n    }\n  }\n}\n\nobject MergeActorApp extends App {\n  val system = ActorSystem(\"MergeSystem\")\n  val mergeActor = system.actorOf(Props[MergeActor](), \"mergeActor\")\n\n  mergeActor ! Source1Message(\"Data from source 1\")\n  mergeActor ! Source2Message(\"Data from source 2\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named WorkflowActor that coordinates a multi-step process. It should spawn two StepActor children to perform steps, and once both steps are complete, it should send a ProcessComplete message to the original sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase object StartProcess\ncase object ProcessComplete\ncase class StepCompleted(step: String)\n\nclass StepActor(stepName: String) extends Actor {\n  def receive: Receive = {\n    case \"execute\" =>\n      println(s\"StepActor: Executing $stepName\")\n      sender() ! StepCompleted(stepName)\n    case _ => println(s\"StepActor: Unknown message in $stepName\")\n  }\n}\n\nclass WorkflowActor extends Actor {\n  var stepsCompleted: Set[String] = Set.empty\n  var originalSender: Option[ActorRef] = None\n\n  def receive: Receive = {\n    case StartProcess =>\n      originalSender = Some(sender())\n      // Create two step actors\n      val step1 = context.actorOf(Props(new StepActor(\"Step1\")), \"step1\")\n      val step2 = context.actorOf(Props(new StepActor(\"Step2\")), \"step2\")\n      step1 ! \"execute\"\n      step2 ! \"execute\"\n    case StepCompleted(step) =>\n      stepsCompleted += step\n      if (stepsCompleted.size == 2) {\n        println(\"WorkflowActor: Process complete.\")\n        originalSender.foreach(_ ! ProcessComplete)\n        stepsCompleted = Set.empty\n      }\n    case _ => println(\"WorkflowActor: Received unknown message.\")\n  }\n}\n\nobject WorkflowActorApp extends App {\n  val system = ActorSystem(\"WorkflowSystem\")\n  val workflow = system.actorOf(Props[WorkflowActor](), \"workflowActor\")\n\n  workflow ! StartProcess\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named UniqueIdGeneratorActor that generates unique IDs upon receiving a GenerateId message. It should reply with GeneratedId containing a unique string."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object GenerateId\ncase class GeneratedId(id: String)\n\nclass UniqueIdGeneratorActor extends Actor {\n  var counter: Int = 0\n\n  def receive: Receive = {\n    case GenerateId =>\n      counter += 1\n      val id = s\"ID-$counter\"\n      println(s\"UniqueIdGenerator: Generated $id\")\n      sender() ! GeneratedId(id)\n    case _ => println(\"UniqueIdGenerator: Received unknown message.\")\n  }\n}\n\nobject UniqueIdGeneratorApp extends App {\n  val system = ActorSystem(\"UniqueIdSystem\")\n  val generator = system.actorOf(Props[UniqueIdGeneratorActor](), \"uniqueIdGenerator\")\n\n  generator ! GenerateId\n  generator ! GenerateId\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named SessionManagerActor that manages user sessions. It should handle CreateSession, EndSession, and GetSession messages, maintaining a map of session IDs to user information."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class CreateSession(userId: String)\ncase class EndSession(sessionId: String)\ncase class GetSession(sessionId: String)\ncase class SessionInfo(sessionId: String, userId: String)\ncase class SessionNotFound(sessionId: String)\n\nclass SessionManagerActor extends Actor {\n  var sessions: Map[String, String] = Map.empty\n  var sessionCounter: Int = 0\n\n  def receive: Receive = {\n    case CreateSession(userId) =>\n      sessionCounter += 1\n      val sessionId = s\"session-$sessionCounter\"\n      sessions += (sessionId -> userId)\n      println(s\"SessionManager: Created session $sessionId for user $userId\")\n      sender() ! SessionInfo(sessionId, userId)\n    case EndSession(sessionId) =>\n      if (sessions.contains(sessionId)) {\n        sessions -= sessionId\n        println(s\"SessionManager: Ended session $sessionId\")\n      } else {\n        println(s\"SessionManager: Session $sessionId not found\")\n        sender() ! SessionNotFound(sessionId)\n      }\n    case GetSession(sessionId) =>\n      sessions.get(sessionId) match {\n        case Some(userId) => sender() ! SessionInfo(sessionId, userId)\n        case None => sender() ! SessionNotFound(sessionId)\n      }\n    case _ => println(\"SessionManager: Received unknown message.\")\n  }\n}\n\nobject SessionManagerApp extends App {\n  val system = ActorSystem(\"SessionManagerSystem\")\n  val sessionManager = system.actorOf(Props[SessionManagerActor](), \"sessionManager\")\n\n  sessionManager ! CreateSession(\"user123\")\n  sessionManager ! GetSession(\"session-1\")\n  sessionManager ! EndSession(\"session-1\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named PaymentProcessorActor that simulates processing a payment. It should handle PaymentRequest messages and, after a delay, respond with either PaymentConfirmation or PaymentFailure."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase class PaymentRequest(orderId: String, amount: Double)\ncase class PaymentConfirmation(orderId: String)\ncase class PaymentFailure(orderId: String, reason: String)\n\nclass PaymentProcessorActor extends Actor {\n  def receive: Receive = {\n    case PaymentRequest(orderId, amount) =>\n      println(s\"PaymentProcessor: Processing payment for order $orderId, amount $$ $amount\")\n      // Simulate a processing delay\n      context.system.scheduler.scheduleOnce(1.second) {\n        if (amount < 1000) {\n          println(s\"PaymentProcessor: Payment for order $orderId confirmed.\")\n          sender() ! PaymentConfirmation(orderId)\n        } else {\n          println(s\"PaymentProcessor: Payment for order $orderId failed due to insufficient funds.\")\n          sender() ! PaymentFailure(orderId, \"Insufficient funds\")\n        }\n      }\n    case _ => println(\"PaymentProcessor: Received unknown message.\")\n  }\n}\n\nobject PaymentProcessorApp extends App {\n  val system = ActorSystem(\"PaymentProcessorSystem\")\n  val processor = system.actorOf(Props[PaymentProcessorActor](), \"paymentProcessor\")\n\n  processor ! PaymentRequest(\"Order1001\", 500)\n  processor ! PaymentRequest(\"Order1002\", 1500)\n\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named MetricsCollectorActor that collects numerical metrics from various sources. It should handle SubmitMetric messages and periodically print a summary of the metrics collected."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.ListBuffer\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase class SubmitMetric(value: Double)\n\nclass MetricsCollectorActor extends Actor {\n  val metrics = ListBuffer[Double]()\n\n  override def preStart(): Unit = {\n    context.system.scheduler.scheduleWithFixedDelay(3.seconds, 3.seconds, self, \"printSummary\")\n  }\n\n  def receive: Receive = {\n    case SubmitMetric(value) =>\n      metrics += value\n      println(s\"MetricsCollector: Received metric: $value\")\n    case \"printSummary\" =>\n      if (metrics.nonEmpty) {\n        val sum = metrics.sum\n        val avg = sum / metrics.size\n        println(f\"MetricsCollector: Collected ${metrics.size} metrics. Sum: $$${sum}%.2f, Average: $$${avg}%.2f\")\n        metrics.clear()\n      } else {\n        println(\"MetricsCollector: No metrics to report.\")\n      }\n    case _ => println(\"MetricsCollector: Received unknown message.\")\n  }\n}\n\nobject MetricsCollectorApp extends App {\n  val system = ActorSystem(\"MetricsCollectorSystem\")\n  val collector = system.actorOf(Props[MetricsCollectorActor](), \"metricsCollector\")\n\n  collector ! SubmitMetric(10.5)\n  collector ! SubmitMetric(20.0)\n  collector ! SubmitMetric(15.5)\n\n  Thread.sleep(10000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an Akka Actor in Scala named NotifierActor that sends a notification when it receives a Notify(user: String, message: String).\nHuman: Add a second message type for group notifications, e.g., NotifyGroup(groupName: String, message: String)."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Notify(user: String, message: String)\n\nclass NotifierActor extends Actor {\n  def receive: Receive = {\n    case Notify(user, msg) =>\n      println(s\"NotifierActor: Sending notification to $user -> $msg\")\n    case _ =>\n      println(\"NotifierActor: Received unknown message.\")\n  }\n}\n\nobject NotifierApp extends App {\n  val system = ActorSystem(\"NotifierSystem\")\n  val notifier = system.actorOf(Props[NotifierActor](), \"notifierActor\")\n\n  notifier ! Notify(\"Alice\", \"You have a new message!\")\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a simple conversation demonstrating a ChatActor that handles Join and Chat messages.\nHuman: Add a Leave(name: String) message and show removing users from the set."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Join(name: String)\ncase class Chat(user: String, message: String)\n\nclass ChatActor extends Actor {\n  var users: Set[String] = Set.empty\n  def receive: Receive = {\n    case Join(name) =>\n      users += name\n      println(s\"ChatActor: $name joined. Current users: $users\")\n    case Chat(user, message) =>\n      println(s\"ChatActor: [$user] $message\")\n    case _ => println(\"ChatActor: Unknown message.\")\n  }\n}\n\nobject ChatApp extends App {\n  val system = ActorSystem(\"ChatSystem\")\n  val chatActor = system.actorOf(Props[ChatActor](), \"chatActor\")\n\n  chatActor ! Join(\"Alice\")\n  chatActor ! Join(\"Bob\")\n  chatActor ! Chat(\"Alice\", \"Hello Bob!\")\n\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a BankAccountActor in Scala that handles Deposit and Withdraw messages, replying with the new balance."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Messages representing bank account actions\ncase class Deposit(amount: Double)\ncase class Withdraw(amount: Double)\n// Reply message containing the updated balance\ncase class UpdatedBalance(balance: Double)\n\n// Actor that manages a simple bank account\nclass BankAccountActor extends Actor {\n  private var balance = 0.0\n\n  def receive: Receive = {\n    case Deposit(amount) =>\n      balance += amount\n      println(s\"BankAccountActor: Deposited $$ $amount, new balance: $$ $balance.\")\n      sender() ! UpdatedBalance(balance)\n\n    case Withdraw(amount) =>\n      if (balance >= amount) {\n        balance -= amount\n        println(s\"BankAccountActor: Withdrew $$ $amount, new balance: $$ $balance.\")\n        sender() ! UpdatedBalance(balance)\n      } else {\n        println(s\"BankAccountActor: Insufficient funds to withdraw $$ $amount.\")\n        sender() ! UpdatedBalance(balance) // Return current balance\n      }\n\n    case _ =>\n      println(\"BankAccountActor: Unknown message.\")\n  }\n}\n\nobject BankAccountApp extends App {\n  val system = ActorSystem(\"BankSystem\")\n  val account = system.actorOf(Props[BankAccountActor](), \"bankAccount\")\n\n  account ! Deposit(100.0)\n  account ! Withdraw(30.0)\n  account ! Withdraw(80.0)\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a BankAccountActor in Scala that handles Deposit and Withdraw messages, replying with the new balance.\nHuman: Add a GetBalance message that returns the current balance."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Deposit(amount: Double)\ncase class Withdraw(amount: Double)\ncase object GetBalance\ncase class UpdatedBalance(balance: Double)\n\nclass BankAccountActor extends Actor {\n  private var balance = 0.0\n\n  def receive: Receive = {\n    case Deposit(amount) =>\n      balance += amount\n      println(s\"BankAccountActor: Deposited $$ $amount, new balance: $$ $balance.\")\n      sender() ! UpdatedBalance(balance)\n\n    case Withdraw(amount) =>\n      if (balance >= amount) {\n        balance -= amount\n        println(s\"BankAccountActor: Withdrew $$ $amount, new balance: $$ $balance.\")\n        sender() ! UpdatedBalance(balance)\n      } else {\n        println(s\"BankAccountActor: Insufficient funds to withdraw $$ $amount.\")\n        sender() ! UpdatedBalance(balance) // Return current balance\n      }\n\n    case GetBalance =>\n      println(s\"BankAccountActor: Returning current balance: $$ $balance.\")\n      sender() ! UpdatedBalance(balance)\n\n    case _ =>\n      println(\"BankAccountActor: Unknown message.\")\n  }\n}\n\nobject BankAccountApp extends App {\n  val system = ActorSystem(\"BankSystem\")\n  val account = system.actorOf(Props[BankAccountActor](), \"bankAccount\")\n\n  // Various operations\n  account ! Deposit(100.0)\n  account ! Withdraw(30.0)\n  account ! GetBalance\n  account ! Withdraw(80.0)\n  account ! GetBalance\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ToggleActor in Scala that switches behavior using context.become. Then allow a second conversation to add a new command."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Command to toggle the state\ncase object Toggle\n// Regular string messages\ncase class Msg(content: String)\n\nclass ToggleActor extends Actor {\n  // Start in active state\n  def receive: Receive = active\n\n  def active: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from active to inactive.\")\n      context.become(inactive)\n    case Msg(content) =>\n      println(s\"ToggleActor (active) got -> $content\")\n    case _ =>\n      println(\"ToggleActor (active) received an unknown message.\")\n  }\n\n  def inactive: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from inactive to active.\")\n      context.become(active)\n    case Msg(content) =>\n      println(s\"ToggleActor (inactive) got -> $content\")\n    case _ =>\n      println(\"ToggleActor (inactive) received an unknown message.\")\n  }\n}\n\nobject ToggleApp extends App {\n  val system = ActorSystem(\"ToggleSystem\")\n  val toggler = system.actorOf(Props[ToggleActor](), \"toggleActor\")\n\n  toggler ! Msg(\"Hello in active mode.\")\n  toggler ! Toggle\n  toggler ! Msg(\"Now I'm in inactive mode.\")\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ToggleActor in Scala that switches behavior using context.become. Then allow a second conversation to add a new command.\nHuman: Add a new Reset command that always returns the actor to the active state, regardless of its current state."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Toggle\ncase object Reset\ncase class Msg(content: String)\n\nclass ToggleActor extends Actor {\n  // Start in active state\n  def receive: Receive = active\n\n  def active: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from active to inactive.\")\n      context.become(inactive)\n    case Reset =>\n      println(\"ToggleActor: Already active, staying active.\")\n      // Remain in the same active state\n    case Msg(content) =>\n      println(s\"ToggleActor (active) got -> $content\")\n    case _ =>\n      println(\"ToggleActor (active) received unknown message.\")\n  }\n\n  def inactive: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from inactive to active.\")\n      context.become(active)\n    case Reset =>\n      println(\"ToggleActor: Reset invoked, going to active.\")\n      context.become(active)\n    case Msg(content) =>\n      println(s\"ToggleActor (inactive) got -> $content\")\n    case _ =>\n      println(\"ToggleActor (inactive) received unknown message.\")\n  }\n}\n\nobject ToggleApp extends App {\n  val system = ActorSystem(\"ToggleSystem\")\n  val toggler = system.actorOf(Props[ToggleActor](), \"toggleActor\")\n\n  toggler ! Msg(\"Hello in active mode.\")\n  toggler ! Toggle\n  toggler ! Msg(\"Now I'm in inactive mode.\")\n\n  // Use Reset to go back to active no matter what\n  toggler ! Reset\n  toggler ! Msg(\"Back in active mode.\")\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a HelloActor in Scala that logs a 'Hello, Actor!' message whenever it receives a Greet message. Add detailed comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message to trigger a greeting\ncase object Greet\n\n// Actor that prints a greeting when it receives a Greet message\nclass HelloActor extends Actor {\n  // Define how the actor handles incoming messages\n  def receive: Receive = {\n    // If the message is Greet, log a greeting\n    case Greet =>\n      println(\"HelloActor: Hello, Actor!\")\n    // Otherwise, log unknown messages\n    case _ =>\n      println(\"HelloActor: Unknown message received.\")\n  }\n}\n\nobject HelloActorApp extends App {\n  // Create an ActorSystem named \"HelloSystem\"\n  val system = ActorSystem(\"HelloSystem\")\n  // Create an instance of HelloActor\n  val helloActor = system.actorOf(Props[HelloActor](), \"helloActor\")\n\n  // Send the Greet message\n  helloActor ! Greet\n\n  // Pause briefly, then terminate the system\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CountingActor in Scala that increments its counter each time it receives Increment, and logs its current count."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message to increment the counter\ncase object Increment\n\n// Actor that keeps track of how many increments it has seen\nclass CountingActor extends Actor {\n  // Internal counter, starts at zero\n  private var count = 0\n\n  def receive: Receive = {\n    // If we get Increment, increase count and log it\n    case Increment =>\n      count += 1\n      println(s\"CountingActor: Count is now $count\")\n    // If unknown message, log that it's unknown\n    case _ =>\n      println(\"CountingActor: Received unknown message.\")\n  }\n}\n\nobject CountingActorApp extends App {\n  // Create an ActorSystem named \"CountingSystem\"\n  val system = ActorSystem(\"CountingSystem\")\n  // Create an instance of CountingActor\n  val counter = system.actorOf(Props[CountingActor](), \"counter\")\n\n  // Send multiple increments\n  counter ! Increment\n  counter ! Increment\n  counter ! Increment\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an AggregationActor in Scala that sends tasks to two workers and aggregates their results, with comments explaining each step."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// A task to distribute\ncase class Task(data: String)\n// Workers respond with partial results\ncase class PartialResult(result: String)\n// AggregationActor sends back an aggregated message\ncase class AggregatedResult(content: String)\n\n// WorkerActor that processes a Task and returns PartialResult\nclass WorkerActor(workerId: Int) extends Actor {\n  def receive: Receive = {\n    case Task(data) =>\n      // Process the task in some faked manner\n      val outcome = s\"Worker-$workerId processed: $data\"\n      println(outcome)\n      sender() ! PartialResult(outcome)\n    case _ => println(s\"Worker-$workerId: Unknown message.\")\n  }\n}\n\n// AggregationActor that coordinates two workers and combines their results\nclass AggregationActor(worker1: ActorRef, worker2: ActorRef) extends Actor {\n  private var responses = List.empty[String]\n  private var pendingCount = 0\n  private var originalSender: Option[ActorRef] = None\n\n  def receive: Receive = {\n    case task: Task =>\n      responses = Nil\n      pendingCount = 2\n      originalSender = Some(sender())\n      // Send the same task to both workers\n      worker1 ! task\n      worker2 ! task\n\n    case PartialResult(res) =>\n      responses = res :: responses\n      pendingCount -= 1\n      if (pendingCount == 0) {\n        val aggregated = responses.reverse.mkString(\" | \")\n        println(s\"AggregationActor: Aggregated -> $aggregated\")\n        originalSender.foreach(_ ! AggregatedResult(aggregated))\n      }\n\n    case _ => println(\"AggregationActor: Unknown message.\")\n  }\n}\n\nobject AggregationApp extends App {\n  val system = ActorSystem(\"AggregationSystem\")\n\n  val w1 = system.actorOf(Props(new WorkerActor(1)), \"worker1\")\n  val w2 = system.actorOf(Props(new WorkerActor(2)), \"worker2\")\n\n  val aggregator = system.actorOf(Props(new AggregationActor(w1, w2)), \"aggregator\")\n\n  aggregator ! Task(\"Compute something.\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a StashingActor that stashes messages until it receives an Initialize message, with clarity in the code comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\ncase object Initialize\ncase class DataMsg(content: String)\n\n// StashingActor that buffers DataMsg until initialization\nclass StashingActor extends Actor with Stash {\n  def receive: Receive = uninitialized\n\n  def uninitialized: Receive = {\n    case Initialize =>\n      println(\"StashingActor: Actor initialized, unstashing.\")\n      unstashAll() // Process all stashed messages\n      context.become(initialized)\n\n    case otherMsg =>\n      // Stash everything before we are initialized\n      println(s\"StashingActor: Stashing -> $otherMsg\")\n      stash()\n  }\n\n  def initialized: Receive = {\n    case DataMsg(content) =>\n      println(s\"StashingActor: Processing -> $content\")\n    case _ =>\n      println(\"StashingActor (initialized): Unknown message.\")\n  }\n}\n\nobject StashingActorApp extends App {\n  val system = ActorSystem(\"StashingSystem\")\n  val stasher = system.actorOf(Props[StashingActor](), \"stasher\")\n\n  // Send some data before initialization\n  stasher ! DataMsg(\"data1\")\n  stasher ! DataMsg(\"data2\")\n\n  // Now initialize\n  stasher ! Initialize\n\n  // Send data after initialization\n  stasher ! DataMsg(\"data3\")\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SupervisorActor in Scala that restarts a child on runtime exceptions, with detailed comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy.{Restart, Stop}\nimport scala.concurrent.duration._\n\ncase object FailNow\n\n// A child that throws an error on FailNow\nclass PotentiallyFailingChild extends Actor {\n  def receive: Receive = {\n    case FailNow =>\n      println(s\"PotentiallyFailingChild [${self.path.name}] is failing now!\")\n      throw new RuntimeException(\"Forced child failure.\")\n    case msg =>\n      println(s\"PotentiallyFailingChild [${self.path.name}] received -> $msg\")\n  }\n}\n\n// SupervisorActor with a custom supervision strategy\nclass SupervisorActor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(maxNrOfRetries = 2, withinTimeRange = 1.minute) {\n    case _: RuntimeException =>\n      println(\"SupervisorActor: Restarting child after runtime exception.\")\n      Restart\n    case _ => Stop\n  }\n\n  // Create the child\n  val child = context.actorOf(Props[PotentiallyFailingChild](), \"failingChild\")\n\n  def receive: Receive = {\n    // Forward all messages to the child\n    case msg => child.forward(msg)\n  }\n}\n\nobject SupervisorApp extends App {\n  val system = ActorSystem(\"SupervisorSystem\")\n  val supervisor = system.actorOf(Props[SupervisorActor](), \"supervisor\")\n\n  supervisor ! \"Normal message\"\n  supervisor ! FailNow\n  supervisor ! \"Check if child restarted\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ToggleActor in Scala that uses context.become to switch between active and inactive, with a short explanation."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Toggle\ncase class Message(text: String)\n\nclass ToggleActor extends Actor {\n  // Begin in active state\n  def receive: Receive = active\n\n  def active: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from active to inactive.\")\n      context.become(inactive)\n    case Message(text) =>\n      println(s\"ToggleActor (active) got -> $text\")\n    case _ => println(\"ToggleActor (active): Unknown message.\")\n  }\n\n  def inactive: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from inactive to active.\")\n      context.become(active)\n    case Message(text) =>\n      println(s\"ToggleActor (inactive) got -> $text\")\n    case _ => println(\"ToggleActor (inactive): Unknown message.\")\n  }\n}\n\nobject ToggleActorApp extends App {\n  val system = ActorSystem(\"ToggleActorSystem\")\n  val toggle = system.actorOf(Props[ToggleActor](), \"toggleActor\")\n\n  toggle ! Message(\"Hello in active.\")\n  toggle ! Toggle\n  toggle ! Message(\"Now I'm inactive.\")\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ForwardingActor that preserves the original sender, using forward. Keep comments clear and concise."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// DestinationActor logs any message with its sender\nclass DestinationActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"DestinationActor: Received '$msg' from ${sender().path.name}\")\n  }\n}\n\n// ForwardingActor forwards messages to the destination using 'forward'\nclass ForwardingActor(dest: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ForwardingActor: Forwarding '$msg'\")\n      dest.forward(msg)\n  }\n}\n\nobject ForwardingApp extends App {\n  val system = ActorSystem(\"ForwardingSystem\")\n\n  // Create the destination actor\n  val destination = system.actorOf(Props[DestinationActor](), \"destinationActor\")\n\n  // Create the forwarding actor\n  val forwarder = system.actorOf(Props(new ForwardingActor(destination)), \"forwarder\")\n\n  // Create a test sender to see if original sender is preserved\n  val testSender = system.actorOf(Props(new Actor {\n    def receive: Receive = {\n      case response =>\n        println(s\"TestSender: Got response -> $response\")\n    }\n  }), \"testSender\")\n\n  // Send a message from testSender\n  forwarder.tell(\"Hello, destination!\", testSender)\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a PriorityActor that always processes PriorityMessage before NormalMessage, even if NormalMessage was enqueued first."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\ncase object PriorityMessage\ncase object NormalMessage\n\n// PriorityActor uses stashing to ensure priority messages are processed first\nclass PriorityActor extends Actor with Stash {\n  def receive: Receive = {\n    case PriorityMessage =>\n      // Process priority immediately\n      println(\"PriorityActor: Processing PRIORITY message.\")\n      unstashAll()\n    case NormalMessage =>\n      // Stash normal messages until a priority is handled\n      println(\"PriorityActor: Stashing NORMAL message.\")\n      stash()\n    case _ =>\n      println(\"PriorityActor: Unknown message.\")\n  }\n}\n\nobject PriorityActorApp extends App {\n  val system = ActorSystem(\"PrioritySystem\")\n  val actor = system.actorOf(Props[PriorityActor](), \"priorityActor\")\n\n  // Send normal messages first\n  actor ! NormalMessage\n  actor ! NormalMessage\n  // Then send a priority message\n  actor ! PriorityMessage\n  // Then another normal message\n  actor ! NormalMessage\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RouterActor that uses RoundRobinPool with 3 WorkerActor instances. Provide a moderate number of comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\ncase class Work(job: String)\n\nclass WorkerActor extends Actor {\n  def receive: Receive = {\n    case Work(job) =>\n      println(s\"${self.path.name} working on: $job\")\n    case _ =>\n      println(s\"${self.path.name} received an unknown message.\")\n  }\n}\n\nobject RouterActorApp extends App {\n  val system = ActorSystem(\"RouterSystem\")\n\n  // Create a router with 3 workers\n  val router = system.actorOf(\n    RoundRobinPool(3).props(Props[WorkerActor]()),\n    \"workerRouter\"\n  )\n\n  // Send multiple tasks\n  for (i <- 1 to 5) {\n    router ! Work(s\"Task-$i\")\n  }\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ToggleFSM actor in Scala using the FSM trait that toggles between On and Off states every second. Include detailed comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{ActorSystem, Props, FSM}\nimport scala.concurrent.duration._\n\n// Define possible states\nsealed trait SwitchState\ncase object On extends SwitchState\ncase object Off extends SwitchState\n\n// Define data type (here we don't use any extra data)\nsealed trait SwitchData\ncase object Uninitialized extends SwitchData\n\n// ToggleFSM actor that switches state every second\nclass ToggleFSM extends FSM[SwitchState, SwitchData] {\n  // Start in Off state\n  startWith(Off, Uninitialized)\n\n  // In Off state, after 1 second, transition to On\n  when(Off, stateTimeout = 1.second) {\n    case Event(StateTimeout, _) =>\n      println(\"ToggleFSM: Switching from Off to On\")\n      goto(On)\n  }\n\n  // In On state, after 1 second, transition back to Off\n  when(On, stateTimeout = 1.second) {\n    case Event(StateTimeout, _) =>\n      println(\"ToggleFSM: Switching from On to Off\")\n      goto(Off)\n  }\n\n  // Initialize the FSM\n  initialize()\n}\n\nobject ToggleFSMApp extends App {\n  val system = ActorSystem(\"ToggleFSMSystem\")\n  val fsmActor = system.actorOf(Props[ToggleFSM](), \"toggleFSM\")\n\n  // Let the FSM run for a few seconds\n  Thread.sleep(5000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ParentActor in Scala that creates child actors and sends them messages using the ! operator. Do not call methods directly on ActorRefs. Include comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Message for children\ncase class ChildMsg(content: String)\n\n// ChildActor simply prints any received ChildMsg\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case ChildMsg(content) => println(s\"${self.path.name} received: $content\")\n    case _ => println(s\"${self.path.name} received an unknown message\")\n  }\n}\n\n// ParentActor creates two child actors and forwards ChildMsg messages to them\nclass ParentActor extends Actor {\n  // Create child actors and store their ActorRefs\n  val child1: ActorRef = context.actorOf(Props[ChildActor](), \"child1\")\n  val child2: ActorRef = context.actorOf(Props[ChildActor](), \"child2\")\n\n  def receive: Receive = {\n    case msg: ChildMsg =>\n      // Send the message to both children using the ! operator\n      child1 ! msg\n      child2 ! msg\n    case _ => println(\"ParentActor: Received an unknown message\")\n  }\n}\n\nobject ParentActorApp extends App {\n  val system = ActorSystem(\"ParentSystem\")\n  val parent = system.actorOf(Props[ParentActor](), \"parentActor\")\n\n  // Send a message to the parent actor which it forwards to its children\n  parent ! ChildMsg(\"Hello, children!\")\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SafeStringActor in Scala that safely converts a message to lower case, only if it is a String. Include comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// SafeStringActor processes messages only if they are Strings\nclass SafeStringActor extends Actor {\n  def receive: Receive = {\n    // Pattern match to ensure msg is a String before calling toLowerCase\n    case msg: String =>\n      val lower = msg.toLowerCase\n      println(s\"SafeStringActor processed: $lower\")\n    case _ =>\n      println(\"SafeStringActor: Received non-string message\")\n  }\n}\n\nobject SafeStringActorApp extends App {\n  val system = ActorSystem(\"SafeStringSystem\")\n  val safeActor = system.actorOf(Props[SafeStringActor](), \"safeActor\")\n\n  safeActor ! \"HeLLo WorLD\"\n  safeActor ! 123  // This will trigger the non-string case\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an InitializationActor in Scala that demonstrates proper usage of immutable vals by initializing configuration in preStart and never reassigning it. Include comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// InitializationActor uses an immutable val for configuration\nclass InitializationActor extends Actor {\n  // Immutable configuration value; it is set only once\n  val configValue: String = \"InitialConfig\"\n\n  override def preStart(): Unit = {\n    println(s\"InitializationActor starting with config: $configValue\")\n  }\n\n  def receive: Receive = {\n    case \"getConfig\" =>\n      // Respond with the configuration value\n      sender() ! configValue\n    case _ => println(\"InitializationActor: Received unknown message\")\n  }\n}\n\nobject InitializationActorApp extends App {\n  val system = ActorSystem(\"InitSystem\")\n  val initActor = system.actorOf(Props[InitializationActor](), \"initActor\")\n\n  initActor ! \"getConfig\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ScheduledActor in Scala that uses context.system.scheduler.scheduleWithFixedDelay to send itself a tick message every second. Include clear comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// ScheduledActor schedules a 'tick' message to itself every second\nclass ScheduledActor extends Actor {\n  var cancellable: Cancellable = _\n\n  override def preStart(): Unit = {\n    // Schedule 'tick' every 1 second, starting immediately\n    cancellable = context.system.scheduler.scheduleWithFixedDelay(0.seconds, 1.second, self, \"tick\")\n  }\n\n  def receive: Receive = {\n    case \"tick\" => println(\"ScheduledActor: Tick received\")\n    case _ => println(\"ScheduledActor: Unknown message\")\n  }\n\n  override def postStop(): Unit = {\n    // Cancel the scheduled task when the actor stops\n    cancellable.cancel()\n  }\n}\n\nobject ScheduledActorApp extends App {\n  val system = ActorSystem(\"ScheduledSystem\")\n  val actor = system.actorOf(Props[ScheduledActor](), \"scheduledActor\")\n\n  // Let the actor run for 3 seconds before terminating\n  Thread.sleep(3000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create two actors, PingActor and PongActor, where PingActor sends 'Ping' and PongActor responds with 'Pong'."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase object Ping\ncase object Pong\n\n// PingActor sends a Ping to PongActor and expects a Pong back\nclass PingActor(pong: ActorRef) extends Actor {\n  override def preStart(): Unit = {\n    pong ! Ping\n  }\n  \n  def receive: Receive = {\n    case Pong =>\n      println(\"PingActor: Received Pong, sending Ping again.\")\n      pong ! Ping\n    case _ => println(\"PingActor: Unknown message received.\")\n  }\n}\n\n// PongActor responds with Pong when it receives Ping\nclass PongActor extends Actor {\n  def receive: Receive = {\n    case Ping =>\n      println(\"PongActor: Received Ping, replying with Pong.\")\n      sender() ! Pong\n    case _ => println(\"PongActor: Unknown message received.\")\n  }\n}\n\nobject PingPongApp extends App {\n  val system = ActorSystem(\"PingPongSystem\")\n  val pongActor = system.actorOf(Props[PongActor](), \"pongActor\")\n  val pingActor = system.actorOf(Props(new PingActor(pongActor)), \"pingActor\")\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ChildWatcher actor in Scala that watches a child actor and logs when it terminates."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Terminated}\n\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"ChildActor received: $msg\")\n  }\n}\n\nclass ChildWatcher extends Actor {\n  // Create a child and start watching it\n  val child = context.actorOf(Props[ChildActor](), \"childActor\")\n  context.watch(child)\n  \n  def receive: Receive = {\n    case msg => child ! msg\n    case Terminated(ref) => println(s\"ChildWatcher: Child $ref terminated\")\n  }\n}\n\nobject ChildWatcherApp extends App {\n  val system = ActorSystem(\"ChildWatcherSystem\")\n  val watcher = system.actorOf(Props[ChildWatcher](), \"watcher\")\n  watcher ! \"Hello Child\"\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an AskPatternActor in Scala that uses the ask pattern to request a greeting from a Responder actor and prints the response."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\n\ncase class Greet(name: String)\ncase class Greeting(message: String)\n\nclass Responder extends Actor {\n  def receive: Receive = {\n    case Greet(name) => sender() ! Greeting(s\"Hello, $name!\")\n  }\n}\n\nobject AskPatternActorApp extends App {\n  val system = ActorSystem(\"AskPatternSystem\")\n  val responder = system.actorOf(Props[Responder](), \"responder\")\n  implicit val timeout: Timeout = Timeout(2.seconds)\n  \n  val future = responder ? Greet(\"Alice\")\n  val result = Await.result(future, timeout.duration).asInstanceOf[Greeting]\n  println(s\"Received greeting: ${result.message}\")\n  \n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ConfigurableActor in Scala that reads a configuration value from the ActorSystem's config and logs it."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ConfigurableActor extends Actor {\n  // Read configuration from the ActorSystem's config\n  val configValue: String = context.system.settings.config.getString(\"myapp.configValue\")\n  \n  override def preStart(): Unit = {\n    println(s\"ConfigurableActor starting with config: $configValue\")\n  }\n  \n  def receive: Receive = {\n    case _ => println(\"ConfigurableActor: Received message\")\n  }\n}\n\nobject ConfigurableActorApp extends App {\n  val system = ActorSystem(\"ConfigSystem\")\n  val actor = system.actorOf(Props[ConfigurableActor](), \"configActor\")\n  actor ! \"test\"\n  Thread.sleep(500)\n  system.terminate()\n}\n\n// Note: Ensure your configuration file (application.conf) contains:\n// myapp.configValue = \"SomeConfig\"\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SchedulerWithCancel actor in Scala that schedules a periodic message and cancels it after 3 messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase object Tick\n\nclass SchedulerWithCancel extends Actor {\n  var tickCount = 0\n  var scheduler: Cancellable = _\n\n  override def preStart(): Unit = {\n    scheduler = context.system.scheduler.scheduleWithFixedDelay(0.seconds, 1.second, self, Tick)\n  }\n\n  def receive: Receive = {\n    case Tick =>\n      tickCount += 1\n      println(s\"SchedulerWithCancel: Tick $tickCount\")\n      if (tickCount >= 3) scheduler.cancel()\n  }\n}\n\nobject SchedulerWithCancelApp extends App {\n  val system = ActorSystem(\"SchedulerSystem\")\n  val actor = system.actorOf(Props[SchedulerWithCancel](), \"schedulerActor\")\n  Thread.sleep(4000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an AdvancedStashingActor in Scala that stashes messages until it receives a 'Start' message, then processes all stashed messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\ncase object Start\ncase class Work(task: String)\n\nclass AdvancedStashingActor extends Actor with Stash {\n  def receive: Receive = waiting\n\n  def waiting: Receive = {\n    case Start =>\n      println(\"AdvancedStashingActor: Received Start, unstashing messages.\")\n      unstashAll()\n      context.become(working)\n    case msg =>\n      println(s\"AdvancedStashingActor: Stashing message $msg\")\n      stash()\n  }\n\n  def working: Receive = {\n    case Work(task) => println(s\"AdvancedStashingActor: Processing task $task\")\n    case _ => println(\"AdvancedStashingActor (working): Unknown message\")\n  }\n}\n\nobject AdvancedStashingActorApp extends App {\n  val system = ActorSystem(\"AdvancedStashSystem\")\n  val actor = system.actorOf(Props[AdvancedStashingActor](), \"advStashActor\")\n  \n  actor ! Work(\"Task1\")\n  actor ! Work(\"Task2\")\n  actor ! Start\n  actor ! Work(\"Task3\")\n  \n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RouterGroupActor in Scala that uses a group router to send messages to a set of predefined worker actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.routing.BroadcastGroup\n\ncase class Task(job: String)\n\nclass GroupWorker extends Actor {\n  def receive: Receive = {\n    case Task(job) => println(s\"${self.path.name} processing: $job\")\n    case _ => println(s\"${self.path.name} received unknown message\")\n  }\n}\n\nobject RouterGroupActorApp extends App {\n  val system = ActorSystem(\"RouterGroupSystem\")\n  // Create worker actors and get their paths\n  val worker1 = system.actorOf(Props[GroupWorker](), \"worker1\")\n  val worker2 = system.actorOf(Props[GroupWorker](), \"worker2\")\n  val worker3 = system.actorOf(Props[GroupWorker](), \"worker3\")\n\n  // Define the paths for the group router\n  val paths = List(\n    worker1.path.toStringWithoutAddress,\n    worker2.path.toStringWithoutAddress,\n    worker3.path.toStringWithoutAddress\n  )\n  val router = system.actorOf(BroadcastGroup(paths).props(), \"groupRouter\")\n\n  router ! Task(\"Group Task\")\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CustomSupervisorStrategyActor in Scala that applies a custom strategy to restart its child on IllegalArgumentException."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy.{Restart, Escalate}\nimport scala.concurrent.duration._\n\ncase object TriggerFailure\n\nclass ChildForSupervision extends Actor {\n  def receive: Receive = {\n    case TriggerFailure => throw new IllegalArgumentException(\"Forced failure\")\n    case msg => println(s\"ChildForSupervision received: $msg\")\n  }\n}\n\nclass CustomSupervisorStrategyActor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(maxNrOfRetries = 3, withinTimeRange = 1.minute) {\n    case _: IllegalArgumentException =>\n      println(\"CustomSupervisorStrategyActor: Restarting child due to IllegalArgumentException\")\n      Restart\n    case _ => Escalate\n  }\n\n  val child = context.actorOf(Props[ChildForSupervision](), \"supervisedChild\")\n  def receive: Receive = {\n    case msg => child.forward(msg)\n  }\n}\n\nobject CustomSupervisorStrategyActorApp extends App {\n  val system = ActorSystem(\"CustomSupervisorSystem\")\n  val supervisor = system.actorOf(Props[CustomSupervisorStrategyActor](), \"customSupervisor\")\n  supervisor ! TriggerFailure\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a TransformingActor in Scala that transforms any received String to uppercase before printing it."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass TransformingActor extends Actor {\n  def receive: Receive = {\n    case msg: String => println(s\"Transformed: ${msg.toUpperCase}\")\n    case _ => println(\"TransformingActor: Unknown message\")\n  }\n}\n\nobject TransformingActorApp extends App {\n  val system = ActorSystem(\"TransformingSystem\")\n  val transformer = system.actorOf(Props[TransformingActor](), \"transformer\")\n  transformer ! \"hello, actor\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a PipeToActor in Scala that uses akka.pattern.pipe to forward the result of a Future to itself."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.pipe\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration._\n\nclass PipeToActor extends Actor {\n  def receive: Receive = {\n    case \"start\" =>\n      val futureResult = Future {\n        Thread.sleep(200)\n        \"Future result\"\n      }\n      // Pipe the result of the future to self\n      futureResult pipeTo self\n    case result: String => println(s\"PipeToActor received: $result\")\n    case _ => println(\"PipeToActor: Unknown message\")\n  }\n}\n\nobject PipeToActorApp extends App {\n  val system = ActorSystem(\"PipeToSystem\")\n  val actor = system.actorOf(Props[PipeToActor](), \"pipeActor\")\n  actor ! \"start\"\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RecoveryActor in Scala that catches exceptions in its receive method and logs a recovery message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass RecoveryActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      try {\n        if (msg == \"fail\") throw new RuntimeException(\"Failure triggered\")\n        println(s\"RecoveryActor processed: $msg\")\n      } catch {\n        case ex: Exception => println(s\"RecoveryActor recovered from error: ${ex.getMessage}\")\n      }\n    case _ => println(\"RecoveryActor: Unknown message\")\n  }\n}\n\nobject RecoveryActorApp extends App {\n  val system = ActorSystem(\"RecoverySystem\")\n  val actor = system.actorOf(Props[RecoveryActor](), \"recoveryActor\")\n  actor ! \"test\"\n  actor ! \"fail\"\n  actor ! \"continue\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a BehaviorSwitchActor in Scala that uses context.become to switch between 'normal' and 'alert' modes based on messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass BehaviorSwitchActor extends Actor {\n  def receive: Receive = normal\n\n  def normal: Receive = {\n    case \"alert\" =>\n      println(\"BehaviorSwitchActor: Switching to alert mode\")\n      context.become(alert)\n    case msg => println(s\"Normal mode processing: $msg\")\n  }\n\n  def alert: Receive = {\n    case \"reset\" =>\n      println(\"BehaviorSwitchActor: Returning to normal mode\")\n      context.become(normal)\n    case msg => println(s\"Alert mode processing: $msg\")\n  }\n}\n\nobject BehaviorSwitchActorApp extends App {\n  val system = ActorSystem(\"BehaviorSwitchSystem\")\n  val actor = system.actorOf(Props[BehaviorSwitchActor](), \"behaviorSwitch\")\n  actor ! \"hello\"\n  actor ! \"alert\"\n  actor ! \"warning\"\n  actor ! \"reset\"\n  actor ! \"back to normal\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ReplyActor in Scala that replies to every message with 'Received: ' followed by the message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ReplyActor extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! s\"Received: $msg\"\n  }\n}\n\nobject ReplyActorApp extends App {\n  val system = ActorSystem(\"ReplySystem\")\n  val actor = system.actorOf(Props[ReplyActor](), \"replyActor\")\n  actor.tell(\"test message\", actor) // using self as sender for demonstration\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a TupleResponseActor in Scala that replies with a tuple (message, length) when it receives a String."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass TupleResponseActor extends Actor {\n  def receive: Receive = {\n    case msg: String => sender() ! (msg, msg.length)\n    case _ => println(\"TupleResponseActor: Unknown message\")\n  }\n}\n\nobject TupleResponseActorApp extends App {\n  val system = ActorSystem(\"TupleResponseSystem\")\n  val actor = system.actorOf(Props[TupleResponseActor](), \"tupleActor\")\n  actor.tell(\"Hello\", actor)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SelfSchedulingActor in Scala that uses context.system.scheduler.scheduleOnce to send itself a delayed message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass SelfSchedulingActor extends Actor {\n  override def preStart(): Unit = {\n    // Schedule a one-off message after 1 second\n    context.system.scheduler.scheduleOnce(1.second, self, \"delayed\")\n  }\n\n  def receive: Receive = {\n    case \"delayed\" => println(\"SelfSchedulingActor: Received delayed message\")\n    case _ => println(\"SelfSchedulingActor: Unknown message\")\n  }\n}\n\nobject SelfSchedulingActorApp extends App {\n  val system = ActorSystem(\"SelfSchedulingSystem\")\n  val actor = system.actorOf(Props[SelfSchedulingActor](), \"selfScheduler\")\n  Thread.sleep(1500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ProgressActor in Scala that simulates long processing by printing progress messages every 200ms."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass ProgressActor extends Actor {\n  def receive: Receive = {\n    case \"start\" =>\n      (1 to 5).foreach { i =>\n        context.system.scheduler.scheduleOnce(i * 200.milliseconds) {\n          println(s\"ProgressActor: Step $i completed\")\n        }\n      }\n    case _ => println(\"ProgressActor: Unknown message\")\n  }\n}\n\nobject ProgressActorApp extends App {\n  val system = ActorSystem(\"ProgressSystem\")\n  val actor = system.actorOf(Props[ProgressActor](), \"progressActor\")\n  actor ! \"start\"\n  Thread.sleep(1500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a MultiTypeMatcherActor in Scala that handles Int, String, and a custom message type differently."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class CustomMsg(info: String)\n\nclass MultiTypeMatcherActor extends Actor {\n  def receive: Receive = {\n    case i: Int => println(s\"Received an Int: $i\")\n    case s: String => println(s\"Received a String: $s\")\n    case CustomMsg(info) => println(s\"Received CustomMsg: $info\")\n    case _ => println(\"Unknown message type\")\n  }\n}\n\nobject MultiTypeMatcherActorApp extends App {\n  val system = ActorSystem(\"MultiTypeSystem\")\n  val actor = system.actorOf(Props[MultiTypeMatcherActor](), \"multiMatcher\")\n  actor ! 42\n  actor ! \"Hello\"\n  actor ! CustomMsg(\"Custom info\")\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an ImplicitExecutionContextActor in Scala that uses the implicit execution context to run a Future."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.Future\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass ImplicitExecutionContextActor extends Actor {\n  def receive: Receive = {\n    case \"run\" =>\n      Future {\n        Thread.sleep(200)\n        \"Future completed\"\n      } map { result =>\n        println(result)\n      }\n    case _ => println(\"ImplicitExecutionContextActor: Unknown message\")\n  }\n}\n\nobject ImplicitExecutionContextActorApp extends App {\n  val system = ActorSystem(\"ImplicitECSystem\")\n  val actor = system.actorOf(Props[ImplicitExecutionContextActor](), \"implicitECActor\")\n  actor ! \"run\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SelfStoppingActor in Scala that stops itself when it receives a 'stop' message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass SelfStoppingActor extends Actor {\n  def receive: Receive = {\n    case \"stop\" =>\n      println(\"SelfStoppingActor: Stopping now\")\n      context.stop(self)\n    case msg => println(s\"SelfStoppingActor: Received $msg\")\n  }\n}\n\nobject SelfStoppingActorApp extends App {\n  val system = ActorSystem(\"SelfStoppingSystem\")\n  val actor = system.actorOf(Props[SelfStoppingActor](), \"selfStopper\")\n  actor ! \"hello\"\n  actor ! \"stop\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a LifecycleHookActor in Scala that demonstrates preRestart and postRestart methods."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass LifecycleHookActor extends Actor {\n  override def preRestart(reason: Throwable, message: Option[Any]): Unit = {\n    println(s\"LifecycleHookActor: preRestart due to ${reason.getMessage}\")\n    super.preRestart(reason, message)\n  }\n\n  override def postRestart(reason: Throwable): Unit = {\n    println(\"LifecycleHookActor: postRestart\")\n    super.postRestart(reason)\n  }\n\n  def receive: Receive = {\n    case \"fail\" => throw new Exception(\"Failure triggered\")\n    case msg => println(s\"LifecycleHookActor: Received $msg\")\n  }\n}\n\nobject LifecycleHookActorApp extends App {\n  val system = ActorSystem(\"LifecycleHookSystem\")\n  val actor = system.actorOf(Props[LifecycleHookActor](), \"lifecycleActor\")\n  actor ! \"hello\"\n  actor ! \"fail\"\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a FullLifecycleActor in Scala that demonstrates preStart, postStop, preRestart, and postRestart lifecycle hooks."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass FullLifecycleActor extends Actor {\n  override def preStart(): Unit = println(\"FullLifecycleActor: preStart called\")\n  override def postStop(): Unit = println(\"FullLifecycleActor: postStop called\")\n  override def preRestart(reason: Throwable, message: Option[Any]): Unit = println(\"FullLifecycleActor: preRestart called\")\n  override def postRestart(reason: Throwable): Unit = println(\"FullLifecycleActor: postRestart called\")\n\n  def receive: Receive = {\n    case \"fail\" => throw new Exception(\"Failure triggered\")\n    case msg => println(s\"FullLifecycleActor: Received $msg\")\n  }\n}\n\nobject FullLifecycleActorApp extends App {\n  val system = ActorSystem(\"FullLifecycleSystem\")\n  val actor = system.actorOf(Props[FullLifecycleActor](), \"fullLifecycleActor\")\n  actor ! \"start\"\n  actor ! \"fail\"\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DynamicChildCreator actor in Scala that creates a new child actor upon receiving a CreateChild message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class CreateChild(name: String)\n\nclass DynamicChildCreator extends Actor {\n  def receive: Receive = {\n    case CreateChild(name) =>\n      val child = context.actorOf(Props[SimpleChildActor](), name)\n      println(s\"DynamicChildCreator: Created child with name $name\")\n    case msg => println(s\"DynamicChildCreator: Received $msg\")\n  }\n}\n\nclass SimpleChildActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"SimpleChildActor ${self.path.name} received: $msg\")\n  }\n}\n\nobject DynamicChildCreatorApp extends App {\n  val system = ActorSystem(\"DynamicChildSystem\")\n  val creator = system.actorOf(Props[DynamicChildCreator](), \"creator\")\n  creator ! CreateChild(\"child1\")\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a MessageModifierActor in Scala that receives a String, appends ' modified' to it, and forwards it to another actor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\nclass MessageModifierActor(next: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      val modified = msg + \" modified\"\n      println(s\"MessageModifierActor: Forwarding modified message: $modified\")\n      next.forward(modified)\n    case _ => println(\"MessageModifierActor: Unknown message\")\n  }\n}\n\nclass FinalReceiver extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"FinalReceiver received: $msg\")\n  }\n}\n\nobject MessageModifierActorApp extends App {\n  val system = ActorSystem(\"ModifierSystem\")\n  val receiver = system.actorOf(Props[FinalReceiver](), \"receiver\")\n  val modifier = system.actorOf(Props(new MessageModifierActor(receiver)), \"modifier\")\n  modifier ! \"Test message\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ParameterizedMessageActor in Scala that uses a case class parameterized message and prints its details."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class DetailedMsg(id: Int, content: String)\n\nclass ParameterizedMessageActor extends Actor {\n  def receive: Receive = {\n    case DetailedMsg(id, content) => println(s\"Received message with id: $id and content: $content\")\n    case _ => println(\"ParameterizedMessageActor: Unknown message\")\n  }\n}\n\nobject ParameterizedMessageActorApp extends App {\n  val system = ActorSystem(\"ParamMessageSystem\")\n  val actor = system.actorOf(Props[ParameterizedMessageActor](), \"paramActor\")\n  actor ! DetailedMsg(1, \"Hello Parameterized\")\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DelayedMessageActor in Scala that schedules a one-off delayed message to itself after 2 seconds."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass DelayedMessageActor extends Actor {\n  override def preStart(): Unit = {\n    context.system.scheduler.scheduleOnce(2.seconds, self, \"delayed\")\n  }\n\n  def receive: Receive = {\n    case \"delayed\" => println(\"DelayedMessageActor: Received delayed message\")\n    case _ => println(\"DelayedMessageActor: Unknown message\")\n  }\n}\n\nobject DelayedMessageActorApp extends App {\n  val system = ActorSystem(\"DelayedMessageSystem\")\n  val actor = system.actorOf(Props[DelayedMessageActor](), \"delayedActor\")\n  Thread.sleep(2500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a FiniteStateActor in Scala that simulates a finite state machine using become to switch between 'idle' and 'busy' states."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass FiniteStateActor extends Actor {\n  def receive: Receive = idle\n\n  def idle: Receive = {\n    case \"work\" =>\n      println(\"FiniteStateActor: Switching to busy state\")\n      context.become(busy)\n    case _ => println(\"FiniteStateActor (idle): Unknown message\")\n  }\n\n  def busy: Receive = {\n    case \"done\" =>\n      println(\"FiniteStateActor: Switching back to idle state\")\n      context.become(idle)\n    case _ => println(\"FiniteStateActor (busy): Processing message\")\n  }\n}\n\nobject FiniteStateActorApp extends App {\n  val system = ActorSystem(\"FiniteStateSystem\")\n  val actor = system.actorOf(Props[FiniteStateActor](), \"finiteStateActor\")\n  actor ! \"work\"\n  actor ! \"random\"\n  actor ! \"done\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a TimersActor in Scala that uses the Timers trait to schedule a periodic tick message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Timers}\nimport scala.concurrent.duration._\n\ncase object Tick\n\nclass TimersActor extends Actor with Timers {\n  // Start the timer to send Tick every 1 second\n  timers.startPeriodicTimer(\"TickTimer\", Tick, 1.second)\n  \n  def receive: Receive = {\n    case Tick => println(\"TimersActor: Tick received\")\n    case _ => println(\"TimersActor: Unknown message\")\n  }\n}\n\nobject TimersActorApp extends App {\n  val system = ActorSystem(\"TimersSystem\")\n  val actor = system.actorOf(Props[TimersActor](), \"timersActor\")\n  Thread.sleep(3000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CustomMailboxActor in Scala and explain that a custom mailbox would be configured via application.conf. Provide a simple actor example."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// CustomMailboxActor simply prints messages; the custom mailbox is set via configuration (not shown here).\nclass CustomMailboxActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"CustomMailboxActor received: $msg\")\n  }\n}\n\nobject CustomMailboxActorApp extends App {\n  val system = ActorSystem(\"CustomMailboxSystem\")\n  val actor = system.actorOf(Props[CustomMailboxActor]().withMailbox(\"custom-mailbox\"), \"customMailboxActor\")\n  actor ! \"Test message for custom mailbox\"\n  Thread.sleep(500)\n  system.terminate()\n}\n\n// Note: The custom mailbox must be defined in application.conf.\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a GracefulShutdownActor in Scala that stops gracefully upon receiving a 'shutdown' message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass GracefulShutdownActor extends Actor {\n  def receive: Receive = {\n    case \"shutdown\" =>\n      println(\"GracefulShutdownActor: Shutting down gracefully.\")\n      context.stop(self)\n    case msg => println(s\"GracefulShutdownActor: Received $msg\")\n  }\n}\n\nobject GracefulShutdownActorApp extends App {\n  val system = ActorSystem(\"ShutdownSystem\")\n  val actor = system.actorOf(Props[GracefulShutdownActor](), \"shutdownActor\")\n  actor ! \"hello\"\n  actor ! \"shutdown\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a HotSwappingActor in Scala that uses context.become to swap between two behaviors on receiving a 'swap' message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass HotSwappingActor extends Actor {\n  def receive: Receive = behaviorA\n\n  def behaviorA: Receive = {\n    case \"swap\" =>\n      println(\"HotSwappingActor: Switching from BehaviorA to BehaviorB\")\n      context.become(behaviorB)\n    case msg => println(s\"BehaviorA processing: $msg\")\n  }\n\n  def behaviorB: Receive = {\n    case \"swap\" =>\n      println(\"HotSwappingActor: Switching from BehaviorB to BehaviorA\")\n      context.become(behaviorA)\n    case msg => println(s\"BehaviorB processing: $msg\")\n  }\n}\n\nobject HotSwappingActorApp extends App {\n  val system = ActorSystem(\"HotSwapSystem\")\n  val actor = system.actorOf(Props[HotSwappingActor](), \"hotSwapper\")\n  actor ! \"test\"\n  actor ! \"swap\"\n  actor ! \"another test\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SelfPathLoggingActor in Scala that logs its own actor path when it receives any message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass SelfPathLoggingActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"SelfPathLoggingActor (${self.path}) received: $msg\")\n  }\n}\n\nobject SelfPathLoggingActorApp extends App {\n  val system = ActorSystem(\"SelfPathSystem\")\n  val actor = system.actorOf(Props[SelfPathLoggingActor](), \"selfPathLogger\")\n  actor ! \"Log my path\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an AskAndPipeActor in Scala that uses the ask pattern and then pipes the result to itself using pipeTo."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.{ask, pipe}\nimport akka.util.Timeout\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration._\n\nclass AskAndPipeActor(responder: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(2.seconds)\n  \n  def receive: Receive = {\n    case \"trigger\" =>\n      val futureResponse = responder ? \"hello\"\n      futureResponse pipeTo self\n    case response => println(s\"AskAndPipeActor received: $response\")\n  }\n}\n\nclass SimpleResponder extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! s\"Response to $msg\"\n  }\n}\n\nobject AskAndPipeActorApp extends App {\n  val system = ActorSystem(\"AskAndPipeSystem\")\n  val responder = system.actorOf(Props[SimpleResponder](), \"responder\")\n  val actor = system.actorOf(Props(new AskAndPipeActor(responder)), \"askAndPipe\")\n  actor ! \"trigger\"\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ResettableCounterActor in Scala that increments a counter on 'inc' and resets it on 'reset'."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ResettableCounterActor extends Actor {\n  var counter = 0\n\n  def receive: Receive = {\n    case \"inc\" =>\n      counter += 1\n      println(s\"Counter: $counter\")\n    case \"reset\" =>\n      counter = 0\n      println(\"Counter reset\")\n    case _ => println(\"ResettableCounterActor: Unknown message\")\n  }\n}\n\nobject ResettableCounterActorApp extends App {\n  val system = ActorSystem(\"CounterSystem\")\n  val counterActor = system.actorOf(Props[ResettableCounterActor](), \"counterActor\")\n  counterActor ! \"inc\"\n  counterActor ! \"inc\"\n  counterActor ! \"reset\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a BatchCollectorActor in Scala that collects incoming messages in a batch and processes them once the batch reaches 3 messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass BatchCollectorActor extends Actor {\n  var batch = List.empty[String]\n  \n  def receive: Receive = {\n    case msg: String =>\n      batch = batch :+ msg\n      if (batch.size >= 3) {\n        println(s\"Processing batch: ${batch.mkString(\", \")}\")\n        batch = Nil\n      }\n    case _ => println(\"BatchCollectorActor: Unknown message\")\n  }\n}\n\nobject BatchCollectorActorApp extends App {\n  val system = ActorSystem(\"BatchSystem\")\n  val collector = system.actorOf(Props[BatchCollectorActor](), \"batchCollector\")\n  collector ! \"msg1\"\n  collector ! \"msg2\"\n  collector ! \"msg3\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a PatternFilterActor in Scala that only processes messages that are even numbers."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass PatternFilterActor extends Actor {\n  def receive: Receive = {\n    case i: Int if i % 2 == 0 => println(s\"Even number: $i\")\n    case i: Int => println(s\"Odd number ignored: $i\")\n    case _ => println(\"PatternFilterActor: Unknown message\")\n  }\n}\n\nobject PatternFilterActorApp extends App {\n  val system = ActorSystem(\"PatternFilterSystem\")\n  val actor = system.actorOf(Props[PatternFilterActor](), \"filterActor\")\n  actor ! 4\n  actor ! 5\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an OptionStateActor in Scala that uses an Option to store a state and updates it upon receiving a message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass OptionStateActor extends Actor {\n  var state: Option[String] = None\n  \n  def receive: Receive = {\n    case s: String =>\n      state = Some(s)\n      println(s\"State updated to: ${state.get}\")\n    case \"clear\" =>\n      state = None\n      println(\"State cleared\")\n    case _ => println(\"OptionStateActor: Unknown message\")\n  }\n}\n\nobject OptionStateActorApp extends App {\n  val system = ActorSystem(\"OptionStateSystem\")\n  val actor = system.actorOf(Props[OptionStateActor](), \"optionStateActor\")\n  actor ! \"new state\"\n  actor ! \"clear\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ResourceManagerActor in Scala that simulates opening and closing a resource on 'open' and 'close' messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ResourceManagerActor extends Actor {\n  var resourceOpen = false\n\n  def receive: Receive = {\n    case \"open\" =>\n      if (!resourceOpen) {\n        resourceOpen = true\n        println(\"ResourceManagerActor: Resource opened\")\n      } else println(\"ResourceManagerActor: Resource already open\")\n    case \"close\" =>\n      if (resourceOpen) {\n        resourceOpen = false\n        println(\"ResourceManagerActor: Resource closed\")\n      } else println(\"ResourceManagerActor: Resource already closed\")\n    case _ => println(\"ResourceManagerActor: Unknown message\")\n  }\n}\n\nobject ResourceManagerActorApp extends App {\n  val system = ActorSystem(\"ResourceSystem\")\n  val actor = system.actorOf(Props[ResourceManagerActor](), \"resourceManager\")\n  actor ! \"open\"\n  actor ! \"close\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a HealthCheckActor in Scala that uses a scheduler to check its health status every second."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass HealthCheckActor extends Actor {\n  override def preStart(): Unit = {\n    context.system.scheduler.scheduleWithFixedDelay(0.seconds, 1.second, self, \"healthCheck\")\n  }\n  def receive: Receive = {\n    case \"healthCheck\" => println(\"HealthCheckActor: System is healthy\")\n    case _ => println(\"HealthCheckActor: Unknown message\")\n  }\n}\n\nobject HealthCheckActorApp extends App {\n  val system = ActorSystem(\"HealthCheckSystem\")\n  val actor = system.actorOf(Props[HealthCheckActor](), \"healthChecker\")\n  Thread.sleep(3000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ModeSwitchActor in Scala that switches processing mode based on incoming message content using become."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ModeSwitchActor extends Actor {\n  def receive: Receive = normal\n\n  def normal: Receive = {\n    case \"mode:urgent\" =>\n      println(\"ModeSwitchActor: Switching to urgent mode\")\n      context.become(urgent)\n    case msg => println(s\"Normal mode processing: $msg\")\n  }\n\n  def urgent: Receive = {\n    case \"mode:normal\" =>\n      println(\"ModeSwitchActor: Switching to normal mode\")\n      context.become(normal)\n    case msg => println(s\"Urgent mode processing: $msg\")\n  }\n}\n\nobject ModeSwitchActorApp extends App {\n  val system = ActorSystem(\"ModeSwitchSystem\")\n  val actor = system.actorOf(Props[ModeSwitchActor](), \"modeSwitch\")\n  actor ! \"Hello\"\n  actor ! \"mode:urgent\"\n  actor ! \"Emergency\"\n  actor ! \"mode:normal\"\n  actor ! \"Back to normal\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SelfMessagingActor in Scala that sends a message to itself upon receiving any message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass SelfMessagingActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"SelfMessagingActor received: $msg, sending self a confirmation\")\n      self ! s\"ack: $msg\"\n    case ack => println(s\"SelfMessagingActor received acknowledgment: $ack\")\n  }\n}\n\nobject SelfMessagingActorApp extends App {\n  val system = ActorSystem(\"SelfMessagingSystem\")\n  val actor = system.actorOf(Props[SelfMessagingActor](), \"selfMessenger\")\n  actor ! \"Test message\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an ImplicitConversionActor in Scala that demonstrates using an implicit conversion to transform a message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Implicit conversion from Int to String\nimplicit def intToString(i: Int): String = s\"Number: $i\"\n\nclass ImplicitConversionActor extends Actor {\n  def receive: Receive = {\n    case msg: String => println(s\"Processed: $msg\")\n    case _ => println(\"ImplicitConversionActor: Unknown message\")\n  }\n}\n\nobject ImplicitConversionActorApp extends App {\n  val system = ActorSystem(\"ImplicitConversionSystem\")\n  val actor = system.actorOf(Props[ImplicitConversionActor](), \"implicitActor\")\n  // Sending an Int, which will be implicitly converted to a String\n  actor ! 100\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ChainForwarderActor in Scala that forwards a message through a chain of three actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\nclass Forwarder(next: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg => \n      println(s\"Forwarder (${self.path.name}) forwarding: $msg\")\n      next.forward(msg)\n  }\n}\n\nclass FinalReceiver extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"FinalReceiver received: $msg\")\n  }\n}\n\nobject ChainForwarderActorApp extends App {\n  val system = ActorSystem(\"ChainForwarderSystem\")\n  val finalReceiver = system.actorOf(Props[FinalReceiver](), \"finalReceiver\")\n  val forwarder2 = system.actorOf(Props(new Forwarder(finalReceiver)), \"forwarder2\")\n  val forwarder1 = system.actorOf(Props(new Forwarder(forwarder2)), \"forwarder1\")\n  forwarder1 ! \"Chained message\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an AggregatorActor in Scala that aggregates messages over 2 seconds and then prints the aggregated result."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.collection.mutable.ListBuffer\n\nclass AggregatorActor extends Actor {\n  val buffer = ListBuffer.empty[String]\n  \n  import context.dispatcher\n  context.system.scheduler.scheduleOnce(2.seconds, self, \"aggregate\")\n  \n  def receive: Receive = {\n    case msg: String => buffer += msg\n    case \"aggregate\" =>\n      println(s\"Aggregated messages: ${buffer.mkString(\", \")}\")\n      buffer.clear()\n    case _ => println(\"AggregatorActor: Unknown message\")\n  }\n}\n\nobject AggregatorActorApp extends App {\n  val system = ActorSystem(\"AggregatorSystem\")\n  val actor = system.actorOf(Props[AggregatorActor](), \"aggregator\")\n  actor ! \"msg1\"\n  actor ! \"msg2\"\n  actor ! \"msg3\"\n  Thread.sleep(2500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a FakeDBActor in Scala that simulates a database call with a Future and replies with a fake result."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration._\n\nclass FakeDBActor extends Actor {\n  def receive: Receive = {\n    case \"query\" =>\n      val originalSender = sender()\n      Future {\n        Thread.sleep(200)\n        \"Fake DB result\"\n      } foreach { result => originalSender ! result }\n    case _ => println(\"FakeDBActor: Unknown message\")\n  }\n}\n\nobject FakeDBActorApp extends App {\n  val system = ActorSystem(\"FakeDBSystem\")\n  val actor = system.actorOf(Props[FakeDBActor](), \"fakeDB\")\n  actor ! \"query\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a FutureErrorHandlingActor in Scala that performs a Future computation and handles errors gracefully, sending an error message back to the sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Success, Failure}\nimport scala.concurrent.duration._\n\nclass FutureErrorHandlingActor extends Actor {\n  def receive: Receive = {\n    case \"compute\" =>\n      val originalSender = sender()\n      Future {\n        Thread.sleep(100)\n        if (scala.util.Random.nextBoolean()) \"Computation successful\" else throw new Exception(\"Computation failed\")\n      } onComplete {\n        case Success(result) => originalSender ! result\n        case Failure(ex) => originalSender ! s\"Error: ${ex.getMessage}\"\n      }\n    case _ => println(\"FutureErrorHandlingActor: Unknown message\")\n  }\n}\n\nobject FutureErrorHandlingActorApp extends App {\n  val system = ActorSystem(\"FutureErrorSystem\")\n  val actor = system.actorOf(Props[FutureErrorHandlingActor](), \"futureErrorActor\")\n  actor ! \"compute\"\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SimpleLoggerActor in Scala that logs any received message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass SimpleLoggerActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"SimpleLoggerActor received: $msg\")\n  }\n}\n\nobject SimpleLoggerActorApp extends App {\n  val system = ActorSystem(\"SimpleLoggerSystem\")\n  val logger = system.actorOf(Props[SimpleLoggerActor](), \"logger\")\n  logger ! \"Test message\"\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a MathFactorialActor in Scala that computes the factorial of an integer and replies with the result."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class ComputeFactorial(n: Int)\n\nclass MathFactorialActor extends Actor {\n  def factorial(n: Int): BigInt = if (n <= 1) 1 else n * factorial(n - 1)\n  \n  def receive: Receive = {\n    case ComputeFactorial(n) =>\n      val result = factorial(n)\n      println(s\"Factorial of $n is $result\")\n      sender() ! result\n  }\n}\n\nobject MathFactorialActorApp extends App {\n  val system = ActorSystem(\"MathFactorialSystem\")\n  val actor = system.actorOf(Props[MathFactorialActor](), \"factorialActor\")\n  actor ! ComputeFactorial(5)\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DelayActor in Scala that delays its response by 500 milliseconds before replying."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase object DelayedReply\n\nclass DelayActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      val originalSender = sender()\n      context.system.scheduler.scheduleOnce(500.milliseconds) {\n        originalSender ! s\"Delayed response to: $msg\"\n      }\n  }\n}\n\nobject DelayActorApp extends App {\n  val system = ActorSystem(\"DelaySystem\")\n  val actor = system.actorOf(Props[DelayActor](), \"delayActor\")\n  actor ! \"Hello\"\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CountResetActor in Scala that increments a counter for each message and resets the count when it receives a Reset message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Reset\n\nclass CountResetActor extends Actor {\n  var count = 0\n  def receive: Receive = {\n    case Reset =>\n      println(s\"CountResetActor: Counter reset from $count to 0\")\n      count = 0\n    case _ =>\n      count += 1\n      println(s\"CountResetActor: Current count is $count\")\n  }\n}\n\nobject CountResetActorApp extends App {\n  val system = ActorSystem(\"CountResetSystem\")\n  val actor = system.actorOf(Props[CountResetActor](), \"counter\")\n  actor ! \"msg1\"\n  actor ! \"msg2\"\n  actor ! Reset\n  actor ! \"msg3\"\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a PrinterActor in Scala that prints messages with a prefix 'Printed:' before the message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass PrinterActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"Printed: $msg\")\n  }\n}\n\nobject PrinterActorApp extends App {\n  val system = ActorSystem(\"PrinterSystem\")\n  val printer = system.actorOf(Props[PrinterActor](), \"printer\")\n  printer ! \"This is a test\"\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a TimerBasedActor in Scala that uses scheduleOnce to send itself a 'wake' message after 1 second."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass TimerBasedActor extends Actor {\n  override def preStart(): Unit = {\n    context.system.scheduler.scheduleOnce(1.second, self, \"wake\")\n  }\n  \n  def receive: Receive = {\n    case \"wake\" => println(\"TimerBasedActor: I have been woken up!\")\n    case _ => println(\"TimerBasedActor: Unknown message\")\n  }\n}\n\nobject TimerBasedActorApp extends App {\n  val system = ActorSystem(\"TimerBasedSystem\")\n  val actor = system.actorOf(Props[TimerBasedActor](), \"timerActor\")\n  Thread.sleep(1500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SupervisorStopActor in Scala that supervises a child and stops the child when it throws an exception."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy.Stop\nimport scala.concurrent.duration._\n\nclass FaultyChild extends Actor {\n  def receive: Receive = {\n    case \"fail\" => throw new Exception(\"Child failure\")\n    case msg => println(s\"FaultyChild received: $msg\")\n  }\n}\n\nclass SupervisorStopActor extends Actor {\n  override val supervisorStrategy = OneForOneStrategy(maxNrOfRetries = 1, withinTimeRange = 1.minute) {\n    case _: Exception => Stop\n  }\n  \n  val child = context.actorOf(Props[FaultyChild](), \"faultyChild\")\n  def receive: Receive = {\n    case msg => child.forward(msg)\n  }\n}\n\nobject SupervisorStopActorApp extends App {\n  val system = ActorSystem(\"SupervisorStopSystem\")\n  val supervisor = system.actorOf(Props[SupervisorStopActor](), \"supervisor\")\n  supervisor ! \"fail\"\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an FSMStateActor in Scala using the FSM trait that switches between 'Active' and 'Inactive' states based on a toggle message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{ActorSystem, Props, FSM}\nimport scala.concurrent.duration._\n\n// Define states\nsealed trait State\ncase object Active extends State\ncase object Inactive extends State\n\n// Define data (unused here)\nsealed trait Data\ncase object Uninitialized extends Data\n\nclass FSMStateActor extends FSM[State, Data] {\n  startWith(Inactive, Uninitialized)\n\n  when(Inactive, stateTimeout = 2.seconds) {\n    case Event(\"toggle\", _) => goto(Active)\n  }\n\n  when(Active, stateTimeout = 2.seconds) {\n    case Event(\"toggle\", _) => goto(Inactive)\n  }\n\n  initialize()\n}\n\nobject FSMStateActorApp extends App {\n  val system = ActorSystem(\"FSMStateSystem\")\n  val fsmActor = system.actorOf(Props[FSMStateActor](), \"fsmActor\")\n  fsmActor ! \"toggle\"\n  Thread.sleep(2500)\n  fsmActor ! \"toggle\"\n  Thread.sleep(2500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ConfigReaderActor in Scala that reads a configuration value from the ActorSystem's config and prints it."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ConfigReaderActor extends Actor {\n  val configValue: String = context.system.settings.config.getString(\"myapp.value\")\n  def receive: Receive = {\n    case _ => println(s\"ConfigReaderActor: Config value is $configValue\")\n  }\n}\n\nobject ConfigReaderActorApp extends App {\n  val system = ActorSystem(\"ConfigReaderSystem\")\n  val actor = system.actorOf(Props[ConfigReaderActor](), \"configReader\")\n  actor ! \"read\"\n  Thread.sleep(500)\n  system.terminate()\n}\n\n// Note: Ensure application.conf contains: myapp.value = \"ExampleValue\"\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ForwarderWithLoggingActor in Scala that logs a message before forwarding it to another actor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\nclass ForwarderWithLoggingActor(next: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ForwarderWithLoggingActor: Forwarding message: $msg\")\n      next.forward(msg)\n  }\n}\n\nclass FinalReceiverActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"FinalReceiverActor received: $msg\")\n  }\n}\n\nobject ForwarderWithLoggingActorApp extends App {\n  val system = ActorSystem(\"ForwarderSystem\")\n  val finalReceiver = system.actorOf(Props[FinalReceiverActor](), \"finalReceiver\")\n  val forwarder = system.actorOf(Props(new ForwarderWithLoggingActor(finalReceiver)), \"forwarder\")\n  forwarder ! \"Hello, world!\"\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a MultiplexerActor in Scala that sends integer messages to IntWorker and string messages to StringWorker."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass IntWorker extends Actor {\n  def receive: Receive = {\n    case i: Int => println(s\"IntWorker processing: $i\")\n  }\n}\n\nclass StringWorker extends Actor {\n  def receive: Receive = {\n    case s: String => println(s\"StringWorker processing: $s\")\n  }\n}\n\nclass MultiplexerActor(intWorker: akka.actor.ActorRef, stringWorker: akka.actor.ActorRef) extends Actor {\n  def receive: Receive = {\n    case i: Int => intWorker ! i\n    case s: String => stringWorker ! s\n    case _ => println(\"MultiplexerActor: Unknown message\")\n  }\n}\n\nobject MultiplexerActorApp extends App {\n  val system = ActorSystem(\"MultiplexerSystem\")\n  val intWorker = system.actorOf(Props[IntWorker](), \"intWorker\")\n  val stringWorker = system.actorOf(Props[StringWorker](), \"stringWorker\")\n  val multiplexer = system.actorOf(Props(new MultiplexerActor(intWorker, stringWorker)), \"multiplexer\")\n  multiplexer ! 42\n  multiplexer ! \"Hello Multiplexer\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RequestResponseActor in Scala that uses the ask pattern to request data from a DataProvider actor and prints the response."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\n\ncase object RequestData\n\nclass DataProvider extends Actor {\n  def receive: Receive = {\n    case RequestData => sender() ! \"Data response\"\n  }\n}\n\nclass RequestResponseActor(dataProvider: akka.actor.ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(2.seconds)\n  def receive: Receive = {\n    case \"request\" =>\n      val result = Await.result(dataProvider ? RequestData, timeout.duration)\n      println(s\"RequestResponseActor received: $result\")\n  }\n}\n\nobject RequestResponseActorApp extends App {\n  val system = ActorSystem(\"RequestResponseSystem\")\n  val dataProvider = system.actorOf(Props[DataProvider](), \"dataProvider\")\n  val actor = system.actorOf(Props(new RequestResponseActor(dataProvider)), \"requestResponse\")\n  actor ! \"request\"\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DataCollectorActor in Scala that collects incoming messages in a list and processes them when it receives a 'flush' message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass DataCollectorActor extends Actor {\n  var data = List.empty[String]\n  def receive: Receive = {\n    case msg: String if msg != \"flush\" => data = data :+ msg\n    case \"flush\" =>\n      println(s\"DataCollectorActor: Flushing data: ${data.mkString(\", \")}\")\n      data = Nil\n    case _ => println(\"DataCollectorActor: Unknown message\")\n  }\n}\n\nobject DataCollectorActorApp extends App {\n  val system = ActorSystem(\"DataCollectorSystem\")\n  val collector = system.actorOf(Props[DataCollectorActor](), \"collector\")\n  collector ! \"one\"\n  collector ! \"two\"\n  collector ! \"flush\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RateLimiterActor in Scala that processes only one message per second and ignores others."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass RateLimiterActor extends Actor {\n  var lastProcessed = System.currentTimeMillis()\n  def receive: Receive = {\n    case msg =>\n      val now = System.currentTimeMillis()\n      if (now - lastProcessed >= 1000) {\n        println(s\"RateLimiterActor processing: $msg\")\n        lastProcessed = now\n      } else {\n        println(s\"RateLimiterActor ignoring: $msg\")\n      }\n  }\n}\n\nobject RateLimiterActorApp extends App {\n  val system = ActorSystem(\"RateLimiterSystem\")\n  val actor = system.actorOf(Props[RateLimiterActor](), \"rateLimiter\")\n  actor ! \"first\"\n  Thread.sleep(500)\n  actor ! \"second\"\n  Thread.sleep(1500)\n  actor ! \"third\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a LazyInitializerActor in Scala that initializes its state only upon receiving the first message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass LazyInitializerActor extends Actor {\n  var initialized = false\n  var state: String = \"\"\n\n  def receive: Receive = {\n    case msg if !initialized =>\n      state = s\"Initialized with: $msg\"\n      initialized = true\n      println(state)\n    case msg => println(s\"LazyInitializerActor processing: $msg with state: $state\")\n  }\n}\n\nobject LazyInitializerActorApp extends App {\n  val system = ActorSystem(\"LazyInitializerSystem\")\n  val actor = system.actorOf(Props[LazyInitializerActor](), \"lazyInitializer\")\n  actor ! \"first message\"\n  actor ! \"second message\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ChildCreatorActor in Scala that creates a new child actor upon receiving a CreateChild(name) message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class CreateChild(name: String)\n\nclass ChildCreatorActor extends Actor {\n  def receive: Receive = {\n    case CreateChild(name) =>\n      val child = context.actorOf(Props[SimpleChildActor](), name)\n      println(s\"ChildCreatorActor created child: $name\")\n    case msg => println(s\"ChildCreatorActor received: $msg\")\n  }\n}\n\nclass SimpleChildActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"SimpleChildActor ${self.path.name} received: $msg\")\n  }\n}\n\nobject ChildCreatorActorApp extends App {\n  val system = ActorSystem(\"ChildCreatorSystem\")\n  val creator = system.actorOf(Props[ChildCreatorActor](), \"creator\")\n  creator ! CreateChild(\"child1\")\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CommandHandlerActor in Scala that logs commands and executes actions for 'start', 'stop', and 'status'."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass CommandHandlerActor extends Actor {\n  def receive: Receive = {\n    case \"start\" => println(\"CommandHandlerActor: Starting process\")\n    case \"stop\" => println(\"CommandHandlerActor: Stopping process\")\n    case \"status\" => println(\"CommandHandlerActor: Status is OK\")\n    case cmd => println(s\"CommandHandlerActor: Unknown command $cmd\")\n  }\n}\n\nobject CommandHandlerActorApp extends App {\n  val system = ActorSystem(\"CommandHandlerSystem\")\n  val actor = system.actorOf(Props[CommandHandlerActor](), \"commandHandler\")\n  actor ! \"start\"\n  actor ! \"status\"\n  actor ! \"stop\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SumActor in Scala that sums all integer messages it receives and replies with the total."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass SumActor extends Actor {\n  var sum = 0\n  def receive: Receive = {\n    case n: Int => \n      sum += n\n      println(s\"SumActor: Current sum is $sum\")\n      sender() ! sum\n    case _ => println(\"SumActor: Unknown message\")\n  }\n}\n\nobject SumActorApp extends App {\n  val system = ActorSystem(\"SumSystem\")\n  val actor = system.actorOf(Props[SumActor](), \"sumActor\")\n  actor ! 10\n  actor ! 20\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SubtractActor in Scala that subtracts each received integer from an initial value of 100 and prints the result."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass SubtractActor extends Actor {\n  var total = 100\n  def receive: Receive = {\n    case n: Int => \n      total -= n\n      println(s\"SubtractActor: New total is $total\")\n    case _ => println(\"SubtractActor: Unknown message\")\n  }\n}\n\nobject SubtractActorApp extends App {\n  val system = ActorSystem(\"SubtractSystem\")\n  val actor = system.actorOf(Props[SubtractActor](), \"subtractActor\")\n  actor ! 10\n  actor ! 5\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a MultiplyActor in Scala that multiplies all integer messages it receives and prints the product."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass MultiplyActor extends Actor {\n  var product = 1\n  def receive: Receive = {\n    case n: Int => \n      product *= n\n      println(s\"MultiplyActor: Current product is $product\")\n    case _ => println(\"MultiplyActor: Unknown message\")\n  }\n}\n\nobject MultiplyActorApp extends App {\n  val system = ActorSystem(\"MultiplySystem\")\n  val actor = system.actorOf(Props[MultiplyActor](), \"multiplyActor\")\n  actor ! 2\n  actor ! 3\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DivideActor in Scala that divides 100 by a received integer and handles division by zero gracefully."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass DivideActor extends Actor {\n  def receive: Receive = {\n    case n: Int => \n      if (n == 0) println(\"DivideActor: Division by zero error\")\n      else println(s\"DivideActor: 100 / $n = ${100 / n}\")\n    case _ => println(\"DivideActor: Unknown message\")\n  }\n}\n\nobject DivideActorApp extends App {\n  val system = ActorSystem(\"DivideSystem\")\n  val actor = system.actorOf(Props[DivideActor](), \"divideActor\")\n  actor ! 5\n  actor ! 0\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an EchoActor in Scala that replies with the same message it receives."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass EchoActor extends Actor {\n  def receive: Receive = {\n    case msg => \n      println(s\"EchoActor: Echoing back $msg\")\n      sender() ! msg\n  }\n}\n\nobject EchoActorApp extends App {\n  val system = ActorSystem(\"EchoSystem\")\n  val actor = system.actorOf(Props[EchoActor](), \"echoActor\")\n  actor.tell(\"Hello Echo\", actor)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ToggleSwitchActor in Scala that toggles between 'on' and 'off' states on receiving a Toggle message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Toggle\n\nclass ToggleSwitchActor extends Actor {\n  var state = \"off\"\n  def receive: Receive = {\n    case Toggle => \n      state = if (state == \"off\") \"on\" else \"off\"\n      println(s\"ToggleSwitchActor: State is now $state\")\n    case msg => println(s\"ToggleSwitchActor: Received $msg in state $state\")\n  }\n}\n\nobject ToggleSwitchActorApp extends App {\n  val system = ActorSystem(\"ToggleSwitchSystem\")\n  val actor = system.actorOf(Props[ToggleSwitchActor](), \"toggleSwitch\")\n  actor ! Toggle\n  actor ! Toggle\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a FileSimulatorActor in Scala that simulates reading from a file by returning a fixed string when it receives a ReadFile message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object ReadFile\n\nclass FileSimulatorActor extends Actor {\n  def receive: Receive = {\n    case ReadFile => \n      println(\"FileSimulatorActor: Simulating file read\")\n      sender() ! \"File content: Hello from file!\"\n    case _ => println(\"FileSimulatorActor: Unknown message\")\n  }\n}\n\nobject FileSimulatorActorApp extends App {\n  val system = ActorSystem(\"FileSimulatorSystem\")\n  val actor = system.actorOf(Props[FileSimulatorActor](), \"fileSimulator\")\n  actor.tell(ReadFile, actor)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SumAggregatorActor in Scala that receives numbers from two workers and prints the total sum when both have responded."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase class NumberMsg(value: Int)\n\nclass SumAggregatorActor extends Actor {\n  var responses = List.empty[Int]\n  def receive: Receive = {\n    case NumberMsg(num) =>\n      responses = num :: responses\n      if (responses.size == 2) {\n        val total = responses.sum\n        println(s\"SumAggregatorActor: Total sum is $total\")\n        responses = Nil\n      }\n    case _ => println(\"SumAggregatorActor: Unknown message\")\n  }\n}\n\n// Workers simply send a fixed number\nclass NumberWorker(num: Int) extends Actor {\n  def receive: Receive = {\n    case \"start\" => sender() ! NumberMsg(num)\n  }\n}\n\nobject SumAggregatorActorApp extends App {\n  val system = ActorSystem(\"SumAggregatorSystem\")\n  val worker1 = system.actorOf(Props(new NumberWorker(10)), \"worker1\")\n  val worker2 = system.actorOf(Props(new NumberWorker(20)), \"worker2\")\n  val aggregator = system.actorOf(Props(new SumAggregatorActor), \"aggregator\")\n  worker1.tell(\"start\", aggregator)\n  worker2.tell(\"start\", aggregator)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ThresholdCounterActor in Scala that counts messages and resets the counter once it reaches a threshold of 5."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ThresholdCounterActor extends Actor {\n  var count = 0\n  def receive: Receive = {\n    case msg =>\n      count += 1\n      println(s\"ThresholdCounterActor: Count is $count\")\n      if (count >= 5) {\n        println(\"ThresholdCounterActor: Threshold reached, resetting counter\")\n        count = 0\n      }\n  }\n}\n\nobject ThresholdCounterActorApp extends App {\n  val system = ActorSystem(\"ThresholdCounterSystem\")\n  val actor = system.actorOf(Props[ThresholdCounterActor](), \"thresholdCounter\")\n  for (i <- 1 to 7) actor ! s\"msg $i\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a StatePrinterActor in Scala that maintains an internal state and prints it when it receives a 'print' message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass StatePrinterActor extends Actor {\n  var state = \"Initial state\"\n  def receive: Receive = {\n    case s: String if s.startsWith(\"set:\") =>\n      state = s.stripPrefix(\"set:\")\n      println(s\"State updated to: $state\")\n    case \"print\" => println(s\"Current state: $state\")\n    case _ => println(\"StatePrinterActor: Unknown message\")\n  }\n}\n\nobject StatePrinterActorApp extends App {\n  val system = ActorSystem(\"StatePrinterSystem\")\n  val actor = system.actorOf(Props[StatePrinterActor](), \"statePrinter\")\n  actor ! \"set:Active\"\n  actor ! \"print\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a TemperatureConverterActor in Scala that converts a Celsius temperature to Fahrenheit when it receives a Temperature value."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Temperature(celsius: Double)\n\nclass TemperatureConverterActor extends Actor {\n  def receive: Receive = {\n    case Temperature(c) =>\n      val f = c * 9/5 + 32\n      println(s\"TemperatureConverterActor: $c\u00b0C is $f\u00b0F\")\n    case _ => println(\"TemperatureConverterActor: Unknown message\")\n  }\n}\n\nobject TemperatureConverterActorApp extends App {\n  val system = ActorSystem(\"TemperatureConverterSystem\")\n  val actor = system.actorOf(Props[TemperatureConverterActor](), \"tempConverter\")\n  actor ! Temperature(25)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a GreetingActor in Scala that responds to a Hello message with a greeting."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Hello\n\nclass GreetingActor extends Actor {\n  def receive: Receive = {\n    case Hello => println(\"GreetingActor: Hello, how are you?\")\n    case _ => println(\"GreetingActor: Unknown message\")\n  }\n}\n\nobject GreetingActorApp extends App {\n  val system = ActorSystem(\"GreetingSystem\")\n  val actor = system.actorOf(Props[GreetingActor](), \"greetingActor\")\n  actor ! Hello\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ShutdownNotifierActor in Scala that logs a message when it receives a 'shutdown' message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ShutdownNotifierActor extends Actor {\n  def receive: Receive = {\n    case \"shutdown\" => println(\"ShutdownNotifierActor: Received shutdown, cleaning up...\")\n    case msg => println(s\"ShutdownNotifierActor: Received $msg\")\n  }\n}\n\nobject ShutdownNotifierActorApp extends App {\n  val system = ActorSystem(\"ShutdownNotifierSystem\")\n  val actor = system.actorOf(Props[ShutdownNotifierActor](), \"shutdownNotifier\")\n  actor ! \"shutdown\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a LazyLoadingActor in Scala that loads a resource (simulated by a string) only upon receiving its first message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass LazyLoadingActor extends Actor {\n  lazy val resource: String = {\n    println(\"LazyLoadingActor: Loading resource...\")\n    \"LoadedResource\"\n  }\n  def receive: Receive = {\n    case msg => println(s\"LazyLoadingActor: Using resource: $resource for message: $msg\")\n  }\n}\n\nobject LazyLoadingActorApp extends App {\n  val system = ActorSystem(\"LazyLoadingSystem\")\n  val actor = system.actorOf(Props[LazyLoadingActor](), \"lazyLoader\")\n  actor ! \"First access\"\n  actor ! \"Second access\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CacheActor in Scala that caches a message and replies with the cached result if available, otherwise stores and replies with the new message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass CacheActor extends Actor {\n  var cache: Option[String] = None\n  def receive: Receive = {\n    case msg: String =>\n      cache match {\n        case Some(cached) => println(s\"CacheActor: Returning cached result: $cached\")\n        case None => \n          cache = Some(msg)\n          println(s\"CacheActor: Caching and returning: $msg\")\n      }\n  }\n}\n\nobject CacheActorApp extends App {\n  val system = ActorSystem(\"CacheSystem\")\n  val actor = system.actorOf(Props[CacheActor](), \"cacheActor\")\n  actor ! \"Data1\"\n  actor ! \"Data2\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a LogFilterActor in Scala that only logs messages that contain the keyword 'important'."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass LogFilterActor extends Actor {\n  def receive: Receive = {\n    case msg: String if msg.contains(\"important\") => println(s\"LogFilterActor: $msg\")\n    case _ => // ignore other messages\n  }\n}\n\nobject LogFilterActorApp extends App {\n  val system = ActorSystem(\"LogFilterSystem\")\n  val actor = system.actorOf(Props[LogFilterActor](), \"logFilter\")\n  actor ! \"This is important information\"\n  actor ! \"Not important\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RequestLoggerActor in Scala that logs every incoming message with a timestamp."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport java.time.LocalDateTime\n\nclass RequestLoggerActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"${LocalDateTime.now}: Received $msg\")\n  }\n}\n\nobject RequestLoggerActorApp extends App {\n  val system = ActorSystem(\"RequestLoggerSystem\")\n  val actor = system.actorOf(Props[RequestLoggerActor](), \"requestLogger\")\n  actor ! \"Request 1\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SequenceGeneratorActor in Scala that generates the next number in a sequence upon receiving a 'next' message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass SequenceGeneratorActor extends Actor {\n  var current = 0\n  def receive: Receive = {\n    case \"next\" => \n      current += 1\n      println(s\"SequenceGeneratorActor: Next number is $current\")\n      sender() ! current\n    case _ => println(\"SequenceGeneratorActor: Unknown message\")\n  }\n}\n\nobject SequenceGeneratorActorApp extends App {\n  val system = ActorSystem(\"SequenceGeneratorSystem\")\n  val actor = system.actorOf(Props[SequenceGeneratorActor](), \"sequenceGenerator\")\n  actor ! \"next\"\n  actor ! \"next\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RandomNumberActor in Scala that generates a random number between 1 and 100 and replies with it."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.util.Random\n\nclass RandomNumberActor extends Actor {\n  def receive: Receive = {\n    case \"generate\" => \n      val number = Random.nextInt(100) + 1\n      println(s\"RandomNumberActor: Generated number $number\")\n      sender() ! number\n    case _ => println(\"RandomNumberActor: Unknown message\")\n  }\n}\n\nobject RandomNumberActorApp extends App {\n  val system = ActorSystem(\"RandomNumberSystem\")\n  val actor = system.actorOf(Props[RandomNumberActor](), \"randomNumber\")\n  actor ! \"generate\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a TimeoutResponseActor in Scala that simulates a long computation and replies with a timeout message if it takes too long."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.Future\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport akka.pattern.after\n\nclass TimeoutResponseActor extends Actor {\n  def receive: Receive = {\n    case \"compute\" =>\n      val originalSender = sender()\n      val computation = Future {\n        Thread.sleep(2000)\n        \"Computation result\"\n      }\n      val timeout = after(1.second, using = context.system.scheduler)(Future.successful(\"Timeout occurred\"))\n      Future.firstCompletedOf(Seq(computation, timeout)).foreach(result => originalSender ! result)\n    case _ => println(\"TimeoutResponseActor: Unknown message\")\n  }\n}\n\nobject TimeoutResponseActorApp extends App {\n  val system = ActorSystem(\"TimeoutResponseSystem\")\n  val actor = system.actorOf(Props[TimeoutResponseActor](), \"timeoutResponse\")\n  actor ! \"compute\"\n  Thread.sleep(2500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CircuitBreakerDemoActor in Scala that uses akka.pattern.CircuitBreaker to call a simulated unreliable service."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.CircuitBreaker\nimport scala.concurrent.Future\nimport scala.concurrent.duration._\nimport scala.util.{Success, Failure}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass CircuitBreakerDemoActor extends Actor {\n  val breaker = new CircuitBreaker(\n    scheduler = context.system.scheduler,\n    maxFailures = 2,\n    callTimeout = 1.second,\n    resetTimeout = 3.seconds\n  )\n\n  def unreliableService(): Future[String] = Future {\n    if (scala.util.Random.nextBoolean()) \"Service OK\" else throw new Exception(\"Service failed\")\n  }\n\n  def receive: Receive = {\n    case \"callService\" =>\n      val origSender = sender()\n      breaker.withCircuitBreaker(unreliableService()).onComplete {\n        case Success(result) => origSender ! result\n        case Failure(ex) => origSender ! s\"Error: ${ex.getMessage}\"\n      }\n  }\n}\n\nobject CircuitBreakerDemoActorApp extends App {\n  val system = ActorSystem(\"CircuitBreakerDemoSystem\")\n  val actor = system.actorOf(Props[CircuitBreakerDemoActor](), \"circuitBreakerDemo\")\n  actor ! \"callService\"\n  Thread.sleep(1500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SplitterActor in Scala that splits a received sentence into words and sends each word to a WordWorker actor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass WordWorker extends Actor {\n  def receive: Receive = {\n    case word: String => println(s\"WordWorker: Received word '$word'\")\n  }\n}\n\nclass SplitterActor(wordWorker: akka.actor.ActorRef) extends Actor {\n  def receive: Receive = {\n    case sentence: String =>\n      sentence.split(\" \").foreach(wordWorker ! _)\n  }\n}\n\nobject SplitterActorApp extends App {\n  val system = ActorSystem(\"SplitterSystem\")\n  val wordWorker = system.actorOf(Props[WordWorker](), \"wordWorker\")\n  val splitter = system.actorOf(Props(new SplitterActor(wordWorker)), \"splitter\")\n  splitter ! \"Split this sentence into words\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a WorkerPoolActor in Scala that uses a RoundRobinPool to process tasks by multiple Worker actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\ncase class Task(description: String)\n\nclass Worker extends Actor {\n  def receive: Receive = {\n    case Task(desc) => println(s\"${self.path.name} processing: $desc\")\n  }\n}\n\nobject WorkerPoolActorApp extends App {\n  val system = ActorSystem(\"WorkerPoolSystem\")\n  val router = system.actorOf(RoundRobinPool(3).props(Props[Worker]()), \"workerPool\")\n  router ! Task(\"Task 1\")\n  router ! Task(\"Task 2\")\n  router ! Task(\"Task 3\")\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a MergeActor in Scala that receives partial results from two actors and prints the merged result once both have arrived."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class PartialResult(result: String)\n\nclass MergeActor extends Actor {\n  var results = List.empty[String]\n  def receive: Receive = {\n    case PartialResult(res) =>\n      results = res :: results\n      if (results.size == 2) {\n        println(s\"MergeActor: Merged result: ${results.reverse.mkString(\" + \")}\")\n        results = Nil\n      }\n  }\n}\n\nobject MergeActorApp extends App {\n  val system = ActorSystem(\"MergeSystem\")\n  val mergeActor = system.actorOf(Props[MergeActor](), \"mergeActor\")\n  mergeActor ! PartialResult(\"Result1\")\n  mergeActor ! PartialResult(\"Result2\")\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a BatchingActor in Scala that batches messages received within 1 second and then processes the batch."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.collection.mutable.ListBuffer\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass BatchingActor extends Actor {\n  val buffer = ListBuffer.empty[String]\n  import context.dispatcher\n  context.system.scheduler.scheduleOnce(1.second, self, \"process\")\n\n  def receive: Receive = {\n    case msg: String => buffer += msg\n    case \"process\" =>\n      println(s\"BatchingActor: Processing batch: ${buffer.mkString(\", \")}\")\n      buffer.clear()\n      context.system.scheduler.scheduleOnce(1.second, self, \"process\")\n  }\n}\n\nobject BatchingActorApp extends App {\n  val system = ActorSystem(\"BatchingSystem\")\n  val actor = system.actorOf(Props[BatchingActor](), \"batchingActor\")\n  actor ! \"msg1\"\n  actor ! \"msg2\"\n  actor ! \"msg3\"\n  Thread.sleep(1500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SessionManagerActor in Scala that handles 'startSession' and 'endSession' messages and logs session events."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass SessionManagerActor extends Actor {\n  def receive: Receive = {\n    case \"startSession\" => println(\"SessionManagerActor: Session started\")\n    case \"endSession\" => println(\"SessionManagerActor: Session ended\")\n    case _ => println(\"SessionManagerActor: Unknown session command\")\n  }\n}\n\nobject SessionManagerActorApp extends App {\n  val system = ActorSystem(\"SessionManagerSystem\")\n  val actor = system.actorOf(Props[SessionManagerActor](), \"sessionManager\")\n  actor ! \"startSession\"\n  actor ! \"endSession\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DataFilterActor in Scala that filters out negative integers and only processes non-negative numbers."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass DataFilterActor extends Actor {\n  def receive: Receive = {\n    case n: Int if n >= 0 => println(s\"DataFilterActor: Processing $n\")\n    case n: Int => println(s\"DataFilterActor: Ignoring negative number $n\")\n    case _ => println(\"DataFilterActor: Unknown message\")\n  }\n}\n\nobject DataFilterActorApp extends App {\n  val system = ActorSystem(\"DataFilterSystem\")\n  val actor = system.actorOf(Props[DataFilterActor](), \"dataFilter\")\n  actor ! 10\n  actor ! -5\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a LoggerWithLevelsActor in Scala that logs messages at different levels based on the message prefix ('info:', 'warn:', 'error:')."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.event.Logging\n\nclass LoggerWithLevelsActor extends Actor {\n  val log = Logging(context.system, this)\n  def receive: Receive = {\n    case msg: String if msg.startsWith(\"info:\") => log.info(msg.stripPrefix(\"info:\"))\n    case msg: String if msg.startsWith(\"warn:\") => log.warning(msg.stripPrefix(\"warn:\"))\n    case msg: String if msg.startsWith(\"error:\") => log.error(msg.stripPrefix(\"error:\"))\n    case msg: String => log.debug(s\"Default log: $msg\")\n  }\n}\n\nobject LoggerWithLevelsActorApp extends App {\n  val system = ActorSystem(\"LoggerLevelsSystem\")\n  val actor = system.actorOf(Props[LoggerWithLevelsActor](), \"loggerLevels\")\n  actor ! \"info:This is an info message\"\n  actor ! \"warn:This is a warning\"\n  actor ! \"error:This is an error\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DynamicRouterActor in Scala that routes messages to different child actors based on message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\nclass DynamicRouterActor extends Actor {\n  val intChild: ActorRef = context.actorOf(Props[IntWorker](), \"intChild\")\n  val stringChild: ActorRef = context.actorOf(Props[StringWorker](), \"stringChild\")\n  \n  def receive: Receive = {\n    case i: Int => intChild ! i\n    case s: String => stringChild ! s\n    case _ => println(\"DynamicRouterActor: Unknown message\")\n  }\n}\n\nclass IntWorker extends Actor {\n  def receive: Receive = {\n    case i: Int => println(s\"IntWorker: Received $i\")\n  }\n}\n\nclass StringWorker extends Actor {\n  def receive: Receive = {\n    case s: String => println(s\"StringWorker: Received $s\")\n  }\n}\n\nobject DynamicRouterActorApp extends App {\n  val system = ActorSystem(\"DynamicRouterSystem\")\n  val router = system.actorOf(Props[DynamicRouterActor](), \"dynamicRouter\")\n  router ! 100\n  router ! \"Dynamic routing\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CommandParserActor in Scala that parses a command string and extracts the command and its parameter."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass CommandParserActor extends Actor {\n  def receive: Receive = {\n    case cmd: String =>\n      val parts = cmd.split(\":\")\n      if (parts.length == 2) {\n        println(s\"CommandParserActor: Command = ${parts(0)}, Parameter = ${parts(1)}\")\n      } else {\n        println(s\"CommandParserActor: Invalid command format: $cmd\")\n      }\n    case _ => println(\"CommandParserActor: Unknown message\")\n  }\n}\n\nobject CommandParserActorApp extends App {\n  val system = ActorSystem(\"CommandParserSystem\")\n  val actor = system.actorOf(Props[CommandParserActor](), \"commandParser\")\n  actor ! \"run:fast\"\n  actor ! \"stop:now\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a FeedbackActor in Scala that replies with a feedback message for any input message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass FeedbackActor extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! s\"FeedbackActor: Received your message: $msg\"\n  }\n}\n\nobject FeedbackActorApp extends App {\n  val system = ActorSystem(\"FeedbackSystem\")\n  val actor = system.actorOf(Props[FeedbackActor](), \"feedbackActor\")\n  actor.tell(\"This is a test\", actor)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DataFilterActor in Scala that filters out negative numbers."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass DataFilterActor extends Actor {\n  def receive: Receive = {\n    case n: Int if n >= 0 => println(s\"DataFilterActor: Processing $n\")\n    case n: Int => println(s\"DataFilterActor: Ignoring negative number $n\")\n    case _ => println(\"DataFilterActor: Unknown message\")\n  }\n}\n\nobject DataFilterActorApp extends App {\n  val system = ActorSystem(\"DataFilterSystem\")\n  val actor = system.actorOf(Props[DataFilterActor](), \"dataFilter\")\n  actor ! 10\n  actor ! -5\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a LoggerWithLevelsActor in Scala that logs messages at different levels based on the message prefix ('info:', 'warn:', 'error:')."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.event.Logging\n\nclass LoggerWithLevelsActor extends Actor {\n  val log = Logging(context.system, this)\n  def receive: Receive = {\n    case msg: String if msg.startsWith(\"info:\") => log.info(msg.stripPrefix(\"info:\"))\n    case msg: String if msg.startsWith(\"warn:\") => log.warning(msg.stripPrefix(\"warn:\"))\n    case msg: String if msg.startsWith(\"error:\") => log.error(msg.stripPrefix(\"error:\"))\n    case msg: String => log.debug(s\"Default log: $msg\")\n  }\n}\n\nobject LoggerWithLevelsActorApp extends App {\n  val system = ActorSystem(\"LoggerLevelsSystem\")\n  val actor = system.actorOf(Props[LoggerWithLevelsActor](), \"loggerLevels\")\n  actor ! \"info:This is an info message\"\n  actor ! \"warn:This is a warning\"\n  actor ! \"error:This is an error\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DynamicRouterActor in Scala that routes messages to different child actors based on message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\nclass DynamicRouterActor extends Actor {\n  val intChild: ActorRef = context.actorOf(Props[IntWorker](), \"intChild\")\n  val stringChild: ActorRef = context.actorOf(Props[StringWorker](), \"stringChild\")\n  \n  def receive: Receive = {\n    case i: Int => intChild ! i\n    case s: String => stringChild ! s\n    case _ => println(\"DynamicRouterActor: Unknown message\")\n  }\n}\n\nclass IntWorker extends Actor {\n  def receive: Receive = {\n    case i: Int => println(s\"IntWorker: Received $i\")\n  }\n}\n\nclass StringWorker extends Actor {\n  def receive: Receive = {\n    case s: String => println(s\"StringWorker: Received $s\")\n  }\n}\n\nobject DynamicRouterActorApp extends App {\n  val system = ActorSystem(\"DynamicRouterSystem\")\n  val router = system.actorOf(Props[DynamicRouterActor](), \"dynamicRouter\")\n  router ! 100\n  router ! \"Dynamic routing\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CommandParserActor in Scala that parses a command string and extracts the command and its parameter."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass CommandParserActor extends Actor {\n  def receive: Receive = {\n    case cmd: String =>\n      val parts = cmd.split(\":\")\n      if (parts.length == 2) {\n        println(s\"CommandParserActor: Command = ${parts(0)}, Parameter = ${parts(1)}\")\n      } else {\n        println(s\"CommandParserActor: Invalid command format: $cmd\")\n      }\n    case _ => println(\"CommandParserActor: Unknown message\")\n  }\n}\n\nobject CommandParserActorApp extends App {\n  val system = ActorSystem(\"CommandParserSystem\")\n  val actor = system.actorOf(Props[CommandParserActor](), \"commandParser\")\n  actor ! \"run:fast\"\n  actor ! \"stop:now\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a FeedbackActor in Scala that replies with a feedback message for any input message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass FeedbackActor extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! s\"FeedbackActor: Received your message: $msg\"\n  }\n}\n\nobject FeedbackActorApp extends App {\n  val system = ActorSystem(\"FeedbackSystem\")\n  val actor = system.actorOf(Props[FeedbackActor](), \"feedbackActor\")\n  actor.tell(\"This is a test\", actor)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DataFilterActor in Scala that filters out negative integers and only processes non-negative numbers."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass DataFilterActor extends Actor {\n  def receive: Receive = {\n    case n: Int if n >= 0 => println(s\"DataFilterActor: Processing $n\")\n    case n: Int => println(s\"DataFilterActor: Ignoring negative number $n\")\n    case _ => println(\"DataFilterActor: Unknown message\")\n  }\n}\n\nobject DataFilterActorApp extends App {\n  val system = ActorSystem(\"DataFilterSystem\")\n  val actor = system.actorOf(Props[DataFilterActor](), \"dataFilter\")\n  actor ! 10\n  actor ! -5\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a LoggerWithLevelsActor in Scala that logs messages at different levels based on the message prefix ('info:', 'warn:', 'error:')."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.event.Logging\n\nclass LoggerWithLevelsActor extends Actor {\n  val log = Logging(context.system, this)\n  def receive: Receive = {\n    case msg: String if msg.startsWith(\"info:\") => log.info(msg.stripPrefix(\"info:\"))\n    case msg: String if msg.startsWith(\"warn:\") => log.warning(msg.stripPrefix(\"warn:\"))\n    case msg: String if msg.startsWith(\"error:\") => log.error(msg.stripPrefix(\"error:\"))\n    case msg: String => log.debug(s\"Default log: $msg\")\n  }\n}\n\nobject LoggerWithLevelsActorApp extends App {\n  val system = ActorSystem(\"LoggerLevelsSystem\")\n  val actor = system.actorOf(Props[LoggerWithLevelsActor](), \"loggerLevels\")\n  actor ! \"info:This is an info message\"\n  actor ! \"warn:This is a warning\"\n  actor ! \"error:This is an error\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a DynamicRouterActor in Scala that routes messages to different child actors based on message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\nclass DynamicRouterActor extends Actor {\n  val intChild: ActorRef = context.actorOf(Props[IntWorker](), \"intChild\")\n  val stringChild: ActorRef = context.actorOf(Props[StringWorker](), \"stringChild\")\n  \n  def receive: Receive = {\n    case i: Int => intChild ! i\n    case s: String => stringChild ! s\n    case _ => println(\"DynamicRouterActor: Unknown message\")\n  }\n}\n\nclass IntWorker extends Actor {\n  def receive: Receive = {\n    case i: Int => println(s\"IntWorker: Received $i\")\n  }\n}\n\nclass StringWorker extends Actor {\n  def receive: Receive = {\n    case s: String => println(s\"StringWorker: Received $s\")\n  }\n}\n\nobject DynamicRouterActorApp extends App {\n  val system = ActorSystem(\"DynamicRouterSystem\")\n  val router = system.actorOf(Props[DynamicRouterActor](), \"dynamicRouter\")\n  router ! 100\n  router ! \"Dynamic routing\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CommandParserActor in Scala that parses a command string and extracts the command and its parameter."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass CommandParserActor extends Actor {\n  def receive: Receive = {\n    case cmd: String =>\n      val parts = cmd.split(\":\")\n      if (parts.length == 2) {\n        println(s\"CommandParserActor: Command = ${parts(0)}, Parameter = ${parts(1)}\")\n      } else {\n        println(s\"CommandParserActor: Invalid command format: $cmd\")\n      }\n    case _ => println(\"CommandParserActor: Unknown message\")\n  }\n}\n\nobject CommandParserActorApp extends App {\n  val system = ActorSystem(\"CommandParserSystem\")\n  val actor = system.actorOf(Props[CommandParserActor](), \"commandParser\")\n  actor ! \"run:fast\"\n  actor ! \"stop:now\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a FeedbackActor in Scala that replies with a feedback message for any input message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass FeedbackActor extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! s\"FeedbackActor: Received your message: $msg\"\n  }\n}\n\nobject FeedbackActorApp extends App {\n  val system = ActorSystem(\"FeedbackSystem\")\n  val actor = system.actorOf(Props[FeedbackActor](), \"feedbackActor\")\n  actor.tell(\"This is a test\", actor)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a StartupLogActor in Scala that logs a message in preStart to indicate it has started."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// StartupLogActor logs a specific message when the actor starts\nclass StartupLogActor extends Actor {\n  // Called when the actor is about to start\n  override def preStart(): Unit = {\n    println(\"StartupLogActor: The actor is starting up!\")\n    super.preStart()\n  }\n\n  def receive: Receive = {\n    case msg => println(s\"StartupLogActor received: $msg\")\n  }\n}\n\nobject StartupLogActorApp extends App {\n  // Create the ActorSystem\n  val system = ActorSystem(\"StartupLogSystem\")\n  // Create the actor\n  val logActor = system.actorOf(Props[StartupLogActor](), \"startupLogger\")\n\n  // Send a test message\n  logActor ! \"Hello World\"\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Build a LifecyclePrintActor in Scala that prints a message during postStop to announce its termination."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// LifecyclePrintActor prints a message when it's terminated\nclass LifecyclePrintActor extends Actor {\n  // postStop is called after the actor has been stopped\n  override def postStop(): Unit = {\n    println(\"LifecyclePrintActor: The actor has been stopped.\")\n    super.postStop()\n  }\n\n  def receive: Receive = {\n    case msg => println(s\"LifecyclePrintActor received: $msg\")\n  }\n}\n\nobject LifecyclePrintActorApp extends App {\n  val system = ActorSystem(\"LifecyclePrintSystem\")\n  val actor = system.actorOf(Props[LifecyclePrintActor](), \"lifecyclePrinter\")\n\n  actor ! \"Testing lifecycle\"\n\n  // Stop the actor to see postStop in action\n  system.stop(actor)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ChildTerminatorActor that spawns a child and then stops the child when it receives 'terminateChild'."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// A trivial child actor that just logs messages\nclass TerminatableChild extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"TerminatableChild received: $msg\")\n  }\n}\n\n// ChildTerminatorActor creates a child and can terminate it on command\nclass ChildTerminatorActor extends Actor {\n  val child: ActorRef = context.actorOf(Props[TerminatableChild](), \"terminatableChild\")\n\n  def receive: Receive = {\n    case \"terminateChild\" =>\n      println(\"ChildTerminatorActor: Terminating child actor.\")\n      context.stop(child)\n    case msg =>\n      child ! msg // forward any other message to the child\n  }\n}\n\nobject ChildTerminatorActorApp extends App {\n  val system = ActorSystem(\"ChildTerminatorSystem\")\n  val parent = system.actorOf(Props[ChildTerminatorActor](), \"parentActor\")\n\n  parent ! \"Hello child\"\n  parent ! \"terminateChild\"\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an AppendStringActor that appends a provided suffix to any incoming string."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// AppendStringActor appends a suffix to strings\nclass AppendStringActor(suffix: String) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      val updated = msg + suffix\n      println(s\"AppendStringActor: $updated\")\n    case _ => println(\"AppendStringActor: Received non-string message\")\n  }\n}\n\nobject AppendStringActorApp extends App {\n  // Provide a suffix in the constructor\n  val system = ActorSystem(\"AppendStringSystem\")\n  val appender = system.actorOf(Props(new AppendStringActor(\"_SUFFIX\")), \"appender\")\n\n  appender ! \"Hello\"\n  appender ! 123 // Non-string example\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Build a CustomMailboxLoggerActor that prints the name of the mailbox it is using, configured externally."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// CustomMailboxLoggerActor expects an externally defined mailbox\nclass CustomMailboxLoggerActor extends Actor {\n  override def preStart(): Unit = {\n    println(s\"CustomMailboxLoggerActor using mailbox: ${context.props.mailbox}\")\n    super.preStart()\n  }\n\n  def receive: Receive = {\n    case msg => println(s\"CustomMailboxLoggerActor received: $msg\")\n  }\n}\n\nobject CustomMailboxLoggerActorApp extends App {\n  val system = ActorSystem(\"CustomMailboxLoggerSystem\")\n  // You would define your mailbox config in application.conf\n  val actor = system.actorOf(\n    Props[CustomMailboxLoggerActor]().withMailbox(\"custom-mailbox\"),\n    \"mailboxLogger\"\n  )\n\n  actor ! \"Testing mailbox\"\n  Thread.sleep(500)\n  system.terminate()\n}\n\n// Note: The mailbox must be defined in your configuration, e.g.:\n// akka.actor.mailboxes {\n//   \"custom-mailbox\" {\n//     mailbox-type = \"com.example.CustomMailbox\"\n//   }\n// }\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a PausableActor that stashes messages when paused, and processes them once resumed."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\ncase object Pause\ncase object Resume\ncase class Data(value: String)\n\n// PausableActor demonstrates stashing behavior while paused\nclass PausableActor extends Actor with Stash {\n  def receive: Receive = running\n\n  def running: Receive = {\n    case Pause =>\n      println(\"PausableActor: Pausing actor and switching to paused behavior\")\n      context.become(paused)\n    case Data(v) => println(s\"PausableActor: Processing data -> $v\")\n    case _ => println(\"PausableActor: Unknown message\")\n  }\n\n  def paused: Receive = {\n    case Resume =>\n      println(\"PausableActor: Resuming and unstashing messages\")\n      unstashAll()\n      context.become(running)\n    case _ =>\n      println(\"PausableActor: Currently paused, stashing message\")\n      stash()\n  }\n}\n\nobject PausableActorApp extends App {\n  val system = ActorSystem(\"PausableSystem\")\n  val actor = system.actorOf(Props[PausableActor](), \"pausable\")\n\n  actor ! Data(\"Before pause\")\n  actor ! Pause\n  actor ! Data(\"While paused 1\")\n  actor ! Data(\"While paused 2\")\n  actor ! Resume\n  actor ! Data(\"After resume\")\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Construct a CountingSupervisor that restarts its child actor up to 3 times, then stops it."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy.{Restart, Stop}\nimport scala.concurrent.duration._\n\nclass FaultyCounterChild extends Actor {\n  var crashCount = 0\n  def receive: Receive = {\n    case \"explode\" =>\n      crashCount += 1\n      println(s\"FaultyCounterChild: Crashing attempt #$crashCount\")\n      throw new RuntimeException(\"Boom!\")\n    case _ => println(\"FaultyCounterChild: Normal message\")\n  }\n}\n\nclass CountingSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(maxNrOfRetries = 3, withinTimeRange = 1.minute) {\n    case _: RuntimeException => Restart\n  }\n\n  val child = context.actorOf(Props[FaultyCounterChild](), \"faultyChild\")\n\n  def receive: Receive = {\n    case msg => child.forward(msg)\n  }\n}\n\nobject CountingSupervisorApp extends App {\n  val system = ActorSystem(\"CountingSupervisorSystem\")\n  val supervisor = system.actorOf(Props[CountingSupervisor](), \"countingSupervisor\")\n  supervisor ! \"explode\"\n  supervisor ! \"explode\"\n  supervisor ! \"explode\"\n  supervisor ! \"explode\" // The 4th crash should lead to Stop\n\n  Thread.sleep(2000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Make a MultiResponderActor that responds differently to 'hi', 'bye', and any other message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass MultiResponderActor extends Actor {\n  def receive: Receive = {\n    case \"hi\" => sender() ! \"Hello!\"\n    case \"bye\" => sender() ! \"Goodbye!\"\n    case msg => sender() ! s\"I don't understand '$msg'\"\n  }\n}\n\nobject MultiResponderActorApp extends App {\n  val system = ActorSystem(\"MultiResponderSystem\")\n  val actor = system.actorOf(Props[MultiResponderActor](), \"multiResponder\")\n  // For demonstration, we can use actor as sender\n  actor.tell(\"hi\", actor)\n  actor.tell(\"bye\", actor)\n  actor.tell(\"something else\", actor)\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Write a DeduplicatingActor that remembers the last message and ignores duplicates."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass DeduplicatingActor extends Actor {\n  var lastMessage: Option[Any] = None\n\n  def receive: Receive = {\n    case msg =>\n      if (lastMessage.contains(msg)) {\n        println(s\"DeduplicatingActor: Ignoring duplicate: $msg\")\n      } else {\n        lastMessage = Some(msg)\n        println(s\"DeduplicatingActor: New message received: $msg\")\n      }\n  }\n}\n\nobject DeduplicatingActorApp extends App {\n  val system = ActorSystem(\"DeduplicatingSystem\")\n  val actor = system.actorOf(Props[DeduplicatingActor](), \"deduplicator\")\n  actor ! \"hello\"\n  actor ! \"hello\"\n  actor ! \"world\"\n  actor ! \"world\"\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Develop an FSM-based DoorActor that has states: Locked and Unlocked, transitions on Unlock or Lock messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{FSM, ActorSystem, Props}\nimport scala.concurrent.duration._\n\n// Door states\nsealed trait DoorState\ncase object Locked extends DoorState\ncase object Unlocked extends DoorState\n\n// Door data (none needed for this simple example)\nsealed trait DoorData\ncase object EmptyData extends DoorData\n\n// Messages\ncase object Lock\ncase object Unlock\n\nclass DoorActor extends FSM[DoorState, DoorData] {\n  startWith(Locked, EmptyData)\n\n  when(Locked) {\n    case Event(Unlock, _) =>\n      println(\"DoorActor: Transitioning from Locked to Unlocked\")\n      goto(Unlocked)\n  }\n\n  when(Unlocked) {\n    case Event(Lock, _) =>\n      println(\"DoorActor: Transitioning from Unlocked to Locked\")\n      goto(Locked)\n  }\n\n  initialize()\n}\n\nobject DoorActorApp extends App {\n  val system = ActorSystem(\"DoorSystem\")\n  val door = system.actorOf(Props[DoorActor](), \"doorActor\")\n\n  door ! Unlock\n  door ! Lock\n  door ! Unlock\n  door ! Lock\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Build a ThrottlingActor that processes only one message per 500 ms, buffering the rest, then processes the buffer next."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase object ProcessNext\n\nclass ThrottlingActor extends Actor with Stash {\n  var busy = false\n\n  def receive: Receive = {\n    case msg if !busy =>\n      busy = true\n      println(s\"ThrottlingActor: Processing $msg\")\n      context.system.scheduler.scheduleOnce(500.milliseconds, self, ProcessNext)\n    case msg =>\n      println(s\"ThrottlingActor: Stashing $msg while busy\")\n      stash()\n    case ProcessNext =>\n      busy = false\n      println(\"ThrottlingActor: Ready for next message, unstashing.\")\n      unstashAll()\n  }\n}\n\nobject ThrottlingActorApp extends App {\n  val system = ActorSystem(\"ThrottlingSystem\")\n  val actor = system.actorOf(Props[ThrottlingActor](), \"throttler\")\n\n  actor ! \"task1\"\n  actor ! \"task2\"\n  actor ! \"task3\"\n\n  Thread.sleep(2000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ParentInitializationActor that sends an Init message to each child upon creation."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase object Init\n\nclass ChildInitActor extends Actor {\n  def receive: Receive = {\n    case Init => println(s\"ChildInitActor [${self.path.name}] initialized!\")\n    case msg => println(s\"ChildInitActor [${self.path.name}] received: $msg\")\n  }\n}\n\nclass ParentInitializationActor extends Actor {\n  val child1: ActorRef = context.actorOf(Props[ChildInitActor](), \"child1\")\n  val child2: ActorRef = context.actorOf(Props[ChildInitActor](), \"child2\")\n\n  override def preStart(): Unit = {\n    super.preStart()\n    child1 ! Init\n    child2 ! Init\n  }\n\n  def receive: Receive = {\n    case msg =>\n      // Forward to children just as an example\n      child1 ! msg\n      child2 ! msg\n  }\n}\n\nobject ParentInitializationActorApp extends App {\n  val system = ActorSystem(\"ParentInitSystem\")\n  val parent = system.actorOf(Props[ParentInitializationActor](), \"parentInit\")\n  parent ! \"Hello children!\"\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Make a SwitchStateActor that uses become to toggle between collecting messages and printing them immediately."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.ListBuffer\n\ncase object StartCollecting\ncase object StopCollecting\ncase object Dump\ncase class Item(msg: String)\n\nclass SwitchStateActor extends Actor {\n  val buffer = ListBuffer.empty[String]\n\n  def receive: Receive = direct\n\n  def direct: Receive = {\n    case StartCollecting =>\n      println(\"SwitchStateActor: Switching to collection mode\")\n      context.become(collect)\n    case Item(m) => println(s\"Direct mode, printing immediately: $m\")\n    case _ => println(\"SwitchStateActor: Unknown message in direct mode\")\n  }\n\n  def collect: Receive = {\n    case Item(m) =>\n      println(s\"Collect mode, storing message: $m\")\n      buffer += m\n    case StopCollecting =>\n      println(\"SwitchStateActor: Switching back to direct mode\")\n      context.become(direct)\n    case Dump =>\n      println(s\"Collected messages: ${buffer.mkString(\", \")}\")\n      buffer.clear()\n    case _ => println(\"SwitchStateActor: Unknown message in collect mode\")\n  }\n}\n\nobject SwitchStateActorApp extends App {\n  val system = ActorSystem(\"SwitchStateSystem\")\n  val actor = system.actorOf(Props[SwitchStateActor](), \"switchActor\")\n\n  actor ! Item(\"First in direct\")\n  actor ! StartCollecting\n  actor ! Item(\"Col1\")\n  actor ! Item(\"Col2\")\n  actor ! Dump\n  actor ! StopCollecting\n  actor ! Item(\"Back in direct\")\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SortedCollectorActor that collects integer messages, sorts them, and prints them on 'printSorted'."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object PrintSorted\n\nclass SortedCollectorActor extends Actor {\n  var numbers = List.empty[Int]\n\n  def receive: Receive = {\n    case PrintSorted =>\n      val sorted = numbers.sorted\n      println(s\"SortedCollectorActor: $sorted\")\n    case i: Int =>\n      numbers = i :: numbers\n    case _ => println(\"SortedCollectorActor: Unknown message\")\n  }\n}\n\nobject SortedCollectorActorApp extends App {\n  val system = ActorSystem(\"SortedCollectorSystem\")\n  val actor = system.actorOf(Props[SortedCollectorActor](), \"sortedCollector\")\n\n  actor ! 10\n  actor ! 3\n  actor ! 7\n  actor ! PrintSorted\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Construct a WorkerPool with a custom router that routes to workers by hash of the message string."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.routing.ConsistentHashingPool\nimport akka.routing.ConsistentHashingRouter.ConsistentHashable\n\ncase class HashTask(msg: String) extends ConsistentHashable {\n  override def consistentHashKey: Any = msg\n}\n\nclass HashWorker extends Actor {\n  def receive: Receive = {\n    case HashTask(m) => println(s\"${self.path.name} processed: $m\")\n  }\n}\n\nobject HashRouterApp extends App {\n  val system = ActorSystem(\"HashRouterSystem\")\n  val router = system.actorOf(\n    ConsistentHashingPool(3).props(Props[HashWorker]()),\n    \"hashRouter\"\n  )\n\n  // Messages that share the same hash key are routed to the same worker\n  router ! HashTask(\"apple\")\n  router ! HashTask(\"banana\")\n  router ! HashTask(\"apple\")\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Design a SupervisorEscalateActor that escalates exceptions it doesn't understand to its own supervisor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy.{Resume, Escalate}\nimport scala.concurrent.duration._\n\nclass ChildForEscalation extends Actor {\n  def receive: Receive = {\n    case \"resumeError\" => throw new IllegalArgumentException(\"Resume-worthy error\")\n    case \"escalateError\" => throw new UnsupportedOperationException(\"Escalate error\")\n  }\n}\n\nclass SupervisorEscalateActor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy() {\n    case _: IllegalArgumentException => Resume\n    case _: UnsupportedOperationException => Escalate\n  }\n\n  val child = context.actorOf(Props[ChildForEscalation](), \"escalationChild\")\n\n  def receive: Receive = {\n    case msg => child.forward(msg)\n  }\n}\n\nobject SupervisorEscalateActorApp extends App {\n  val system = ActorSystem(\"EscalationSystem\")\n  val supervisor = system.actorOf(Props[SupervisorEscalateActor](), \"escalateSupervisor\")\n\n  supervisor ! \"resumeError\"\n  supervisor ! \"escalateError\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Make a PriorityMailboxExampleActor that uses a priority mailbox: high-priority messages always get processed first."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport com.typesafe.config.ConfigFactory\n\ncase class High(msg: String)\ncase class Low(msg: String)\n\n// PriorityMailboxExampleActor just prints messages in the order it receives them from the mailbox\nclass PriorityMailboxExampleActor extends Actor {\n  def receive: Receive = {\n    case High(m) => println(s\"HIGH PRIORITY: $m\")\n    case Low(m) => println(s\"low priority: $m\")\n  }\n}\n\nobject PriorityMailboxExampleApp extends App {\n  // Normally you'd configure the mailbox in application.conf\n  val config = ConfigFactory.parseString(\n    \"\"\"\n      akka {\n        actor {\n          mailboxes {\n            custom-priority-mailbox {\n              mailbox-type = \"com.example.CustomPriorityMailbox\"\n            }\n          }\n        }\n      }\n    \"\"\"\n  )\n  val system = ActorSystem(\"PriorityMailboxSystem\", config)\n  val actor = system.actorOf(\n    Props[PriorityMailboxExampleActor]().withMailbox(\"custom-priority-mailbox\"),\n    \"priorityExample\"\n  )\n\n  actor ! Low(\"This is low priority\")\n  actor ! High(\"This is high priority\")\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Develop an ErrorHandlerActor that catches arithmetic errors in the receive block and logs them."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ErrorHandlerActor extends Actor {\n  def receive: Receive = {\n    case n: Int =>\n      try {\n        val result = 100 / n\n        println(s\"ErrorHandlerActor: 100 / $n = $result\")\n      } catch {\n        case ex: ArithmeticException => println(s\"ErrorHandlerActor: Arithmetic error: ${ex.getMessage}\")\n      }\n    case _ => println(\"ErrorHandlerActor: Unknown message\")\n  }\n}\n\nobject ErrorHandlerActorApp extends App {\n  val system = ActorSystem(\"ErrorHandlerSystem\")\n  val actor = system.actorOf(Props[ErrorHandlerActor](), \"errorHandler\")\n\n  actor ! 10\n  actor ! 0\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Design a TimerTickActor that uses Timers trait to switch from 'tick' to 'tock' every second."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Timers}\nimport scala.concurrent.duration._\n\ncase object TickKey\ncase object TickMsg\ncase object TockMsg\n\nclass TimerTickActor extends Actor with Timers {\n  var isTick = true\n\n  // Start periodic timer\n  timers.startPeriodicTimer(TickKey, TickMsg, 1.second)\n\n  def receive: Receive = {\n    case TickMsg =>\n      if (isTick) {\n        println(\"TimerTickActor: Tick\")\n        isTick = false\n      } else {\n        self ! TockMsg\n      }\n    case TockMsg =>\n      println(\"TimerTickActor: Tock\")\n      isTick = true\n  }\n}\n\nobject TimerTickActorApp extends App {\n  val system = ActorSystem(\"TimerTickSystem\")\n  val actor = system.actorOf(Props[TimerTickActor](), \"timerTick\")\n\n  Thread.sleep(5000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Construct a SupervisorResumeActor that resumes a child on NullPointerException but restarts on IllegalArgumentException."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy.{Resume, Restart}\nimport scala.concurrent.duration._\n\nclass MixedChild extends Actor {\n  def receive: Receive = {\n    case \"null\" => throw new NullPointerException(\"Null pointer!\")\n    case \"illegal\" => throw new IllegalArgumentException(\"Bad argument!\")\n    case msg => println(s\"MixedChild received: $msg\")\n  }\n}\n\nclass SupervisorResumeActor extends Actor {\n  override val supervisorStrategy = OneForOneStrategy() {\n    case _: NullPointerException => Resume\n    case _: IllegalArgumentException => Restart\n  }\n\n  val child = context.actorOf(Props[MixedChild](), \"mixedChild\")\n\n  def receive: Receive = {\n    case msg => child.forward(msg)\n  }\n}\n\nobject SupervisorResumeActorApp extends App {\n  val system = ActorSystem(\"SupervisorResumeSystem\")\n  val supervisor = system.actorOf(Props[SupervisorResumeActor](), \"supervisor\")\n\n  supervisor ! \"null\"\n  supervisor ! \"illegal\"\n  supervisor ! \"hello\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RollingBufferActor that keeps a buffer of the last N messages and prints them on request."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object PrintBuffer\ncase class SetSize(n: Int)\n\nclass RollingBufferActor extends Actor {\n  var maxSize = 5\n  var buffer = List.empty[Any]\n\n  def receive: Receive = {\n    case SetSize(n) =>\n      maxSize = n\n      println(s\"RollingBufferActor: maxSize set to $n\")\n    case PrintBuffer =>\n      println(s\"RollingBufferActor: Buffer contents: ${buffer.mkString(\", \")}\")\n    case msg =>\n      buffer = (buffer :+ msg).takeRight(maxSize)\n  }\n}\n\nobject RollingBufferActorApp extends App {\n  val system = ActorSystem(\"RollingBufferSystem\")\n  val actor = system.actorOf(Props[RollingBufferActor](), \"rollingBuffer\")\n\n  actor ! \"msg1\"\n  actor ! \"msg2\"\n  actor ! \"msg3\"\n  actor ! SetSize(2)\n  actor ! \"msg4\"\n  actor ! PrintBuffer\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Implement a DelayedEchoActor that echoes messages back after a delay of 300 ms using a scheduler."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass DelayedEchoActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      val originalSender = sender()\n      context.system.scheduler.scheduleOnce(300.milliseconds) {\n        originalSender ! s\"Echo after delay: $msg\"\n      }\n  }\n}\n\nobject DelayedEchoActorApp extends App {\n  val system = ActorSystem(\"DelayedEchoSystem\")\n  val actor = system.actorOf(Props[DelayedEchoActor](), \"delayedEcho\")\n\n  // For demonstration, use the actor as sender\n  actor.tell(\"Test message\", actor)\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Build a MergeResultsActor that receives partial results from any number of children, merges them, and prints on 'merge'."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Partial(res: String)\ncase object Merge\n\nclass MergeResultsActor extends Actor {\n  var results = List.empty[String]\n\n  def receive: Receive = {\n    case Partial(r) =>\n      results = r :: results\n    case Merge =>\n      println(s\"Merged result: ${results.reverse.mkString(\" + \")}\")\n      results = Nil\n    case _ => println(\"MergeResultsActor: Unknown message\")\n  }\n}\n\nobject MergeResultsActorApp extends App {\n  val system = ActorSystem(\"MergeResultsSystem\")\n  val mergeActor = system.actorOf(Props[MergeResultsActor](), \"mergeActor\")\n\n  mergeActor ! Partial(\"Result1\")\n  mergeActor ! Partial(\"Result2\")\n  mergeActor ! Merge\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Construct a DelayedStateActor that transitions from 'idle' to 'active' automatically after 1 second using a scheduler."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass DelayedStateActor extends Actor {\n  override def preStart(): Unit = {\n    context.system.scheduler.scheduleOnce(1.second, self, \"activate\")\n  }\n\n  def receive: Receive = idle\n\n  def idle: Receive = {\n    case \"activate\" =>\n      println(\"DelayedStateActor: Transitioning to active state\")\n      context.become(active)\n    case _ => println(\"DelayedStateActor (idle): Received message\")\n  }\n\n  def active: Receive = {\n    case msg => println(s\"DelayedStateActor (active): Processing $msg\")\n  }\n}\n\nobject DelayedStateActorApp extends App {\n  val system = ActorSystem(\"DelayedStateSystem\")\n  val actor = system.actorOf(Props[DelayedStateActor](), \"delayedState\")\n\n  actor ! \"Test while idle\"\n  Thread.sleep(1500)\n  actor ! \"Test while active\"\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an AcknowledgingActor that replies with an 'ack' to every message it receives."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass AcknowledgingActor extends Actor {\n  def receive: Receive = {\n    case msg => sender() ! s\"ack: $msg\"\n  }\n}\n\nobject AcknowledgingActorApp extends App {\n  val system = ActorSystem(\"AcknowledgingSystem\")\n  val actor = system.actorOf(Props[AcknowledgingActor](), \"ackActor\")\n\n  actor.tell(\"Hello ack\", actor)\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Design a RotatingFSM that cycles among 3 states: State1, State2, State3, on each 'next' message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{FSM, ActorSystem, Props}\n\nsealed trait RotateState\ncase object State1 extends RotateState\ncase object State2 extends RotateState\ncase object State3 extends RotateState\n\nsealed trait RotateData\ncase object RotateEmpty extends RotateData\n\ncase object NextState\n\nclass RotatingFSM extends FSM[RotateState, RotateData] {\n  startWith(State1, RotateEmpty)\n\n  when(State1) {\n    case Event(NextState, _) =>\n      println(\"RotatingFSM: Moving from State1 to State2\")\n      goto(State2)\n  }\n  when(State2) {\n    case Event(NextState, _) =>\n      println(\"RotatingFSM: Moving from State2 to State3\")\n      goto(State3)\n  }\n  when(State3) {\n    case Event(NextState, _) =>\n      println(\"RotatingFSM: Moving from State3 to State1\")\n      goto(State1)\n  }\n\n  initialize()\n}\n\nobject RotatingFSMApp extends App {\n  val system = ActorSystem(\"RotatingFSMSystem\")\n  val rotator = system.actorOf(Props[RotatingFSM](), \"rotator\")\n\n  rotator ! NextState\n  rotator ! NextState\n  rotator ! NextState\n  rotator ! NextState\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Implement a ListenerActor that subscribes to DeadLetter and logs all dead letters received."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, DeadLetter, Props}\nimport akka.event.Logging\n\nclass DeadLetterListener extends Actor {\n  val log = Logging(context.system, this)\n\n  def receive: Receive = {\n    case DeadLetter(msg, from, to) =>\n      log.warning(s\"DeadLetter caught: $msg from $from to $to\")\n  }\n}\n\nobject ListenerActorApp extends App {\n  val system = ActorSystem(\"ListenerSystem\")\n  val listener = system.actorOf(Props[DeadLetterListener](), \"deadLetterListener\")\n\n  // Subscribe to dead letters\n  system.eventStream.subscribe(listener, classOf[DeadLetter])\n\n  // Attempt to send a message to a non-existent actor\n  system.actorSelection(\"/user/NoSuchActor\") ! \"Hello?\"\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Write a NameStashActor that stashes messages until it receives a 'SetName' message, then logs them with the name."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\ncase class SetName(name: String)\n\nclass NameStashActor extends Actor with Stash {\n  var currentName: Option[String] = None\n\n  def receive: Receive = {\n    case SetName(n) =>\n      currentName = Some(n)\n      println(s\"NameStashActor: Name set to $n, unstashing messages.\")\n      unstashAll()\n      context.become(named)\n    case msg =>\n      println(\"NameStashActor: Stashing until name is set.\")\n      stash()\n  }\n\n  def named: Receive = {\n    case SetName(n) =>\n      currentName = Some(n)\n      println(s\"NameStashActor: Updated name to $n\")\n    case msg =>\n      println(s\"NameStashActor [${currentName.get}]: Processing $msg\")\n  }\n}\n\nobject NameStashActorApp extends App {\n  val system = ActorSystem(\"NameStashSystem\")\n  val actor = system.actorOf(Props[NameStashActor](), \"nameStash\")\n\n  actor ! \"Msg1\"\n  actor ! \"Msg2\"\n  actor ! SetName(\"Alice\")\n  actor ! \"Msg3\"\n  actor ! SetName(\"Bob\")\n  actor ! \"Msg4\"\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Design a ValueTrackerActor that starts at an integer value and increments or decrements on commands."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Inc\ncase object Dec\n\nclass ValueTrackerActor(start: Int) extends Actor {\n  var current = start\n\n  def receive: Receive = {\n    case Inc =>\n      current += 1\n      println(s\"ValueTrackerActor: Value is now $current\")\n    case Dec =>\n      current -= 1\n      println(s\"ValueTrackerActor: Value is now $current\")\n    case _ => println(\"ValueTrackerActor: Unknown message\")\n  }\n}\n\nobject ValueTrackerActorApp extends App {\n  val system = ActorSystem(\"ValueTrackerSystem\")\n  val tracker = system.actorOf(Props(new ValueTrackerActor(10)), \"tracker\")\n\n  tracker ! Inc\n  tracker ! Dec\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Construct a ProxyActor that holds a reference to a 'real' actor and forwards all messages to it."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass RealActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"RealActor processing: $msg\")\n  }\n}\n\nclass ProxyActor(real: akka.actor.ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ProxyActor: Forwarding $msg to real actor\")\n      real.forward(msg)\n  }\n}\n\nobject ProxyActorApp extends App {\n  val system = ActorSystem(\"ProxySystem\")\n  val realActor = system.actorOf(Props[RealActor](), \"real\")\n  val proxy = system.actorOf(Props(new ProxyActor(realActor)), \"proxy\")\n\n  proxy ! \"Hello through proxy\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Build a ConfigCheckActor that reads two config values and logs them in preStart."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ConfigCheckActor extends Actor {\n  val config = context.system.settings.config\n  val value1 = config.getString(\"myapp.value1\")\n  val value2 = config.getString(\"myapp.value2\")\n\n  override def preStart(): Unit = {\n    println(s\"ConfigCheckActor starting. value1=$value1, value2=$value2\")\n    super.preStart()\n  }\n\n  def receive: Receive = {\n    case _ => println(\"ConfigCheckActor: Received message\")\n  }\n}\n\nobject ConfigCheckActorApp extends App {\n  // Ensure application.conf has myapp.value1 and myapp.value2\n  val system = ActorSystem(\"ConfigCheckSystem\")\n  val actor = system.actorOf(Props[ConfigCheckActor](), \"configChecker\")\n\n  actor ! \"test\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Make a WeightedRandomRouter that randomly sends messages to 3 workers, with different weights."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.routing.SmallestMailboxPool\n\ncase class WeightedTask(task: String)\n\nclass WeightedWorker(id: Int) extends Actor {\n  def receive: Receive = {\n    case WeightedTask(t) => println(s\"WeightedWorker-$id handling task: $t\")\n  }\n}\n\nobject WeightedRandomRouterApp extends App {\n  val system = ActorSystem(\"WeightedRandomRouterSystem\")\n\n  // For a real weighted random approach, you'd implement a custom router.\n  // Here, we'll just demonstrate a smallest mailbox pool as a placeholder.\n  val router = system.actorOf(SmallestMailboxPool(3).props(Props(classOf[WeightedWorker], 0)), \"weightedRouter\")\n\n  router ! WeightedTask(\"Task A\")\n  router ! WeightedTask(\"Task B\")\n  router ! WeightedTask(\"Task C\")\n\n  Thread.sleep(500)\n  system.terminate()\n}\n\n// Note: For true weighted routing, you would use a custom router logic or an external library.\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Construct a PrintOnceActor that only prints the first message it sees, ignoring the rest."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass PrintOnceActor extends Actor {\n  var printed = false\n\n  def receive: Receive = {\n    case msg if !printed =>\n      println(s\"PrintOnceActor: First message is $msg\")\n      printed = true\n    case _ => // do nothing\n  }\n}\n\nobject PrintOnceActorApp extends App {\n  val system = ActorSystem(\"PrintOnceSystem\")\n  val actor = system.actorOf(Props[PrintOnceActor](), \"printOnce\")\n\n  actor ! \"Message1\"\n  actor ! \"Message2\"\n  actor ! \"Message3\"\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Design a StickyRoundRobinActor that cycles through a list of recipients, sending each new message to the next actor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase class Recipients(list: List[ActorRef])\n\nclass StickyRoundRobinActor extends Actor {\n  var recipients: List[ActorRef] = Nil\n  var index = 0\n\n  def receive: Receive = {\n    case Recipients(list) =>\n      recipients = list\n      println(\"StickyRoundRobinActor: Recipients updated\")\n    case msg =>\n      if (recipients.nonEmpty) {\n        recipients(index) ! msg\n        index = (index + 1) % recipients.size\n      } else {\n        println(\"StickyRoundRobinActor: No recipients to route to\")\n      }\n  }\n}\n\nclass PrintTargetActor(id: Int) extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"PrintTargetActor-$id received: $msg\")\n  }\n}\n\nobject StickyRoundRobinActorApp extends App {\n  val system = ActorSystem(\"StickyRoundRobinSystem\")\n\n  val target1 = system.actorOf(Props(new PrintTargetActor(1)), \"target1\")\n  val target2 = system.actorOf(Props(new PrintTargetActor(2)), \"target2\")\n  val target3 = system.actorOf(Props(new PrintTargetActor(3)), \"target3\")\n\n  val roundRobin = system.actorOf(Props[StickyRoundRobinActor](), \"roundRobin\")\n  roundRobin ! Recipients(List(target1, target2, target3))\n\n  roundRobin ! \"Alpha\"\n  roundRobin ! \"Beta\"\n  roundRobin ! \"Gamma\"\n  roundRobin ! \"Delta\"\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Implement a ReverseStringActor that reverses any string it receives and logs the reversed output."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass ReverseStringActor extends Actor {\n  def receive: Receive = {\n    case s: String =>\n      val reversed = s.reverse\n      println(s\"ReverseStringActor: $s reversed is $reversed\")\n    case _ => println(\"ReverseStringActor: Unknown message\")\n  }\n}\n\nobject ReverseStringActorApp extends App {\n  val system = ActorSystem(\"ReverseStringSystem\")\n  val actor = system.actorOf(Props[ReverseStringActor](), \"reverseActor\")\n\n  actor ! \"Akka\"\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Write a OneTimeSchedulerActor that schedules a single 'reminder' message to itself after a short delay, then ignores further attempts."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass OneTimeSchedulerActor extends Actor {\n  var scheduled: Option[Cancellable] = None\n\n  def receive: Receive = {\n    case \"schedule\" if scheduled.isEmpty =>\n      println(\"OneTimeSchedulerActor: Scheduling a one-time reminder\")\n      scheduled = Some(context.system.scheduler.scheduleOnce(1.second, self, \"reminder\"))\n    case \"schedule\" =>\n      println(\"OneTimeSchedulerActor: Already scheduled, ignoring.\")\n    case \"reminder\" =>\n      println(\"OneTimeSchedulerActor: Reminder triggered!\")\n    case _ => println(\"OneTimeSchedulerActor: Unknown message\")\n  }\n}\n\nobject OneTimeSchedulerActorApp extends App {\n  val system = ActorSystem(\"OneTimeSchedulerSystem\")\n  val actor = system.actorOf(Props[OneTimeSchedulerActor](), \"oneTimer\")\n\n  actor ! \"schedule\"\n  Thread.sleep(500)\n  actor ! \"schedule\" // This will be ignored because it's already scheduled\n\n  Thread.sleep(2000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a simple HelloWorld typed actor using akka-actor-typed, with a Behavior that logs messages."
      },
      {
        "from": "assistant",
        "value": "// HelloWorldTyped.scala\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\n\nobject HelloWorldTyped {\n  // Define messages\n  final case class Greet(name: String)\n\n  // Define the behavior\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(s\"Hello, ${message.name} from typed actor!\")\n    Behaviors.same\n  }\n}\n\nobject HelloWorldTypedApp extends App {\n  // Create the ActorSystem for our typed actor\n  val system = ActorSystem(HelloWorldTyped(), \"HelloWorldTypedSystem\")\n\n  // Send a message\n  system ! HelloWorldTyped.Greet(\"Akka Typed\")\n\n  // Give it a moment, then terminate\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Demonstrate a typed actor that changes its behavior upon a 'switch' message, using context.become in typed style."
      },
      {
        "from": "assistant",
        "value": "// SwitchBehaviorTyped.scala\n\nimport akka.actor.typed.scaladsl.{Behaviors, ActorContext}\nimport akka.actor.typed.{ActorSystem, Behavior}\n\nobject SwitchBehaviorTyped {\n  sealed trait Command\n  case object Switch extends Command\n  case class Message(content: String) extends Command\n\n  // Behavior A logs as \"Mode A\"; Behavior B logs as \"Mode B\"\n  def modeA: Behavior[Command] = Behaviors.receive { (context, msg) =>\n    msg match {\n      case Switch =>\n        context.log.info(\"Switching from Mode A to Mode B.\")\n        modeB\n      case Message(text) =>\n        context.log.info(s\"Mode A received: $text\")\n        Behaviors.same\n      case _ => Behaviors.same\n    }\n  }\n\n  def modeB: Behavior[Command] = Behaviors.receive { (context, msg) =>\n    msg match {\n      case Switch =>\n        context.log.info(\"Switching from Mode B to Mode A.\")\n        modeA\n      case Message(text) =>\n        context.log.info(s\"Mode B received: $text\")\n        Behaviors.same\n      case _ => Behaviors.same\n    }\n  }\n\n  // Start in modeA\n  def apply(): Behavior[Command] = modeA\n}\n\nobject SwitchBehaviorTypedApp extends App {\n  import SwitchBehaviorTyped._\n\n  val system = ActorSystem(SwitchBehaviorTyped(), \"SwitchBehaviorTypedSystem\")\n  system ! Message(\"Hello in A\")\n  system ! Switch\n  system ! Message(\"Now in B\")\n  system ! Switch\n  system ! Message(\"Back to A\")\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Show how to create a typed actor that uses Behaviors.withTimers to schedule a periodic Tick message and log it."
      },
      {
        "from": "assistant",
        "value": "// TimerTypedActor.scala\n\nimport akka.actor.typed.scaladsl.{Behaviors, TimerScheduler}\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport scala.concurrent.duration._\n\nobject TimerTypedActor {\n  sealed trait Command\n  private case object TickKey\n  case object Tick extends Command\n\n  def apply(): Behavior[Command] = Behaviors.withTimers { (timers: TimerScheduler[Command]) =>\n    // Schedule a periodic Tick every 1 second\n    timers.startTimerWithFixedDelay(TickKey, Tick, 1.second)\n\n    Behaviors.receive { (context, message) =>\n      message match {\n        case Tick =>\n          context.log.info(\"TimerTypedActor: TICK\")\n          Behaviors.same\n      }\n    }\n  }\n}\n\nobject TimerTypedActorApp extends App {\n  val system = ActorSystem(TimerTypedActor(), \"TimerTypedSystem\")\n  Thread.sleep(3000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Show a simple example of an Akka Streams Source that emits numbers from 1 to 5 and prints them to the console."
      },
      {
        "from": "assistant",
        "value": "// SimpleAkkaStream.scala\n\nimport akka.actor.ActorSystem\nimport akka.stream.scaladsl.{Sink, Source}\n\nobject SimpleAkkaStreamApp extends App {\n  implicit val system: ActorSystem = ActorSystem(\"SimpleStreamSystem\")\n\n  // A source of integers 1 to 5\n  val source = Source(1 to 5)\n\n  // Print each element to the console\n  val sink = Sink.foreach[Int](num => println(s\"Stream element: $num\"))\n\n  // Run the stream\n  source.runWith(sink)\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an example of Akka HTTP server that responds with 'Hello from Akka HTTP' to any GET request on /hello."
      },
      {
        "from": "assistant",
        "value": "// SimpleAkkaHttpServer.scala\n\nimport akka.actor.ActorSystem\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.server.Directives._\nimport akka.http.scaladsl.server.Route\nimport akka.stream.ActorMaterializer\nimport scala.concurrent.ExecutionContextExecutor\nimport scala.io.StdIn\n\nobject SimpleAkkaHttpServer extends App {\n  implicit val system: ActorSystem = ActorSystem(\"AkkaHttpSystem\")\n  implicit val dispatcher: ExecutionContextExecutor = system.dispatcher\n  implicit val materializer: ActorMaterializer = ActorMaterializer()(system)\n\n  val route: Route =\n    path(\"hello\") {\n      get {\n        complete(\"Hello from Akka HTTP\")\n      }\n    }\n\n  val bindingFuture = Http().bindAndHandle(route, \"localhost\", 8080)\n  println(\"Server online at http://localhost:8080/hello\\nPress RETURN to stop...\")\n  StdIn.readLine() // Wait for user input to stop\n\n  bindingFuture\n    .flatMap(_.unbind())\n    .onComplete(_ => system.terminate())\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an example typed actor that uses a standard typed Supervision strategy (restart on any exception)."
      },
      {
        "from": "assistant",
        "value": "// TypedSupervisionExample.scala\n\nimport akka.actor.typed.{ActorSystem, Behavior, SupervisorStrategy}\nimport akka.actor.typed.scaladsl.Behaviors\nimport scala.concurrent.duration._\n\nobject FaultyTypedBehavior {\n  sealed trait Command\n  case object Fail extends Command\n\n  def apply(): Behavior[Command] = Behaviors.receive { (context, message) =>\n    message match {\n      case Fail =>\n        context.log.info(\"FaultyTypedBehavior: Throwing exception!\")\n        throw new RuntimeException(\"Failure!\")\n    }\n  }\n}\n\nobject SupervisedTypedBehavior {\n  import FaultyTypedBehavior._\n\n  def apply(): Behavior[Command] = Behaviors.supervise(FaultyTypedBehavior())\n    .onFailure[RuntimeException](SupervisorStrategy.restart.withLimit(maxNrOfRetries = 3, withinTimeRange = 1.second))\n}\n\nobject TypedSupervisionExampleApp extends App {\n  val system = ActorSystem(SupervisedTypedBehavior(), \"TypedSupervisionSystem\")\n\n  system ! FaultyTypedBehavior.Fail\n  system ! FaultyTypedBehavior.Fail\n  system ! FaultyTypedBehavior.Fail\n\n  Thread.sleep(2000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Illustrate a typed actor Behavior that uses onSignal to handle a PostStop signal."
      },
      {
        "from": "assistant",
        "value": "// TypedOnSignalExample.scala\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior, PostStop}\n\nobject OnSignalActor {\n  sealed trait Command\n  case object StopMe extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { context =>\n    Behaviors.receiveMessage[Command] {\n      case StopMe =>\n        context.log.info(\"Received StopMe, stopping...\")\n        Behaviors.stopped\n    }.receiveSignal {\n      case (ctx, PostStop) =>\n        ctx.log.info(\"OnSignalActor: PostStop signal received.\")\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedOnSignalExampleApp extends App {\n  val system = ActorSystem(OnSignalActor(), \"OnSignalSystem\")\n\n  system ! OnSignalActor.StopMe\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Build a typed actor that acts as an HTTP client using Akka HTTP, fetching data from a public API and logging the response."
      },
      {
        "from": "assistant",
        "value": "// TypedHttpClientActor.scala\n\nimport akka.actor.typed.scaladsl.{Behaviors, ActorContext}\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.model.HttpRequest\nimport akka.http.scaladsl.unmarshalling.Unmarshal\nimport akka.stream.Materializer\nimport scala.concurrent.ExecutionContext\n\nobject HttpClientActor {\n  sealed trait Command\n  case object FetchData extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { context =>\n    implicit val classicSystem = context.system.classicSystem\n    implicit val ec: ExecutionContext = context.executionContext\n    implicit val mat: Materializer = Materializer(classicSystem)\n\n    Behaviors.receiveMessage {\n      case FetchData =>\n        val responseF = Http()(classicSystem).singleRequest(HttpRequest(uri = \"https://jsonplaceholder.typicode.com/posts/1\"))\n        responseF.foreach { response =>\n          Unmarshal(response.entity).to[String].foreach { body =>\n            context.log.info(s\"HTTP response body: $body\")\n          }\n        }\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedHttpClientActorApp extends App {\n  val system = ActorSystem(HttpClientActor(), \"TypedHttpClientSystem\")\n\n  system ! HttpClientActor.FetchData\n\n  Thread.sleep(3000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a typed actor system that uses config from application.conf to log custom settings on startup."
      },
      {
        "from": "assistant",
        "value": "// ConfigLoggingTyped.scala\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\n\nobject ConfigLoggingTyped {\n  sealed trait Command\n  case object PrintConfig extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { context =>\n    val someSetting = context.system.settings.config.getString(\"custom.setting\")\n    context.log.info(s\"Actor started with custom.setting = $someSetting\")\n\n    Behaviors.receiveMessage {\n      case PrintConfig =>\n        context.log.info(s\"Current config says: $someSetting\")\n        Behaviors.same\n    }\n  }\n}\n\nobject ConfigLoggingTypedApp extends App {\n  // In application.conf, define: custom.setting = \"Hello Config\"\n  val system = ActorSystem(ConfigLoggingTyped(), \"ConfigLoggingSystem\")\n  system ! ConfigLoggingTyped.PrintConfig\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Demonstrate a typed cluster with a receptionist-based service discovery, where a 'PingService' registers itself and 'Client' finds it."
      },
      {
        "from": "assistant",
        "value": "// TypedClusterReceptionistExample.scala\n\nimport akka.actor.typed.scaladsl.{Behaviors, ActorContext}\nimport akka.actor.typed.{ActorRef, ActorSystem, Behavior}\nimport akka.cluster.typed.{Cluster, SelfUp, Subscribe}\nimport akka.actor.typed.receptionist.{Receptionist, ServiceKey}\n\nobject PingService {\n  val PingKey = ServiceKey[PingCommand](\"PingService\")\n\n  sealed trait PingCommand\n  case class Ping(replyTo: ActorRef[String]) extends PingCommand\n\n  def apply(): Behavior[PingCommand] = Behaviors.setup { ctx =>\n    // Register this service\n    ctx.system.receptionist ! Receptionist.Register(PingKey, ctx.self)\n\n    Behaviors.receiveMessage {\n      case Ping(replyTo) =>\n        replyTo ! \"Pong\"\n        Behaviors.same\n    }\n  }\n}\n\nobject Client {\n  import PingService._\n\n  sealed trait Command\n  case object FindPingService extends Command\n  case class WrappedListing(listing: Receptionist.Listing) extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { ctx =>\n    val listingAdapter = ctx.messageAdapter[Receptionist.Listing](WrappedListing)\n\n    Behaviors.receiveMessage {\n      case FindPingService =>\n        ctx.system.receptionist ! Receptionist.Find(PingKey, listingAdapter)\n        Behaviors.same\n      case WrappedListing(PingService.PingKey.Listing(listings)) =>\n        listings.foreach { pingRef =>\n          ctx.log.info(\"Found PingService, sending Ping...\")\n          pingRef ! Ping(ctx.messageAdapter[String](rsp => {\n            ctx.log.info(s\"Received: $rsp\")\n            FindPingService // or some other next action\n          }))\n        }\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedClusterReceptionistExampleApp extends App {\n  val system = ActorSystem(Behaviors.setup[Nothing] { ctx =>\n    ctx.spawn(PingService(), \"PingActor\")\n    val client = ctx.spawn(Client(), \"ClientActor\")\n    client ! Client.FindPingService\n    Behaviors.empty\n  }, \"ReceptionistCluster\")\n\n  Thread.sleep(5000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a typed actor cluster example that uses a cluster aware router to send messages to typed actors on different nodes."
      },
      {
        "from": "assistant",
        "value": "// TypedClusterAwareRouterExample.scala\n// Note: Akka 2.6+ uses group or pool routers, but typed cluster-based routing often requires custom approach.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorRef, ActorSystem, Behavior}\nimport akka.cluster.typed.{Cluster, SelfUp, Subscribe}\nimport akka.actor.typed.receptionist.{Receptionist, ServiceKey}\n\nobject Worker {\n  val WorkerKey = ServiceKey[Command](\"WorkerService\")\n\n  sealed trait Command\n  case class Work(payload: String) extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { ctx =>\n    // Register with receptionist\n    ctx.system.receptionist ! Receptionist.Register(WorkerKey, ctx.self)\n\n    Behaviors.receiveMessage {\n      case Work(payload) =>\n        ctx.log.info(s\"Processing work: $payload on ${ctx.self.path}\")\n        Behaviors.same\n    }\n  }\n}\n\nobject Router {\n  import Worker._\n  sealed trait RouterCommand\n  case class Dispatch(payload: String) extends RouterCommand\n  private case class ListingResponse(listing: Receptionist.Listing) extends RouterCommand\n\n  def apply(): Behavior[RouterCommand] = Behaviors.setup { ctx =>\n    val adapter = ctx.messageAdapter[Receptionist.Listing](ListingResponse)\n    ctx.system.receptionist ! Receptionist.Subscribe(Worker.WorkerKey, adapter)\n\n    var workers = Set.empty[ActorRef[Worker.Command]]\n\n    Behaviors.receiveMessage {\n      case ListingResponse(Worker.WorkerKey.Listing(newWorkers)) =>\n        workers = newWorkers\n        ctx.log.info(s\"Router: Updated worker set: $workers\")\n        Behaviors.same\n      case Dispatch(payload) =>\n        // Simple round-robin or random approach\n        workers.headOption.foreach(ref => ref ! Work(payload))\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedClusterAwareRouterExampleApp extends App {\n  val system = ActorSystem(Behaviors.setup[Nothing] { ctx =>\n    // Spawn a worker and a router\n    ctx.spawn(Worker(), \"worker1\")\n    val router = ctx.spawn(Router(), \"router\")\n\n    // After a short delay, dispatch some work\n    ctx.scheduleOnce(scala.concurrent.duration.DurationInt(2).seconds, router, Router.Dispatch(\"some cluster work\"))\n\n    Behaviors.empty\n  }, \"ClusterAwareRouter\")\n\n  Thread.sleep(10000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an example of an Akka Streams Flow that capitalizes strings, used between a Source of strings and a Sink that logs them."
      },
      {
        "from": "assistant",
        "value": "// CapitalizeFlowExample.scala\n\nimport akka.actor.ActorSystem\nimport akka.stream.ActorMaterializer\nimport akka.stream.scaladsl.{Flow, Sink, Source}\nimport scala.concurrent.ExecutionContextExecutor\n\nobject CapitalizeFlowExample extends App {\n  implicit val system: ActorSystem = ActorSystem(\"CapFlowSystem\")\n  implicit val ec: ExecutionContextExecutor = system.dispatcher\n  implicit val mat: ActorMaterializer = ActorMaterializer()(system)\n\n  val source = Source(List(\"hello\", \"akka\", \"streams\"))\n\n  // Flow that transforms strings to uppercase\n  val capitalizeFlow = Flow[String].map(_.toUpperCase)\n\n  val sink = Sink.foreach[String](s => println(s\"Got: $s\"))\n\n  val runnable = source.via(capitalizeFlow).to(sink)\n  runnable.run()\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a typed Streams example that uses a RestartSource to automatically restart on failures."
      },
      {
        "from": "assistant",
        "value": "// RestartSourceExample.scala\n\nimport akka.actor.ActorSystem\nimport akka.stream.ActorMaterializer\nimport akka.stream.scaladsl.{RestartSource, Sink, Source}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContextExecutor\nimport scala.util.Random\n\nobject RestartSourceExample extends App {\n  implicit val system: ActorSystem = ActorSystem(\"RestartSourceSystem\")\n  implicit val ec: ExecutionContextExecutor = system.dispatcher\n  implicit val mat: ActorMaterializer = ActorMaterializer()(system)\n\n  val failingSource = Source(1 to 10).map { n =>\n    if (Random.nextBoolean()) n else throw new RuntimeException(\"Random fail!\")\n  }\n\n  val restarting = RestartSource.onFailuresWithBackoff(\n    minBackoff = 1.second,\n    maxBackoff = 5.seconds,\n    randomFactor = 0.2\n  ) { () => failingSource }\n\n  val done = restarting.runWith(Sink.foreach(elem => println(s\"Got element: $elem\")))\n\n  done.onComplete(_ => system.terminate())\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Demonstrate an Akka Streams example that uses a Broadcast to split the flow into two parallel consumers."
      },
      {
        "from": "assistant",
        "value": "// BroadcastStreamExample.scala\n\nimport akka.actor.ActorSystem\nimport akka.stream.{ActorMaterializer, ClosedShape}\nimport akka.stream.scaladsl.{Broadcast, GraphDSL, Sink, Source}\nimport scala.concurrent.ExecutionContextExecutor\n\nobject BroadcastStreamExample extends App {\n  implicit val system: ActorSystem = ActorSystem(\"BroadcastStreamSystem\")\n  implicit val ec: ExecutionContextExecutor = system.dispatcher\n  implicit val mat: ActorMaterializer = ActorMaterializer()(system)\n\n  val source = Source(1 to 5)\n  val sink1 = Sink.foreach[Int](x => println(s\"Sink1 got: $x\"))\n  val sink2 = Sink.foreach[Int](x => println(s\"Sink2 got: $x\"))\n\n  val graph = akka.stream.scaladsl.RunnableGraph.fromGraph(GraphDSL.create() { implicit builder =>\n    import GraphDSL.Implicits._\n\n    val broadcast = builder.add(Broadcast[Int](2))\n\n    source ~> broadcast.in\n    broadcast.out(0) ~> sink1\n    broadcast.out(1) ~> sink2\n\n    ClosedShape\n  })\n\n  graph.run()\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Show an example typed actor that, on a 'startHttpServer' message, spins up a minimal Akka HTTP server, then logs requests."
      },
      {
        "from": "assistant",
        "value": "// TypedActorHttpServerOnDemand.scala\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.server.Directives._\nimport akka.http.scaladsl.model.StatusCodes\nimport akka.stream.Materializer\nimport scala.concurrent.ExecutionContext\nimport scala.util.{Failure, Success}\n\nobject OnDemandHttpActor {\n  sealed trait Command\n  case object StartHttpServer extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { context =>\n    implicit val classicSystem = context.system.classicSystem\n    implicit val mat: Materializer = Materializer(classicSystem)\n    implicit val ec: ExecutionContext = context.executionContext\n\n    val route = path(\"test\") {\n      get {\n        context.log.info(\"Request on /test\")\n        complete(StatusCodes.OK -> \"Hello from typed actor!\")\n      }\n    }\n\n    Behaviors.receiveMessage {\n      case StartHttpServer =>\n        val bindingFuture = Http()(classicSystem).newServerAt(\"localhost\", 9000).bind(route)\n        bindingFuture.onComplete {\n          case Success(binding) => context.log.info(s\"HTTP server running at ${binding.localAddress}\")\n          case Failure(ex) => context.log.error(s\"Failed to bind HTTP server: ${ex.getMessage}\")\n        }\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedActorHttpServerOnDemandApp extends App {\n  val system = ActorSystem(OnDemandHttpActor(), \"OnDemandHttpSystem\")\n  system ! OnDemandHttpActor.StartHttpServer\n\n  Thread.sleep(30000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Use Akka HTTP client in a typed actor to post JSON data to a server, showing how to construct the request entity."
      },
      {
        "from": "assistant",
        "value": "// TypedHttpPostActor.scala\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.model._\nimport akka.http.scaladsl.model.ContentTypes.`application/json`\nimport akka.stream.Materializer\nimport scala.concurrent.ExecutionContext\nimport scala.util.{Failure, Success}\n\nobject HttpPostActor {\n  sealed trait Command\n  case object SendPost extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { context =>\n    implicit val classicSystem = context.system.classicSystem\n    implicit val mat: Materializer = Materializer(classicSystem)\n    implicit val ec: ExecutionContext = context.executionContext\n\n    val jsonString = \"\"\"{\"some\": \"data\"}\"\"\"\n    val entity = HttpEntity(`application/json`, jsonString)\n\n    Behaviors.receiveMessage {\n      case SendPost =>\n        val responseF = Http()(classicSystem).singleRequest(HttpRequest(\n          method = HttpMethods.POST,\n          uri = \"https://httpbin.org/post\",\n          entity = entity\n        ))\n        responseF.onComplete {\n          case Success(res) => context.log.info(s\"Response status: ${res.status}\")\n          case Failure(ex) => context.log.error(s\"Failed: ${ex.getMessage}\")\n        }\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedHttpPostActorApp extends App {\n  val system = ActorSystem(HttpPostActor(), \"HttpPostSystem\")\n  system ! HttpPostActor.SendPost\n\n  Thread.sleep(3000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Build a typed Streams example that merges multiple sources, then filters out even numbers, and prints the rest."
      },
      {
        "from": "assistant",
        "value": "// MergeFilterStreamTyped.scala\n\nimport akka.actor.ActorSystem\nimport akka.stream.ActorMaterializer\nimport akka.stream.scaladsl.{Merge, Sink, Source}\nimport scala.concurrent.ExecutionContextExecutor\n\nobject MergeFilterStreamTyped extends App {\n  implicit val system: ActorSystem = ActorSystem(\"MergeFilterSystem\")\n  implicit val ec: ExecutionContextExecutor = system.dispatcher\n  implicit val mat: ActorMaterializer = ActorMaterializer()(system)\n\n  val source1 = Source(1 to 3)\n  val source2 = Source(4 to 6)\n\n  val merged = Source.combine(source1, source2)(Merge(_))\n  val filtered = merged.filter(_ % 2 != 0)\n\n  val sink = Sink.foreach[Int](n => println(s\"Odd number: $n\"))\n\n  filtered.runWith(sink)\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Show a typed streams example with a custom Graph stage that doubles incoming integers."
      },
      {
        "from": "assistant",
        "value": "// DoubleFlowGraphStageExample.scala\n\nimport akka.actor.ActorSystem\nimport akka.stream.{ActorMaterializer, Attributes, FlowShape, Inlet, Outlet}\nimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}\nimport akka.stream.scaladsl.{Keep, RunnableGraph, Sink, Source}\nimport scala.concurrent.ExecutionContextExecutor\n\nclass DoublingStage extends GraphStage[FlowShape[Int, Int]] {\n  val in: Inlet[Int] = Inlet(\"DoublingStage.in\")\n  val out: Outlet[Int] = Outlet(\"DoublingStage.out\")\n\n  override val shape: FlowShape[Int, Int] = FlowShape(in, out)\n\n  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic = new GraphStageLogic(shape) {\n    setHandler(in, new InHandler {\n      override def onPush(): Unit = {\n        val elem = grab(in)\n        push(out, elem * 2)\n      }\n    })\n\n    setHandler(out, new OutHandler {\n      override def onPull(): Unit = pull(in)\n    })\n  }\n}\n\nobject DoubleFlowGraphStageExample extends App {\n  implicit val system: ActorSystem = ActorSystem(\"DoubleGraphStageSystem\")\n  implicit val ec: ExecutionContextExecutor = system.dispatcher\n  implicit val mat: ActorMaterializer = ActorMaterializer()(system)\n\n  val source = Source(1 to 5)\n  val doublingFlow = new DoublingStage\n  val sink = Sink.foreach[Int](x => println(s\"Doubled: $x\"))\n\n  val runnable = source.via(doublingFlow).toMat(sink)(Keep.right)\n  runnable.run()\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Make a typed cluster Singleton that manages a GCounter via distributed data, demonstrating a single node responsible for updates."
      },
      {
        "from": "assistant",
        "value": "// TypedClusterSingletonGCounter.scala\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorRef, ActorSystem, Behavior}\nimport akka.cluster.typed.{ClusterSingleton, SingletonActor}\nimport akka.cluster.ddata.GCounter\nimport akka.cluster.ddata.typed.scaladsl.{DistributedData, Replicator}\nimport akka.cluster.ddata.{GCounterKey}\nimport akka.actor.typed.scaladsl.adapter._\n\nobject GCounterSingleton {\n  sealed trait Command\n  case object Increment extends Command\n  private case class InternalUpdate(rsp: Replicator.UpdateResponse[GCounter]) extends Command\n\n  private val Key = GCounterKey(\"singletonGCounter\")\n\n  def apply(): Behavior[Command] = Behaviors.setup { ctx =>\n    val replicator = DistributedData(ctx.system).replicator\n    implicit val node = DistributedData(ctx.system).selfUniqueAddress\n\n    Behaviors.receiveMessage {\n      case Increment =>\n        replicator ! Replicator.Update(Key, GCounter.empty, Replicator.WriteLocal, ctx.messageAdapter(InternalUpdate)) {\n          _.increment(node, 1)\n        }\n        Behaviors.same\n      case InternalUpdate(rsp) =>\n        ctx.log.info(s\"Update response: $rsp\")\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedClusterSingletonGCounterApp extends App {\n  val system = ActorSystem(Behaviors.empty, \"SingletonGCounterCluster\")\n\n  val singletonManager = ClusterSingleton(system)\n  val singletonRef = singletonManager.init(\n    SingletonActor(\n      GCounterSingleton(),\n      \"GCounterSingleton\"\n    )\n  )\n\n  // Send increments to the singleton\n  singletonRef ! GCounterSingleton.Increment\n  singletonRef ! GCounterSingleton.Increment\n\n  Thread.sleep(3000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Provide an example of a typed actor that uses a stash for typed messages, stashing until a 'ready' command is received."
      },
      {
        "from": "assistant",
        "value": "// TypedStashExample.scala\n\nimport akka.actor.typed.scaladsl.{Behaviors, StashBuffer}\nimport akka.actor.typed.{ActorSystem, Behavior}\n\nobject StashActor {\n  sealed trait Command\n  case object Ready extends Command\n  case class Payload(msg: String) extends Command\n\n  def apply(): Behavior[Command] = Behaviors.withStash(10) { buffer =>\n    Behaviors.setup { context =>\n\n      def unstashedBehavior: Behavior[Command] = Behaviors.receiveMessage {\n        case Payload(m) =>\n          context.log.info(s\"Processing payload: $m\")\n          Behaviors.same\n        case Ready =>\n          context.log.info(\"Already in ready state.\")\n          Behaviors.same\n      }\n\n      // Initially not ready\n      val initial: Behavior[Command] = Behaviors.receiveMessage {\n        case Ready =>\n          context.log.info(\"Becoming ready, unstashing messages.\")\n          buffer.unstashAll(unstashedBehavior)\n        case other =>\n          context.log.info(\"Stashing message until we get Ready.\")\n          buffer.stash(other)\n          Behaviors.same\n      }\n\n      initial\n    }\n  }\n}\n\nobject TypedStashExampleApp extends App {\n  val system = ActorSystem(StashActor(), \"StashSystem\")\n\n  system ! StashActor.Payload(\"msg1\")\n  system ! StashActor.Payload(\"msg2\")\n  system ! StashActor.Ready\n  system ! StashActor.Payload(\"msg3\")\n\n  Thread.sleep(500)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an example of using Distributed Data with the GCounter CRDT in Akka, incrementing a global counter."
      },
      {
        "from": "assistant",
        "value": "// Fixed example of Distributed Data GCounter in Akka.\n// Ensure you have \"akka-cluster\" and \"akka-cluster-tools\" (or \"akka-cluster-typed\" + \"akka-distributed-data\") in dependencies.\n// This example uses classic APIs for GCounter, but can be adapted to typed.\n\nimport akka.actor.{ActorSystem, Props, Actor}\nimport akka.cluster.ddata.{DistributedData, GCounter, GCounterKey, SelfUniqueAddress}\nimport akka.cluster.ddata.Replicator._\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass GCounterObserver extends Actor {\n  def receive: Receive = {\n    case g @ GetSuccess(GCounterKey(\"globalCounter\"), _) =>\n      val counter = g.get(GCounterKey(\"globalCounter\")).value\n      println(s\"GCounterObserver: Current globalCounter = $counter\")\n    case NotFound(_, _) =>\n      println(\"GCounterObserver: Counter not found.\")\n    case UpdateSuccess(GCounterKey(\"globalCounter\"), _) =>\n      println(\"GCounterObserver: Successfully updated the counter.\")\n    case ModifyFailure(GCounterKey(\"globalCounter\"), error, cause, _) =>\n      println(s\"GCounterObserver: Failed to update: $error\")\n    case other =>\n      println(s\"GCounterObserver: Unknown response -> $other\")\n  }\n}\n\nobject DistributedDataGCounterExample extends App {\n  val system = ActorSystem(\"DDSystem\")\n  val replicator = DistributedData(system).replicator\n  implicit val node: SelfUniqueAddress = DistributedData(system).selfUniqueAddress\n\n  // Create an actor to observe changes\n  val observer = system.actorOf(Props[GCounterObserver](), \"gCounterObserver\")\n\n  val key = GCounterKey(\"globalCounter\")\n\n  // Send an Update to increment the counter by 3\n  replicator ! Update(key, GCounter.empty, WriteLocal, request = None) { counter =>\n    counter.increment(node, 3)\n  }\n\n  // After a delay, do a Get to read the value\n  system.scheduler.scheduleOnce(1.second) {\n    replicator ! Get(key, ReadLocal, request = None)\n  }\n\n  // Terminate later\n  system.scheduler.scheduleOnce(3.seconds) {\n    system.terminate()\n  }\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Show how to implement a typed actor that, upon receiving a 'CompleteStream' command, runs a stream that prints messages. Fix the Materializer error."
      },
      {
        "from": "assistant",
        "value": "// Fixed example of a typed actor that runs a stream upon receiving a command.\n// We'll use the typed SystemMaterializer for the run.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.stream.scaladsl.{Sink, Source}\nimport akka.stream.SystemMaterializer\nimport akka.{Done, NotUsed}\nimport scala.concurrent.Future\nimport scala.concurrent.duration._\nimport scala.util.{Success, Failure}\n\nobject OnDemandStreamActor {\n  sealed trait Command\n  case object CompleteStream extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { context =>\n    // Provide typed-materializer\n    implicit val mat = SystemMaterializer(context.system).materializer\n    implicit val ec = context.executionContext\n\n    Behaviors.receiveMessage {\n      case CompleteStream =>\n        context.log.info(\"Starting on-demand stream...\")\n        val source: Source[Int, NotUsed] = Source(1 to 3)\n        val done: Future[Done] = source.runForeach(n => context.log.info(s\"Stream element: $n\"))\n\n        done.onComplete {\n          case Success(_) => context.log.info(\"Stream completed successfully.\")\n          case Failure(ex) => context.log.error(s\"Stream failed with: ${ex.getMessage}\")\n        }\n        Behaviors.same\n    }\n  }\n}\n\nobject TypedActorStreamOnDemandApp extends App {\n  val system = ActorSystem(OnDemandStreamActor(), \"OnDemandStreamSystem\")\n\n  system ! OnDemandStreamActor.CompleteStream\n\n  Thread.sleep(2000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Write a typed Streams example reading lines from stdin with StreamConverters, fix usage of ByteString for the delimiter."
      },
      {
        "from": "assistant",
        "value": "// Fixed typed Streams example reading lines from stdin.\n// The main fix is using ByteString for the delimiter instead of ByteBuffer.\n// Also note we can use SystemMaterializer for typed systems.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.stream.scaladsl.{Framing, Sink, StreamConverters}\nimport akka.util.ByteString\nimport akka.stream.SystemMaterializer\nimport scala.concurrent.ExecutionContext\nimport akka.{Done, NotUsed}\nimport scala.concurrent.Future\n\nobject StdinStreamApp extends App {\n  val root: Behavior[Nothing] = Behaviors.setup[Nothing] { context =>\n    implicit val mat = SystemMaterializer(context.system).materializer\n    implicit val ec: ExecutionContext = context.executionContext\n\n    // Create a source from System.in\n    val source = StreamConverters.fromInputStream(() => System.in)\n      .via(\n        Framing.delimiter(\n          ByteString(\"\\n\"),      // Use ByteString for the delimiter\n          maximumFrameLength = 256,\n          allowTruncation = true\n        )\n      )\n      .map(_.utf8String)           // Convert each frame to string\n\n    // Print each line\n    val sink = Sink.foreach[String](line => println(s\"You typed: $line\"))\n\n    // Run the stream\n    val done: Future[Done] = source.runWith(sink)\n\n    // Terminate the system after EOF or error\n    done.onComplete { _ =>\n      context.system.terminate()\n    }\n\n    Behaviors.empty\n  }\n\n  val system = ActorSystem(root, \"StdinStreamSystem\")\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Typed Persistence Example: Create a typed persistence actor that stores and retrieves a counter state."
      },
      {
        "from": "assistant",
        "value": "// TypedPersistenceExample.scala\n// This example uses Akka Persistence Typed to implement a simple counter actor\n\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.persistence.typed.PersistenceId\nimport akka.persistence.typed.scaladsl.{EventSourcedBehavior, Effect, RetentionCriteria}\n\nobject TypedPersistenceExample {\n  // Define commands\n  sealed trait Command\n  case object Increment extends Command\n  case object Decrement extends Command\n  case object PrintState extends Command\n\n  // Define events\n  sealed trait Event\n  case object Incremented extends Event\n  case object Decremented extends Event\n\n  // Define the state\n  final case class CounterState(value: Int)\n\n  // Create the behavior using EventSourcedBehavior\n  def apply(entityId: String): Behavior[Command] = EventSourcedBehavior[\n    Command,\n    Event,\n    CounterState\n  ](\n    persistenceId = PersistenceId.ofUniqueId(entityId),\n    emptyState = CounterState(0),\n    commandHandler = (state, command) => command match {\n      case Increment => Effect.persist(Incremented)\n      case Decrement => Effect.persist(Decremented)\n      case PrintState =>\n        println(s\"Current state: ${state.value}\")\n        Effect.none\n    },\n    eventHandler = (state, event) => event match {\n      case Incremented => state.copy(value = state.value + 1)\n      case Decremented => state.copy(value = state.value - 1)\n    }\n  ).withRetention(\n    RetentionCriteria.snapshotEvery(numberOfEvents = 10, keepNSnapshots = 2)\n  )\n}\n\nobject TypedPersistenceExampleApp extends App {\n  import TypedPersistenceExample._\n  // Start the actor system with our persistent counter\n  val system: ActorSystem[Command] = ActorSystem(TypedPersistenceExample(\"CounterEntity\"), \"TypedPersistenceSystem\")\n  system ! Increment\n  system ! Increment\n  system ! Decrement\n  system ! PrintState\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Typed Actor with Stream: Build a typed actor that, upon receiving a 'StartStream' command, runs a stream that sums numbers and logs the result."
      },
      {
        "from": "assistant",
        "value": "// SumStreamTyped.scala\n// This example demonstrates a typed actor that starts an on-demand stream to sum numbers.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.stream.scaladsl.{Sink, Source}\nimport akka.stream.SystemMaterializer\nimport akka.{Done, NotUsed}\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration._\nimport scala.util.{Success, Failure}\n\nobject OnDemandStreamActor {\n  sealed trait Command\n  case object StartStream extends Command\n\n  def apply(): Behavior[Command] = Behaviors.setup { context =>\n    // Obtain a Materializer from the typed system\n    implicit val mat = SystemMaterializer(context.system).materializer\n    Behaviors.receiveMessage {\n      case StartStream =>\n        context.log.info(\"Starting summation stream.\")\n        // Create a source of integers\n        val source: Source[Int, NotUsed] = Source(1 to 5)\n        // Create a sink that reduces (sums) the numbers\n        val sink: Sink[Int, Future[Int]] = Sink.reduce[Int](_ + _)\n        // Run the stream and obtain a Future with the result\n        val sumFuture: Future[Int] = source.runWith(sink)\n        sumFuture.onComplete {\n          case Success(sum) => context.log.info(s\"Summation result: $sum\")\n          case Failure(ex) => context.log.error(s\"Stream failed with: ${ex.getMessage}\")\n        }\n        Behaviors.same\n    }\n  }\n}\n\nobject SumStreamTypedApp extends App {\n  val system = ActorSystem(OnDemandStreamActor(), \"SumStreamSystem\")\n  system ! OnDemandStreamActor.StartStream\n  Thread.sleep(2000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Tagged Persistent Actor: Create a typed persistence actor that uses tagging for events."
      },
      {
        "from": "assistant",
        "value": "// TaggedPersistentActor.scala\n// This example shows a persistent actor that tags events so they can be filtered by projections.\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorSystem, Behavior}\nimport akka.persistence.typed.PersistenceId\nimport akka.persistence.typed.scaladsl.{EventSourcedBehavior, Effect, RetentionCriteria}\n\nobject TaggedPersistentActor {\n  // Commands\n  sealed trait Command\n  case object Increment extends Command\n  case object PrintState extends Command\n\n  // Events\n  sealed trait Event\n  case object Incremented extends Event\n\n  // State\n  final case class State(count: Int)\n\n  // Define a tag set for this entity\n  val MyTag = Set(\"counter-tag\")\n\n  def apply(entityId: String): Behavior[Command] = EventSourcedBehavior[\n    Command,\n    Event,\n    State\n  ](\n    persistenceId = PersistenceId.ofUniqueId(entityId),\n    emptyState = State(0),\n    commandHandler = (state, cmd) => cmd match {\n      case Increment => Effect.persist(Incremented)\n      case PrintState =>\n        println(s\"TaggedPersistentActor state = ${state.count}\")\n        Effect.none\n    },\n    eventHandler = (state, evt) => evt match {\n      case Incremented => state.copy(count = state.count + 1)\n    }\n  ).withTagger { event =>\n    event match {\n      case Incremented => MyTag\n    }\n  }\n}\n\nobject TaggedPersistentActorApp extends App {\n  val system = ActorSystem(TaggedPersistentActor(\"tag-entity\"), \"TaggedPersistenceSystem\")\n  system ! TaggedPersistentActor.Increment\n  system ! TaggedPersistentActor.Increment\n  system ! TaggedPersistentActor.PrintState\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: GroupBy Streams Example: Demonstrate an Akka Streams GraphDSL that groups elements in groups of 2 and prints them."
      },
      {
        "from": "assistant",
        "value": "// GroupByStreamExample.scala\n// This example groups a stream of key-value pairs by the key and then merges the substreams to print all elements.\n\nimport akka.actor.ActorSystem\nimport akka.stream.ActorMaterializer\nimport akka.stream.scaladsl.{Sink, Source}\nimport scala.concurrent.ExecutionContextExecutor\n\nobject GroupByStreamExample extends App {\n  implicit val system: ActorSystem = ActorSystem(\"GroupBySystem\")\n  implicit val ec: ExecutionContextExecutor = system.dispatcher\n  implicit val mat: ActorMaterializer = ActorMaterializer()(system)\n\n  // Define a source of tuples\n  val source = Source(List((1, \"apple\"), (2, \"banana\"), (1, \"cherry\"), (2, \"date\")))\n\n  // Group the source by key, then merge substreams and print each element\n  val done = source.groupBy(2, _._1)\n    .mergeSubstreams\n    .runForeach { case (key, value) =>\n      println(s\"Group #$key => $value\")\n    }\n\n  done.onComplete(_ => system.terminate())\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a simple EchoActor that replies with the same message it receives."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Simple actor that echoes back any message it receives.\nclass EchoActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"EchoActor received: $msg\")\n      sender() ! msg // Reply with the same message\n  }\n}\n\nobject EchoActorApp extends App {\n  val system = ActorSystem(\"EchoSystem\")\n  val echoActor = system.actorOf(Props[EchoActor](), \"echo\")\n\n  echoActor ! \"Hello, Akka!\"\n  echoActor ! 123\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CounterActor that increments a counter for each message received."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message to increment the counter\ncase object Increment\n// Message to retrieve the current count\ncase object GetCount\n\n// Actor that maintains and increments a counter\nclass CounterActor extends Actor {\n  private var count = 0\n\n  def receive: Receive = {\n    case Increment =>\n      count += 1\n      println(s\"CounterActor: Incremented count to $count\")\n    case GetCount =>\n      println(s\"CounterActor: Sending count $count\")\n      sender() ! count\n    case _ =>\n      println(\"CounterActor: Unknown message.\")\n  }\n}\n\nobject CounterApp extends App {\n  val system = ActorSystem(\"CounterSystem\")\n  val counter = system.actorOf(Props[CounterActor](), \"counter\")\n\n  counter ! Increment\n  counter ! Increment\n  counter ! GetCount\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RouterActor using a RoundRobinPool to distribute messages to child actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\n// Message to be processed by workers\ncase class Work(data: String)\n\n// Worker actor that simply prints the received message\nclass Worker extends Actor {\n  def receive: Receive = {\n    case Work(data) =>\n      println(s\"Worker [${self.path.name}] processed: $data\")\n  }\n}\n\nobject RouterApp extends App {\n  val system = ActorSystem(\"RouterSystem\")\n\n  // Create a router with 5 instances of Worker actor\n  val router = system.actorOf(\n    RoundRobinPool(5).props(Props[Worker]()), \"workerRouter\"\n  )\n\n  // Send work messages to the router\n  for (i <- 1 to 10) {\n    router ! Work(s\"Task $i\")\n  }\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Implement request-response with ask pattern and future."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Success, Failure}\n\n// Simple request and response messages.\ncase class Request(msg: String)\ncase class Response(msg: String)\n\n// Actor that responds to a Request with a Response.\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Request(msg) =>\n      println(s\"ResponderActor received request: $msg\")\n      sender() ! Response(s\"Reply to $msg\")\n  }\n}\n\nobject AskPatternApp extends App {\n  val system = ActorSystem(\"AskPatternSystem\")\n  val responder = system.actorOf(Props[ResponderActor](), \"responder\")\n\n  implicit val timeout: Timeout = Timeout(5.seconds)\n  // Use the ask pattern to send a request and get a future response\n  val futureResponse = responder ? Request(\"Hello\")\n\n  futureResponse.onComplete {\n    case Success(Response(msg)) =>\n      println(s\"Main: Received response: $msg\")\n    case Failure(ex) =>\n      println(s\"Main: Error: ${ex.getMessage}\")\n    case Success(other) => // For unexpected message types. Added to show a more exhaustive match. \n            println(s\"Received unexpected message type: ${other}\")\n\n  }\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ParentActor that creates and watches a ChildActor, handling termination."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, Terminated}\n\n// Child actor that stops itself after receiving a specific message.\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case \"stop\" =>\n      println(s\"ChildActor [${self.path.name}]: Stopping.\")\n      context.stop(self)\n    case msg =>\n      println(s\"ChildActor [${self.path.name}] received: $msg\")\n  }\n}\n\n// Parent actor that creates, watches, and reacts to child termination.\nclass ParentActor extends Actor {\n  // Create and watch the child actor\n  val child: ActorRef = context.actorOf(Props[ChildActor](), \"myChild\")\n  context.watch(child)\n\n  def receive: Receive = {\n    case Terminated(actorRef) =>\n      if (actorRef == child) {\n        println(s\"ParentActor: Child actor terminated.\")\n        //Optionally, stop self or create a new child here\n        context.stop(self)\n      }\n    case msg =>\n      // Forward messages to the child\n      child forward msg\n  }\n\n    override def postStop(): Unit = {\n        println(s\"ParentActor stopped\")\n    }\n}\n\nobject ParentChildApp extends App {\n  val system = ActorSystem(\"ParentChildSystem\")\n  val parent = system.actorOf(Props[ParentActor](), \"parent\")\n\n  parent ! \"Hello, Child!\"\n  parent ! \"stop\" // This will stop the child\n  parent ! \"This won't be received\" // The child has now been stopped\n\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an actor that uses scheduler to send a message to itself."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Message to be sent periodically to self\ncase object Tick\n\nclass SchedulerActor extends Actor {\n  // Schedule a Tick message to be sent to self every second\n  val tickScheduler: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    0.seconds, // Initial delay\n    1.second,  // Interval\n    self,      // Recipient\n    Tick       // Message\n  )\n\n  def receive: Receive = {\n    case Tick =>\n      println(\"SchedulerActor: Tick received.\")\n  }\n\n  // Cancel the scheduled task when the actor stops\n  override def postStop(): Unit = {\n    tickScheduler.cancel()\n    println(\"Scheduler stopped\")\n    super.postStop()\n  }\n}\n\nobject SchedulerApp extends App {\n    val system = ActorSystem(\"SchedulerSystem\")\n    val schedulerActor = system.actorOf(Props[SchedulerActor](),\"scheduler\")\n\n    Thread.sleep(5000) // Let it run for 5 seconds\n    system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an actor that uses context.become to change its behavior."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message to switch behavior\ncase object Switch\n\nclass BecomeActor extends Actor {\n  // Define the first behavior\n  def firstBehavior: Receive = {\n    case Switch =>\n      println(\"BecomeActor: Switching to second behavior.\")\n      context.become(secondBehavior)\n    case msg =>\n      println(s\"BecomeActor (first behavior) received: $msg\")\n  }\n\n  // Define the second behavior\n  def secondBehavior: Receive = {\n    case Switch =>\n      println(\"BecomeActor: Switching back to first behavior.\")\n      context.become(firstBehavior)\n    case msg =>\n      println(s\"BecomeActor (second behavior) received: $msg\")\n  }\n\n  // Start with the first behavior\n  def receive: Receive = firstBehavior\n}\n\nobject BecomeApp extends App {\n  val system = ActorSystem(\"BecomeSystem\")\n  val becomeActor = system.actorOf(Props[BecomeActor](), \"becomeActor\")\n\n  becomeActor ! \"Message 1\"\n  becomeActor ! Switch\n  becomeActor ! \"Message 2\"\n  becomeActor ! Switch\n  becomeActor ! \"Message 3\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an actor that handles different message types with pattern matching."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define several different message types\ncase class StringMessage(s: String)\ncase class IntMessage(i: Int)\ncase class DoubleMessage(d: Double)\n\nclass MultiTypeActor extends Actor {\n  def receive: Receive = {\n    case StringMessage(s) =>\n      println(s\"MultiTypeActor received string: $s\")\n    case IntMessage(i) =>\n      println(s\"MultiTypeActor received integer: $i\")\n    case DoubleMessage(d) =>\n      println(s\"MultiTypeActor received double: $d\")\n    case _ =>\n      println(\"MultiTypeActor received unknown message type.\")\n  }\n}\n\nobject MultiTypeApp extends App {\n  val system = ActorSystem(\"MultiTypeSystem\")\n  val multiTypeActor = system.actorOf(Props[MultiTypeActor](), \"multiTypeActor\")\n\n  multiTypeActor ! StringMessage(\"Hello\")\n  multiTypeActor ! IntMessage(42)\n  multiTypeActor ! DoubleMessage(3.14)\n  multiTypeActor ! List(1, 2, 3) // Unknown message type\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Show how to use a custom dispatcher for an actor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport com.typesafe.config.ConfigFactory\n\n// Define a custom dispatcher in application.conf (or as a string config)\n/*\nmy-custom-dispatcher {\n  type = Dispatcher\n  executor = \"fork-join-executor\"\n  fork-join-executor {\n    parallelism-min = 2\n    parallelism-factor = 2.0\n    parallelism-max = 8\n  }\n  throughput = 10\n}\n*/\n\nval customConf = ConfigFactory.parseString(\"\"\"\nmy-custom-dispatcher {\n  type = Dispatcher\n  executor = \"fork-join-executor\"\n  fork-join-executor {\n    parallelism-min = 2\n    parallelism-factor = 2.0\n    parallelism-max = 8\n  }\n  throughput = 10\n}\n\"\"\")\n\n\n// Actor that logs which dispatcher it's using\nclass CustomDispatcherActor extends Actor {\n    def receive: Receive = {\n        case msg =>\n            println(s\"CustomDispatcherActor received '$msg' on dispatcher: ${context.dispatcher}\")\n    }\n}\n\nobject CustomDispatcherApp extends App {\n    val system = ActorSystem(\"CustomDispatcherSystem\", customConf)\n\n    // Create the actor with the custom dispatcher\n    val customDispatcherActor = system.actorOf(\n        Props[CustomDispatcherActor]().withDispatcher(\"my-custom-dispatcher\"),\n        \"customDispatcherActor\"\n    )\n\n    customDispatcherActor ! \"Testing custom dispatcher\"\n    customDispatcherActor ! \"Another Test\"\n\n    Thread.sleep(1000)\n    system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Demonstrate how to stop an actor using context.stop."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Stop\n\n// Actor which stops itself on receiving 'Stop' message\nclass StoppableActor extends Actor {\n    def receive: Receive = {\n        case Stop =>\n            println(s\"StoppableActor [${self.path.name}]: Stopping.\")\n            context.stop(self)\n        case msg => \n            println(s\"StoppableActor [${self.path.name}] received: $msg\")\n    }\n\n    override def postStop(): Unit = {\n        println(s\"StoppableActor stopped\")\n    }\n}\n\nobject ContextStopApp extends App {\n    val system = ActorSystem(\"ContextStopSystem\")\n    val stoppable = system.actorOf(Props[StoppableActor](), \"stoppableActor\")\n\n    stoppable ! \"Some Message\"\n    stoppable ! Stop\n    stoppable ! \"This message won't arrive\" // The actor is stopped now.\n\n    Thread.sleep(1000)\n    system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Show how to use preStart and postStop lifecycle hooks."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\nclass LifecycleActor extends Actor {\n  // Called before the actor starts processing messages\n  override def preStart(): Unit = {\n    println(s\"LifecycleActor [${self.path.name}]: preStart called.\")\n  }\n\n  // Called after the actor has stopped\n  override def postStop(): Unit = {\n    println(s\"LifecycleActor [${self.path.name}]: postStop called.\")\n  }\n\n  def receive: Receive = {\n    case msg =>\n      println(s\"LifecycleActor [${self.path.name}]: Received -> $msg\")\n  }\n}\n\nobject LifecycleHooksApp extends App {\n  val system = ActorSystem(\"LifecycleSystem\")\n  val lifecycleActor = system.actorOf(Props[LifecycleActor](), \"lifecycleActor\")\n\n  lifecycleActor ! \"Hello\"\n\n  system.stop(lifecycleActor) // Stop the actor\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Implement an actor that forwards messages to another actor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Actor that receives messages\nclass ReceiverActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ReceiverActor received: $msg\")\n  }\n}\n\n// Actor that forwards messages to another actor\nclass ForwardingActor(receiver: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ForwardingActor forwarding: $msg\")\n      receiver forward msg // Forward the message\n  }\n}\n\nobject ForwardingApp extends App {\n  val system = ActorSystem(\"ForwardingSystem\")\n  val receiver = system.actorOf(Props[ReceiverActor](), \"receiver\")\n  val forwarder = system.actorOf(Props(new ForwardingActor(receiver)), \"forwarder\")\n\n  forwarder ! \"Hello, Forwarding!\"\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an actor that replies to the sender using sender()."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message to request a reply.\ncase object RequestReply\n\nclass ReplyActor extends Actor {\n  def receive: Receive = {\n    case RequestReply =>\n      println(\"ReplyActor: Received RequestReply, sending reply.\")\n      sender() ! \"This is a reply\"\n  }\n}\n\nobject ReplyApp extends App {\n  val system = ActorSystem(\"ReplySystem\")\n  val replyActor = system.actorOf(Props[ReplyActor](), \"replyActor\")\n\n  // Send the RequestReply message.  In a real application, you would\n  // likely use the ask pattern to deal with the response.\n  replyActor ! RequestReply\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Demonstrate ActorSelection usage to send a message to an actor by path."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Target actor for ActorSelection\nclass TargetActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"TargetActor [${self.path.name}] received: $msg\")\n  }\n}\n\nobject ActorSelectionApp extends App {\n  val system = ActorSystem(\"SelectionSystem\")\n  //Create target actor\n  val target = system.actorOf(Props[TargetActor](), \"targetActor\")\n\n  // Get an ActorSelection by path\n  val selection = system.actorSelection(\"/user/targetActor\")\n\n  // Send messages using the ActorSelection\n  selection ! \"Hello via selection\"\n  selection ! \"Another message\"\n  //Send message to not existing actor\n  val selectionWrong = system.actorSelection(\"/user/NonExistingActor\")\n  selectionWrong ! \"Hello, this will go to dead letters\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  }
]