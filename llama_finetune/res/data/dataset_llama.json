[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that can handle different types of messages, such as strings, integers, and custom case classes, performing different actions based on the message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define custom messages\ncase class Greet(name: String)\ncase class Calculate(a: Int, b: Int)\n\n// Define the MultiMessageActor\nclass MultiMessageActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"Received string message: $msg\")\n    case Greet(name) =>\n      println(s\"Hello, $name!\")\n    case Calculate(a, b) =>\n      println(s\"The sum of $a and $b is ${a + b}\")\n    case _ =>\n      println(\"Unknown message received.\")\n  }\n}\n\n// Usage Example\nobject MultiMessageApp extends App {\n  val system = ActorSystem(\"MultiMessageSystem\")\n  val multiActor = system.actorOf(Props[MultiMessageActor](), \"multiActor\")\n\n  multiActor ! \"A simple string\"\n  multiActor ! Greet(\"Alice\")\n  multiActor ! Calculate(5, 7)\n  multiActor ! 42 // This will trigger the unknown message case\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that maintains a counter. It should handle two messages: one to increment the counter and another to retrieve its current value."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Messages\ncase object Increment\ncase object GetCount\n\n// Define the CounterActor\nclass CounterActor extends Actor {\n  var count = 0\n\n  def receive: Receive = {\n    case Increment =>\n      count += 1\n    case GetCount =>\n      sender() ! count\n  }\n}\n\n// Usage Example\nobject CounterApp extends App {\n  val system = ActorSystem(\"CounterSystem\")\n  val counter = system.actorOf(Props[CounterActor](), \"counter\")\n\n  counter ! Increment\n  counter ! Increment\n  counter ! GetCount\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Supervisor Actor in Scala that supervises a child actor. The supervisor should restart the child in case of any failure"
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy, Terminated}\nimport akka.actor.SupervisorStrategy._\n\nimport scala.concurrent.duration._\n\n// Define the ChildActor\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case \"fail\" => throw new Exception(\"Child failed!\")\n    case msg    => println(s\"Child received: $msg\")\n  }\n}\n\n// Define the SupervisorActor\nclass SupervisorActor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(\n    maxNrOfRetries = 3,\n    withinTimeRange = 1.minute\n  ) {\n    case _: Exception => Restart\n  }\n\n  val child: ActorRef = context.actorOf(Props[ChildActor](), \"childActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example\nobject SupervisorApp extends App {\n  val system = ActorSystem(\"SupervisorSystem\")\n  val supervisor = system.actorOf(Props[SupervisorActor](), \"supervisor\")\n\n  supervisor ! \"Hello\"\n  supervisor ! \"fail\"\n  supervisor ! \"Are you there?\"\n}"
      }
    ]
  },  git pull
  {
    "conversations": [
      {
        "from": "human",
        "value": "Develop an Akka Router Actor in Scala that distributes incoming messages to a pool of worker actors using a round-robin strategy."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\n// Define the WorkerActor\nclass WorkerActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"${self.path.name} processed message: $msg\")\n  }\n}\n\n// Usage Example\nobject RouterApp extends App {\n  val system = ActorSystem(\"RouterSystem\")\n  \n  // Create a router with 5 worker actors\n  val router: ActorRef = system.actorOf(\n    RoundRobinPool(5).props(Props[WorkerActor]()),\n    \"workerRouter\"\n  )\n\n  // Send messages to the router\n  for (i <- 1 to 10) {\n    router ! s\"Message $i\"\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that communicates with multiple other actors, sending messages and aggregating responses."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define worker actors\nclass Worker(id: Int) extends Actor {\n  def receive: Receive = {\n    case \"work\" =>\n      sender() ! s\"Worker $id completed work.\"\n  }\n}\n\n// Define the ManagerActor\nclass Manager(numWorkers: Int) extends Actor {\n  // Create worker actors\n  val workers: IndexedSeq[ActorRef] = for (i <- 1 to numWorkers) yield {\n    context.actorOf(Props(new Worker(i)), s\"worker$i\")\n  }\n\n  def receive: Receive = {\n    case \"start\" =>\n      workers.foreach(_ ! \"work\")\n    case msg =>\n      println(s\"Manager received: $msg\")\n  }\n}\n\n// Usage Example\nobject ManagerApp extends App {\n  val system = ActorSystem(\"ManagerSystem\")\n  val manager = system.actorOf(Props(new Manager(3)), \"manager\")\n\n  manager ! \"start\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that changes its behavior based on the messages it receives using context.become"
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the ToggleActor\nclass ToggleActor extends Actor {\n  def active: Receive = {\n    case \"toggle\" =>\n      println(\"Switching to inactive state.\")\n      context.become(inactive)\n    case msg =>\n      println(s\"Active state received: $msg\")\n  }\n\n  def inactive: Receive = {\n    case \"toggle\" =>\n      println(\"Switching to active state.\")\n      context.become(active)\n    case msg =>\n      println(s\"Inactive state received: $msg\")\n  }\n\n  def receive: Receive = active\n}\n\n// Usage Example\nobject ToggleApp extends App {\n  val system = ActorSystem(\"ToggleSystem\")\n  val toggleActor = system.actorOf(Props[ToggleActor](), \"toggleActor\")\n\n  toggleActor ! \"Hello\"\n  toggleActor ! \"toggle\"\n  toggleActor ! \"World\"\n  toggleActor ! \"toggle\"\n  toggleActor ! \"Back to active\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that uses the ask pattern to send a message and wait for a response asynchronously."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\n\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      sender() ! s\"Received your message: $msg\"\n  }\n}\n\n// Usage Example\nobject AskPatternApp extends App {\n  val system = ActorSystem(\"AskPatternSystem\")\n  val responder = system.actorOf(Props[ResponderActor](), \"responder\")\n\n  implicit val timeout: Timeout = Timeout(5.seconds)\n  val future = responder ? \"Hello via ask pattern\"\n\n  val result = Await.result(future, timeout.duration).asInstanceOf[String]\n  println(result)\n\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named DynamicParentActor that can dynamically create child actors upon receiving a CreateChild(name: String) message. Each child actor should be named according to the provided name and simply print any message it receives. Demonstrate creating multiple children and sending messages to them through the parent."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class CreateChild(name: String)\ncase class SendMessageToChild(childName: String, message: String)\n\n// Define the ChildActor\nclass ChildActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ChildActor [$name] received message: $msg\")\n  }\n}\n\n// Define the DynamicParentActor\nclass DynamicParentActor extends Actor {\n  var children: Map[String, ActorRef] = Map.empty\n\n  def receive: Receive = {\n    case CreateChild(name) =>\n      if (!children.contains(name)) {\n        val child = context.actorOf(Props(new ChildActor(name)), name)\n        children += (name -> child)\n        println(s\"ParentActor created child actor with name: $name\")\n      } else {\n        println(s\"Child actor with name '$name' already exists.\")\n      }\n\n    case SendMessageToChild(childName, message) =>\n      children.get(childName) match {\n        case Some(child) =>\n          child ! message\n        case None =>\n          println(s\"No child actor found with name: $childName\")\n      }\n\n    case msg =>\n      println(s\"ParentActor received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DynamicParentApp extends App {\n  val system = ActorSystem(\"DynamicParentSystem\")\n  val parent = system.actorOf(Props[DynamicParentActor](), \"parentActor\")\n\n  // Create child actors\n  parent ! CreateChild(\"child1\")\n  parent ! CreateChild(\"child2\")\n  parent ! CreateChild(\"child1\") // Attempt to create an existing child\n\n  // Send messages to child actors\n  parent ! SendMessageToChild(\"child1\", \"Hello Child 1!\")\n  parent ! SendMessageToChild(\"child2\", \"Hello Child 2!\")\n  parent ! SendMessageToChild(\"child3\", \"Hello Child 3!\") // Non-existent child\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named BufferedActor that buffers incoming messages and processes them at a controlled rate of one message every 500 milliseconds. Implement buffering such that incoming messages are stored in a queue if the actor is busy processing. Demonstrate sending multiple messages rapidly and observing the controlled processing rate."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.Queue\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext\n\n// Define the BufferedActor\nclass BufferedActor extends Actor {\n  import context.dispatcher\n\n  // Internal message queue\n  val messageQueue: Queue[String] = Queue.empty\n\n  // Processing state\n  var isProcessing: Boolean = false\n  var timer: Option[Cancellable] = None\n\n  def receive: Receive = {\n    case msg: String =>\n      messageQueue.enqueue(msg)\n      processNext()\n\n    case \"process\" =>\n      if (messageQueue.nonEmpty) {\n        val msg = messageQueue.dequeue()\n        println(s\"BufferedActor processing message: $msg\")\n        // Simulate processing delay\n        timer = Some(context.system.scheduler.scheduleOnce(500.milliseconds, self, \"process\"))\n      } else {\n        isProcessing = false\n      }\n  }\n\n  def processNext(): Unit = {\n    if (!isProcessing && messageQueue.nonEmpty) {\n      isProcessing = true\n      self ! \"process\"\n    }\n  }\n\n  override def postStop(): Unit = {\n    timer.foreach(_.cancel())\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BufferedActorApp extends App {\n  val system = ActorSystem(\"BufferedActorSystem\")\n  val bufferedActor = system.actorOf(Props[BufferedActor](), \"bufferedActor\")\n\n  // Send multiple messages rapidly\n  for (i <- 1 to 5) {\n    bufferedActor ! s\"Message $i\"\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(4000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SelfTerminator that monitors the number of messages it has processed. After processing 10 messages, it should gracefully stop itself by sending a \"shutdown\" message to itself. Demonstrate the actor processing messages and terminating after the threshold is reached."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the SelfTerminator Actor\nclass SelfTerminator extends Actor {\n  var messageCount: Int = 0\n\n  def receive: Receive = {\n    case msg: String =>\n      messageCount += 1\n      println(s\"SelfTerminator processed message: $msg (Count: $messageCount)\")\n      if (messageCount >= 10) {\n        println(\"SelfTerminator reached message limit. Shutting down.\")\n        self ! \"shutdown\"\n      }\n    case \"shutdown\" =>\n      println(\"SelfTerminator is shutting itself down.\")\n      context.stop(self)\n    case _ =>\n      println(\"SelfTerminator received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelfTerminatorApp extends App {\n  val system = ActorSystem(\"SelfTerminatorSystem\")\n  val terminator = system.actorOf(Props[SelfTerminator](), \"terminatorActor\")\n\n  // Send 12 messages to demonstrate termination after 10\n  for (i <- 1 to 12) {\n    terminator ! s\"Message $i\"\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named PriorityHandlerActor that handles high-priority and low-priority messages differently. Without using a custom mailbox, implement the actor such that it always processes high-priority messages (\"HighPriority\") before any pending low-priority messages (\"LowPriority\"), regardless of the order they were received."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Define the PriorityHandlerActor\nclass PriorityHandlerActor extends Actor with Stash {\n  def receive: Receive = {\n    case \"HighPriority\" =>\n      println(\"Processing High Priority message.\")\n      unstashAll()\n      context.become(normal)\n    case \"LowPriority\" =>\n      println(\"Stashing Low Priority message.\")\n      stash()\n    case msg =>\n      println(s\"Received unknown message: $msg\")\n  }\n\n  def normal: Receive = {\n    case \"HighPriority\" =>\n      println(\"Processing High Priority message.\")\n    case \"LowPriority\" =>\n      println(\"Processing Low Priority message.\")\n    case msg =>\n      println(s\"Received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PriorityHandlerApp extends App {\n  val system = ActorSystem(\"PriorityHandlerSystem\")\n  val priorityHandler = system.actorOf(Props[PriorityHandlerActor](), \"priorityHandler\")\n\n  // Send messages in mixed order\n  priorityHandler ! \"LowPriority\"   // Should be stashed\n  priorityHandler ! \"LowPriority\"   // Should be stashed\n  priorityHandler ! \"HighPriority\"  // Should process immediately and unstash\n  priorityHandler ! \"HighPriority\"  // Should process immediately\n  priorityHandler ! \"LowPriority\"   // Should process now\n  priorityHandler ! \"LowPriority\"   // Should process now\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named ForwardingActor that forwards any received message to another actor named DestinationActor using the forward method. Ensure that the original sender is preserved when forwarding messages. Demonstrate the forwarding behavior by sending messages through the ForwardingActor and verifying that DestinationActor receives them with the correct sender reference."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the DestinationActor\nclass DestinationActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"DestinationActor received message: $msg from ${sender().path.name}\")\n  }\n}\n\n// Define the ForwardingActor\nclass ForwardingActor(destination: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ForwardingActor forwarding message: $msg\")\n      destination.forward(msg) // Preserves the original sender\n  }\n}\n\n// Define a Simple Sender Actor for demonstration\nclass SenderActor(forwarding: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"SenderActor sending message: $msg\")\n      forwarding ! msg\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ForwardingApp extends App {\n  val system = ActorSystem(\"ForwardingSystem\")\n  \n  val destination = system.actorOf(Props[DestinationActor](), \"destinationActor\")\n  val forwarding = system.actorOf(Props(new ForwardingActor(destination)), \"forwardingActor\")\n  val senderActor = system.actorOf(Props(new SenderActor(forwarding)), \"senderActor\")\n  \n  // Send messages through the SenderActor\n  senderActor ! \"Hello via Forwarding!\"\n  senderActor ! \"Another forwarded message.\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TerminatorActor that performs a simple task upon receiving any message. Demonstrate the use of Akka's PoisonPill to forcefully terminate the actor after it processes a few messages. Verify that the actor stops receiving messages post-termination."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, PoisonPill}\n\n// Define the TerminatorActor\nclass TerminatorActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"TerminatorActor received message: $msg\")\n    case _ =>\n      println(\"TerminatorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TerminatorApp extends App {\n  val system = ActorSystem(\"TerminatorSystem\")\n  val terminator = system.actorOf(Props[TerminatorActor](), \"terminatorActor\")\n\n  // Send messages to the actor\n  terminator ! \"Message 1\"\n  terminator ! \"Message 2\"\n  terminator ! \"Message 3\"\n\n  // Send PoisonPill to terminate the actor\n  terminator ! PoisonPill\n\n  // Attempt to send more messages after termination\n  terminator ! \"Message after PoisonPill\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named BatchingActor that collects incoming integer messages and processes them in batches of three. Upon receiving the third message, it should calculate and print the sum of the batch and then reset to collect the next batch. Demonstrate the batching behavior by sending multiple messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the BatchingActor\nclass BatchingActor extends Actor {\n  var buffer: List[Int] = List.empty\n\n  def receive: Receive = {\n    case num: Int =>\n      buffer = num :: buffer\n      println(s\"BatchingActor received: $num (Buffer size: ${buffer.size})\")\n      if (buffer.size >= 3) {\n        val sum = buffer.sum\n        println(s\"BatchingActor processing batch: ${buffer.reverse} with sum: $sum\")\n        buffer = List.empty\n      }\n    case _ =>\n      println(\"BatchingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BatchingActorApp extends App {\n  val system = ActorSystem(\"BatchingActorSystem\")\n  val batchingActor = system.actorOf(Props[BatchingActor](), \"batchingActor\")\n\n  // Send multiple integer messages\n  batchingActor ! 5\n  batchingActor ! 10\n  batchingActor ! 15  // This should trigger batch processing\n  batchingActor ! 20\n  batchingActor ! 25\n  batchingActor ! 30  // Another batch processing\n  batchingActor ! 35  // Partial batch\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Supervisor Actor in Scala named ResumeSupervisor that supervises a child actor named ResumeChildActor. The child actor should throw a RuntimeException when it receives a \"runtime\" message and an IllegalArgumentException when it receives an \"illegal\" message. Configure the supervisor's strategy to resume the child actor on RuntimeException and stop it on IllegalArgumentException. Demonstrate the different outcomes by sending both types of messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy._\nimport scala.concurrent.duration._\n\n// Define the ResumeChildActor\nclass ResumeChildActor extends Actor {\n  def receive: Receive = {\n    case \"runtime\" =>\n      println(s\"${self.path.name} received 'runtime' and will throw RuntimeException.\")\n      throw new RuntimeException(\"Simulated RuntimeException.\")\n    case \"illegal\" =>\n      println(s\"${self.path.name} received 'illegal' and will throw IllegalArgumentException.\")\n      throw new IllegalArgumentException(\"Simulated IllegalArgumentException.\")\n    case msg =>\n      println(s\"${self.path.name} received message: $msg\")\n  }\n}\n\n// Define the ResumeSupervisor Actor\nclass ResumeSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy() {\n    case _: RuntimeException =>\n      println(\"ResumeSupervisor: Resuming child actor after RuntimeException.\")\n      Resume\n    case _: IllegalArgumentException =>\n      println(\"ResumeSupervisor: Stopping child actor after IllegalArgumentException.\")\n      Stop\n    case _: Exception =>\n      println(\"ResumeSupervisor: Escalating unknown exception.\")\n      Escalate\n  }\n\n  // Create the child actor\n  val child: ActorRef = context.actorOf(Props[ResumeChildActor](), \"resumeChildActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ResumeSupervisorApp extends App {\n  val system = ActorSystem(\"ResumeSupervisorSystem\")\n  val supervisor = system.actorOf(Props[ResumeSupervisor](), \"resumeSupervisor\")\n\n  // Send a message that causes RuntimeException (should resume)\n  supervisor ! \"runtime\"\n  supervisor ! \"Post-runtime message\"\n\n  // Send a message that causes IllegalArgumentException (should stop)\n  supervisor ! \"illegal\"\n  supervisor ! \"Post-illegal message\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor system in Scala with three actors: InitiatorActor, ResponderActor, and LoggerActor. The InitiatorActor sends a Request message to the ResponderActor. Upon receiving a Request, the ResponderActor replies with a Response message. The InitiatorActor then forwards this Response to the LoggerActor for logging. Demonstrate the message flow between these actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase object Request\ncase class Response(content: String)\ncase class LogMessage(message: String)\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Request =>\n      println(s\"${self.path.name} received Request.\")\n      sender() ! Response(\"Here is your response!\")\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the LoggerActor\nclass LoggerActor extends Actor {\n  def receive: Receive = {\n    case LogMessage(msg) =>\n      println(s\"LoggerActor logging message: $msg\")\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the InitiatorActor\nclass InitiatorActor(responder: ActorRef, logger: ActorRef) extends Actor {\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"${self.path.name} sending Request to ResponderActor.\")\n      responder ! Request\n    case Response(content) =>\n      println(s\"${self.path.name} received Response: $content\")\n      logger ! LogMessage(content)\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject MultipleActorsApp extends App {\n  val system = ActorSystem(\"MultipleActorsSystem\")\n\n  val logger = system.actorOf(Props[LoggerActor](), \"loggerActor\")\n  val responder = system.actorOf(Props[ResponderActor](), \"responderActor\")\n  val initiator = system.actorOf(Props(new InitiatorActor(responder, logger)), \"initiatorActor\")\n\n  // Start the message flow\n  initiator ! \"start\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named MultiTypeActor that handles three different message types: TextMessage(content: String), NumberMessage(value: Int), and Shutdown. For TextMessage, it should print the content. For NumberMessage, it should calculate and print the square of the value. Upon receiving Shutdown, it should gracefully stop itself. Demonstrate handling each message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define messages\ncase class TextMessage(content: String)\ncase class NumberMessage(value: Int)\ncase object Shutdown\n\n// Define the MultiTypeActor\nclass MultiTypeActor extends Actor {\n  def receive: Receive = {\n    case TextMessage(content) =>\n      println(s\"MultiTypeActor received TextMessage: $content\")\n    case NumberMessage(value) =>\n      val square = value * value\n      println(s\"MultiTypeActor received NumberMessage: $value, square: $square\")\n    case Shutdown =>\n      println(\"MultiTypeActor received Shutdown. Stopping...\")\n      context.stop(self)\n    case _ =>\n      println(\"MultiTypeActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject MultiTypeActorApp extends App {\n  val system = ActorSystem(\"MultiTypeActorSystem\")\n  val multiTypeActor = system.actorOf(Props[MultiTypeActor](), \"multiTypeActor\")\n\n  // Send different types of messages\n  multiTypeActor ! TextMessage(\"Hello, Akka!\")\n  multiTypeActor ! NumberMessage(7)\n  multiTypeActor ! \"Unknown Message\" // Should trigger unknown message handler\n  multiTypeActor ! Shutdown\n  multiTypeActor ! TextMessage(\"This should not be processed.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CalculatorActor that performs basic arithmetic operations. It should handle messages in the form of Calculate(operation: String, a: Int, b: Int), where operation can be \"add\", \"subtract\", \"multiply\", or \"divide\". The actor should perform the requested operation on the integers a and b and reply with the result. Handle division by zero by replying with an error message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\n\n// Define the Calculate message\ncase class Calculate(operation: String, a: Int, b: Int)\n\n// Define the CalculatorActor\nclass CalculatorActor extends Actor {\n  def receive: Receive = {\n    case Calculate(op, a, b) =>\n      val result = op.toLowerCase match {\n        case \"add\"      => a + b\n        case \"subtract\" => a - b\n        case \"multiply\" => a * b\n        case \"divide\" =>\n          if (b != 0) a.toDouble / b else \"Error: Division by zero\"\n        case _ => \"Error: Unknown operation\"\n      }\n      sender() ! result\n    case _ =>\n      sender() ! \"Error: Unknown message type.\"\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CalculatorActorApp extends App {\n  val system = ActorSystem(\"CalculatorSystem\")\n  val calculator = system.actorOf(Props[CalculatorActor](), \"calculatorActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to perform calculation and print result\n  def performCalculation(op: String, a: Int, b: Int): Unit = {\n    val future = calculator ? Calculate(op, a, b)\n    val result = Await.result(future, timeout.duration)\n    println(s\"Calculate($op, $a, $b) = $result\")\n  }\n\n  // Perform various calculations\n  performCalculation(\"add\", 10, 5)        // 15\n  performCalculation(\"subtract\", 10, 5)   // 5\n  performCalculation(\"multiply\", 10, 5)   // 50\n  performCalculation(\"divide\", 10, 5)     // 2.0\n  performCalculation(\"divide\", 10, 0)     // Error: Division by zero\n  performCalculation(\"modulo\", 10, 5)     // Error: Unknown operation\n\n  // Shutdown the system\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named BroadcasterActor that maintains a list of subscriber actors. It should handle Subscribe(subscriber: ActorRef) and Broadcast(message: String) messages. Upon receiving a Subscribe message, it should add the actor to its subscriber list. When a Broadcast message is received, it should send the message to all subscribed actors. Demonstrate subscribing multiple actors and broadcasting messages to them."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(subscriber: ActorRef)\ncase class Broadcast(message: String)\n\n// Define the BroadcasterActor\nclass BroadcasterActor extends Actor {\n  var subscribers: Set[ActorRef] = Set.empty\n\n  def receive: Receive = {\n    case Subscribe(subscriber) =>\n      subscribers += subscriber\n      println(s\"BroadcasterActor added subscriber: ${subscriber.path.name}\")\n    case Broadcast(msg) =>\n      println(s\"BroadcasterActor broadcasting message: $msg to ${subscribers.size} subscribers.\")\n      subscribers.foreach(_ ! msg)\n    case _ =>\n      println(\"BroadcasterActor received unknown message.\")\n  }\n}\n\n// Define a Subscriber Actor\nclass SubscriberActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"Subscriber [$name] received broadcast message: $msg\")\n    case _ =>\n      println(s\"Subscriber [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BroadcasterApp extends App {\n  val system = ActorSystem(\"BroadcasterSystem\")\n  val broadcaster = system.actorOf(Props[BroadcasterActor](), \"broadcasterActor\")\n\n  // Create subscriber actors\n  val subscriber1 = system.actorOf(Props(new SubscriberActor(\"Alice\")), \"subscriber1\")\n  val subscriber2 = system.actorOf(Props(new SubscriberActor(\"Bob\")), \"subscriber2\")\n  val subscriber3 = system.actorOf(Props(new SubscriberActor(\"Charlie\")), \"subscriber3\")\n\n  // Subscribers subscribe to the broadcaster\n  broadcaster ! Subscribe(subscriber1)\n  broadcaster ! Subscribe(subscriber2)\n  broadcaster ! Subscribe(subscriber3)\n\n  // Broadcast messages\n  broadcaster ! Broadcast(\"Welcome to the broadcast system!\")\n  broadcaster ! Broadcast(\"This is the second broadcast message.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SelectorActor that uses actor selection to send a message to another actor named TargetActor located at a specific path within the same actor system. Demonstrate selecting the TargetActor and sending a \"Hello Target!\" message using actor selection."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the TargetActor\nclass TargetActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"TargetActor received message: $msg from ${sender().path.name}\")\n    case _ =>\n      println(\"TargetActor received unknown message.\")\n  }\n}\n\n// Define the SelectorActor\nclass SelectorActor extends Actor {\n  def receive: Receive = {\n    case \"sendHello\" =>\n      // Actor selection path\n      val targetPath = \"/user/targetActor\"\n      val target = context.actorSelection(targetPath)\n      println(s\"SelectorActor sending 'Hello Target!' to $targetPath\")\n      target ! \"Hello Target!\"\n    case _ =>\n      println(\"SelectorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelectorApp extends App {\n  val system = ActorSystem(\"SelectorSystem\")\n  \n  // Create TargetActor\n  val target = system.actorOf(Props[TargetActor](), \"targetActor\")\n  \n  // Create SelectorActor\n  val selector = system.actorOf(Props[SelectorActor](), \"selectorActor\")\n  \n  // Send a message to SelectorActor to send message to TargetActor\n  selector ! \"sendHello\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AcknowledgingActor that acknowledges each received message by replying with \"Ack\". Implement a sender actor named RequesterActor that sends multiple messages to AcknowledgingActor and waits for acknowledgments before sending the next message. Demonstrate the acknowledgment mechanism."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define the AcknowledgingActor\nclass AcknowledgingActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"AcknowledgingActor received message: $msg from ${sender().path.name}\")\n      sender() ! \"Ack\"\n  }\n}\n\n// Define the RequesterActor\nclass RequesterActor(ackActor: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(3.seconds)\n\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"RequesterActor sending message: $msg\")\n      val future = ackActor ? msg\n      future.map {\n        case \"Ack\" =>\n          println(s\"RequesterActor received Ack for message: $msg\")\n          // Optionally, send next message or perform other actions\n      }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject AcknowledgmentApp extends App {\n  val system = ActorSystem(\"AcknowledgmentSystem\")\n  \n  val acknowledgingActor = system.actorOf(Props[AcknowledgingActor](), \"acknowledgingActor\")\n  val requesterActor = system.actorOf(Props(new RequesterActor(acknowledgingActor)), \"requesterActor\")\n  \n  // Send multiple messages\n  requesterActor ! \"Message 1\"\n  requesterActor ! \"Message 2\"\n  requesterActor ! \"Message 3\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named TransformerActor that receives messages containing integers, multiplies each integer by 2, and forwards the transformed message to another actor named ReceiverActor. Demonstrate the transformation and forwarding behavior by sending integer messages to the TransformerActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the TransformerActor\nclass TransformerActor(receiver: ActorRef) extends Actor {\n  def receive: Receive = {\n    case num: Int =>\n      val transformed = num * 2\n      println(s\"TransformerActor received: $num, transformed to: $transformed\")\n      receiver ! transformed\n    case _ =>\n      println(\"TransformerActor received unknown message.\")\n  }\n}\n\n// Define the ReceiverActor\nclass ReceiverActor extends Actor {\n  def receive: Receive = {\n    case msg: Int =>\n      println(s\"ReceiverActor received transformed message: $msg\")\n    case _ =>\n      println(\"ReceiverActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TransformerApp extends App {\n  val system = ActorSystem(\"TransformerSystem\")\n  \n  val receiver = system.actorOf(Props[ReceiverActor](), \"receiverActor\")\n  val transformer = system.actorOf(Props(new TransformerActor(receiver)), \"transformerActor\")\n  \n  // Send integer messages to TransformerActor\n  transformer ! 5\n  transformer ! 10\n  transformer ! 15\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named ResponderWithTimeout that replies to any Ping message with a Pong after a delay of 2 seconds. Implement a RequesterWithTimeout actor that sends a Ping message to ResponderWithTimeout and waits for a Pong reply with a timeout of 1 second. Handle the timeout scenario by printing \"Request timed out\" if no reply is received in time."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define messages\ncase object Ping\ncase object Pong\n\n// Define the ResponderWithTimeout Actor\nclass ResponderWithTimeout extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case Ping =>\n      println(s\"${self.path.name} received Ping. Will respond with Pong after delay.\")\n      context.system.scheduler.scheduleOnce(2.seconds, sender(), Pong)\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the RequesterWithTimeout Actor\nclass RequesterWithTimeout(responder: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(1.second)\n\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"${self.path.name} sending Ping to ${responder.path.name}\")\n      val future = responder ? Ping\n      future.onComplete {\n        case Success(Pong) =>\n          println(s\"${self.path.name} received Pong.\")\n        case Failure(_) =>\n          println(s\"${self.path.name} Request timed out.\")\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TimeoutApp extends App {\n  val system = ActorSystem(\"TimeoutSystem\")\n  \n  val responder = system.actorOf(Props[ResponderWithTimeout](), \"responderWithTimeout\")\n  val requester = system.actorOf(Props(new RequesterWithTimeout(responder)), \"requesterWithTimeout\")\n  \n  // Start the request\n  requester ! \"start\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(3000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named FileReaderActor that reads the contents of a specified text file upon receiving a ReadFile(path: String) message. After reading the file, it should send the file contents back to the sender wrapped in a FileContents(contents: String) message. Demonstrate reading a sample file and handling the response."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.io.Source\nimport scala.util.{Try, Success, Failure}\n\n// Define messages\ncase class ReadFile(path: String)\ncase class FileContents(contents: String)\ncase class FileReadError(error: String)\n\n// Define the FileReaderActor\nclass FileReaderActor extends Actor {\n  def receive: Receive = {\n    case ReadFile(path) =>\n      println(s\"${self.path.name} received request to read file: $path\")\n      val senderRef = sender()\n      val fileContentTry: Try[String] = Try {\n        Source.fromFile(path).mkString\n      }\n      fileContentTry match {\n        case Success(contents) =>\n          senderRef ! FileContents(contents)\n        case Failure(exception) =>\n          senderRef ! FileReadError(exception.getMessage)\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject FileReaderApp extends App {\n  val system = ActorSystem(\"FileReaderSystem\")\n  val fileReader = system.actorOf(Props(new FileReaderActor()), \"fileReaderActor\")\n\n  // Define a simple responder actor to handle responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case FileContents(contents) =>\n        println(s\"ResponderActor received file contents:\\n$contents\")\n      case FileReadError(error) =>\n        println(s\"ResponderActor encountered an error: $error\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Send a ReadFile message\n  fileReader.tell(ReadFile(\"sample.txt\"), responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named PeriodicReporterActor that sends a Report message to itself every 3 seconds. Upon receiving the Report message, it should print the current timestamp to the console. Demonstrate the periodic reporting behavior and ensure the actor stops reporting after five reports."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport java.time.LocalDateTime\n\n// Define the Report message\ncase object Report\n\n// Define the PeriodicReporterActor\nclass PeriodicReporterActor extends Actor {\n  import context.dispatcher\n\n  var reportCount: Int = 0\n  val maxReports: Int = 5\n\n  // Schedule periodic Report messages\n  val cancellable: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = 0.seconds,\n    delay = 3.seconds,\n    receiver = self,\n    message = Report\n  )\n\n  def receive: Receive = {\n    case Report =>\n      reportCount += 1\n      val timestamp = LocalDateTime.now()\n      println(s\"PeriodicReporterActor Report #$reportCount at $timestamp\")\n      if (reportCount >= maxReports) {\n        println(\"PeriodicReporterActor reached maximum reports. Stopping.\")\n        cancellable.cancel()\n        context.stop(self)\n      }\n    case _ =>\n      println(\"PeriodicReporterActor received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    cancellable.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PeriodicReporterApp extends App {\n  val system = ActorSystem(\"PeriodicReporterSystem\")\n  val reporter = system.actorOf(Props(new PeriodicReporterActor()), \"reporterActor\")\n\n  // Allow some time for reports before shutdown\n  Thread.sleep(16000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CacheActor that acts as an in-memory cache. It should handle Put(key: String, value: String) messages to store key-value pairs and Get(key: String) messages to retrieve values. Upon receiving a Get message, it should respond with ValueFound(key: String, value: String) if the key exists or ValueNotFound(key: String) if it doesn't. Demonstrate storing and retrieving values from the cache."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Put(key: String, value: String)\ncase class Get(key: String)\ncase class ValueFound(key: String, value: String)\ncase class ValueNotFound(key: String)\n\n// Define the CacheActor\nclass CacheActor extends Actor {\n  var cache: Map[String, String] = Map.empty\n\n  def receive: Receive = {\n    case Put(key, value) =>\n      cache += (key -> value)\n      println(s\"CacheActor stored: [$key -> $value]\")\n    case Get(key) =>\n      cache.get(key) match {\n        case Some(value) =>\n          sender() ! ValueFound(key, value)\n        case None =>\n          sender() ! ValueNotFound(key)\n      }\n    case _ =>\n      println(\"CacheActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CacheApp extends App {\n  val system = ActorSystem(\"CacheSystem\")\n  val cacheActor = system.actorOf(Props(new CacheActor()), \"cacheActor\")\n\n  // Define a simple responder actor to handle cache responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case ValueFound(key, value) =>\n        println(s\"ResponderActor: Found [$key -> $value] in cache.\")\n      case ValueNotFound(key) =>\n        println(s\"ResponderActor: No entry found for key '$key'.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Store some key-value pairs\n  cacheActor ! Put(\"name\", \"Alice\")\n  cacheActor ! Put(\"city\", \"Wonderland\")\n\n  // Retrieve existing and non-existing keys\n  cacheActor.tell(Get(\"name\"), responder)\n  cacheActor.tell(Get(\"country\"), responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named LoggingActor that logs incoming messages to a file. It should handle Log(message: String) messages by appending them to a specified log file. Ensure that the actor handles file I/O exceptions gracefully by logging errors to the console. Demonstrate logging multiple messages to a file."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport java.io.{File, FileWriter, BufferedWriter}\nimport scala.util.{Try, Success, Failure}\n\n// Define messages\ncase class Log(message: String)\n\n// Define the LoggingActor\nclass LoggingActor(logFilePath: String) extends Actor {\n  // Initialize the log file\n  val logFile: File = new File(logFilePath)\n  val bw: BufferedWriter = new BufferedWriter(new FileWriter(logFile, true)) // Append mode\n\n  override def postStop(): Unit = {\n    bw.close()\n    super.postStop()\n  }\n\n  def receive: Receive = {\n    case Log(msg) =>\n      Try {\n        bw.write(s\"${java.time.LocalDateTime.now()}: $msg\\n\")\n        bw.flush()\n      } match {\n        case Success(_) =>\n          println(s\"LoggingActor: Logged message to $logFilePath\")\n        case Failure(exception) =>\n          println(s\"LoggingActor encountered an error: ${exception.getMessage}\")\n      }\n    case _ =>\n      println(\"LoggingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LoggingApp extends App {\n  val system = ActorSystem(\"LoggingSystem\")\n  val loggingActor = system.actorOf(Props(new LoggingActor(\"application.log\")), \"loggingActor\")\n\n  // Define a simple logger to send Log messages\n  class Logger extends Actor {\n    def receive: Receive = {\n      case msg: String =>\n        loggingActor ! Log(msg)\n      case _ =>\n        println(\"Logger received unknown message.\")\n    }\n  }\n\n  val logger = system.actorOf(Props[Logger](), \"logger\")\n\n  // Send log messages\n  logger ! \"Application started.\"\n  logger ! \"Performing some operations.\"\n  logger ! \"Application finished successfully.\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named NotificationActor that sends notifications to users. It should handle Notify(user: String, message: String) messages by printing a personalized notification to the console. Implement a UserActor that represents a user and sends Notify messages to the NotificationActor. Demonstrate sending notifications to multiple users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Notify(user: String, message: String)\n\n// Define the NotificationActor\nclass NotificationActor extends Actor {\n  def receive: Receive = {\n    case Notify(user, message) =>\n      println(s\"Notification to $user: $message\")\n    case _ =>\n      println(\"NotificationActor received unknown message.\")\n  }\n}\n\n// Define the UserActor\nclass UserActor(name: String, notifier: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      notifier ! Notify(name, msg)\n    case _ =>\n      println(s\"UserActor [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject NotificationApp extends App {\n  val system = ActorSystem(\"NotificationSystem\")\n  val notificationActor = system.actorOf(Props(new NotificationActor()), \"notificationActor\")\n\n  // Create user actors\n  val user1 = system.actorOf(Props(new UserActor(\"Alice\", notificationActor)), \"userAlice\")\n  val user2 = system.actorOf(Props(new UserActor(\"Bob\", notificationActor)), \"userBob\")\n  val user3 = system.actorOf(Props(new UserActor(\"Charlie\", notificationActor)), \"userCharlie\")\n\n  // Send notifications\n  user1 ! \"Your order has been shipped.\"\n  user2 ! \"You have a new message.\"\n  user3 ! \"Your subscription is about to expire.\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named EventEmitterActor that emits events to subscribed listeners. It should handle Subscribe(listener: ActorRef) and EmitEvent(event: String) messages. Upon receiving EmitEvent, it should send the event to all subscribed listeners wrapped in an Event(event: String) message. Demonstrate subscribing multiple listeners and emitting events."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(listener: ActorRef)\ncase class EmitEvent(event: String)\ncase class Event(event: String)\n\n// Define the EventEmitterActor\nclass EventEmitterActor extends Actor {\n  var listeners: Set[ActorRef] = Set.empty\n\n  def receive: Receive = {\n    case Subscribe(listener) =>\n      listeners += listener\n      println(s\"EventEmitterActor: ${listener.path.name} subscribed.\")\n    case EmitEvent(event) =>\n      println(s\"EventEmitterActor: Emitting event: $event to ${listeners.size} listeners.\")\n      listeners.foreach(_ ! Event(event))\n    case _ =>\n      println(\"EventEmitterActor received unknown message.\")\n  }\n}\n\n// Define the ListenerActor\nclass ListenerActor(name: String) extends Actor {\n  def receive: Receive = {\n    case Event(event) =>\n      println(s\"Listener [$name] received event: $event\")\n    case _ =>\n      println(s\"Listener [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EventEmitterApp extends App {\n  val system = ActorSystem(\"EventEmitterSystem\")\n  val eventEmitter = system.actorOf(Props(new EventEmitterActor()), \"eventEmitterActor\")\n\n  // Create listener actors\n  val listener1 = system.actorOf(Props(new ListenerActor(\"Listener1\")), \"listener1\")\n  val listener2 = system.actorOf(Props(new ListenerActor(\"Listener2\")), \"listener2\")\n  val listener3 = system.actorOf(Props(new ListenerActor(\"Listener3\")), \"listener3\")\n\n  // Subscribe listeners\n  eventEmitter ! Subscribe(listener1)\n  eventEmitter ! Subscribe(listener2)\n  eventEmitter ! Subscribe(listener3)\n\n  // Emit events\n  eventEmitter ! EmitEvent(\"UserLoggedIn\")\n  eventEmitter ! EmitEvent(\"FileUploaded\")\n  eventEmitter ! EmitEvent(\"ErrorOccurred\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named RateLimiterActor that restricts the number of incoming Request messages to 3 per second using the token bucket algorithm. Each Request(id: Int) consumes a token. If tokens are available, process the request by printing \"Processed request <id>\"; otherwise, respond with \"Rate limit exceeded for request <id>\". Refill the bucket with 3 tokens every second. Demonstrate sending multiple requests rapidly and observing the rate limiter in action."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.collection.mutable.Queue\nimport akka.actor.Timers\n\n// Define messages\ncase class Request(id: Int)\ncase class Response(message: String)\n\n// Define the RateLimiterActor\nclass RateLimiterActor extends Actor {\n  import context.dispatcher\n\n  val maxTokens: Int = 3\n  var tokens: Int = maxTokens\n  val requestQueue: Queue[(ActorRef, Request)] = Queue.empty\n\n  // Schedule token refill every second\n  val refillInterval: FiniteDuration = 1.second\n  val refillTask: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = refillInterval,\n    delay = refillInterval,\n    receiver = self,\n    message = \"Refill\"\n  )\n\n  def receive: Receive = {\n    case \"Refill\" =>\n      tokens = maxTokens\n      println(s\"RateLimiterActor: Tokens refilled to $tokens\")\n      processQueue()\n\n    case req @ Request(id) =>\n      if (tokens > 0) {\n        tokens -= 1\n        println(s\"RateLimiterActor: Processed request $id (Tokens left: $tokens)\")\n        sender() ! Response(s\"Processed request $id\")\n      } else {\n        println(s\"RateLimiterActor: Rate limit exceeded for request $id. Queuing request.\")\n        requestQueue.enqueue((sender(), req))\n      }\n\n    case _ =>\n      println(\"RateLimiterActor received unknown message.\")\n  }\n\n  def processQueue(): Unit = {\n    while (tokens > 0 && requestQueue.nonEmpty) {\n      val (senderRef, Request(id)) = requestQueue.dequeue()\n      tokens -= 1\n      println(s\"RateLimiterActor: Processed queued request $id (Tokens left: $tokens)\")\n      senderRef ! Response(s\"Processed request $id\")\n    }\n  }\n\n  override def postStop(): Unit = {\n    refillTask.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject RateLimiterApp extends App {\n  import akka.pattern.ask\n  import akka.util.Timeout\n  import scala.concurrent.Await\n\n  val system = ActorSystem(\"RateLimiterSystem\")\n  val rateLimiter = system.actorOf(Props[RateLimiterActor](), \"rateLimiterActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to send a request and print the response\n  def sendRequest(id: Int): Unit = {\n    val future = rateLimiter ? Request(id)\n    val result = Await.result(future, timeout.duration).asInstanceOf[Response]\n    println(s\"Request $id: ${result.message}\")\n  }\n\n  // Send 5 requests rapidly\n  for (i <- 1 to 5) {\n    sendRequest(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named WorkerPoolActor that manages a pool of worker actors. It should handle Task(taskId: Int) messages by forwarding them to workers in a round-robin fashion. Each WorkerActor processes the task by printing \"Worker <name> processing task <taskId>\". Demonstrate the worker pool handling multiple tasks efficiently."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Task(taskId: Int)\n\n// Define the WorkerActor\nclass WorkerActor(name: String) extends Actor {\n  def receive: Receive = {\n    case Task(id) =>\n      println(s\"Worker [$name] processing task $id\")\n    case _ =>\n      println(s\"Worker [$name] received unknown message.\")\n  }\n}\n\n// Define the WorkerPoolActor\nclass WorkerPoolActor(workers: Seq[ActorRef]) extends Actor {\n  var nextWorkerIndex: Int = 0\n  val numberOfWorkers: Int = workers.size\n\n  def receive: Receive = {\n    case task: Task =>\n      val worker = workers(nextWorkerIndex)\n      println(s\"WorkerPoolActor delegating Task ${task.taskId} to Worker ${worker.path.name}\")\n      worker ! task\n      nextWorkerIndex = (nextWorkerIndex + 1) % numberOfWorkers\n    case _ =>\n      println(\"WorkerPoolActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject WorkerPoolApp extends App {\n  val system = ActorSystem(\"WorkerPoolSystem\")\n\n  // Create worker actors\n  val worker1 = system.actorOf(Props(new WorkerActor(\"worker1\")), \"worker1\")\n  val worker2 = system.actorOf(Props(new WorkerActor(\"worker2\")), \"worker2\")\n  val worker3 = system.actorOf(Props(new WorkerActor(\"worker3\")), \"worker3\")\n\n  // Create WorkerPoolActor with the workers\n  val workerPool = system.actorOf(Props(new WorkerPoolActor(Seq(worker1, worker2, worker3))), \"workerPoolActor\")\n\n  // Send multiple tasks to the pool\n  for (i <- 1 to 9) {\n    workerPool ! Task(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named HealthCheckerActor that performs periodic health checks of a simulated service. It should send a CheckHealth message to itself every 4 seconds. Upon receiving CheckHealth, it should randomly determine if the service is healthy or unhealthy and respond accordingly with Healthy or Unhealthy. Demonstrate the health checking mechanism."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.util.Random\n\n// Define messages\ncase object CheckHealth\ncase object Healthy\ncase object Unhealthy\n\n// Define the HealthCheckerActor\nclass HealthCheckerActor extends Actor {\n  import context.dispatcher\n\n  // Schedule periodic health checks\n  val checkInterval: FiniteDuration = 4.seconds\n  val scheduler: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = 0.seconds,\n    delay = checkInterval,\n    receiver = self,\n    message = CheckHealth\n  )\n\n  def receive: Receive = {\n    case CheckHealth =>\n      val status = if (Random.nextBoolean()) Healthy else Unhealthy\n      println(s\"HealthCheckerActor: Service status is $status\")\n    case _ =>\n      println(\"HealthCheckerActor received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    scheduler.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject HealthCheckerApp extends App {\n  val system = ActorSystem(\"HealthCheckerSystem\")\n  val healthChecker = system.actorOf(Props(new HealthCheckerActor()), \"healthCheckerActor\")\n\n  // Let the health checker run for 20 seconds before shutdown\n  Thread.sleep(20000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named RetryingActor that handles PerformTask(taskId: Int) messages. Upon receiving a task, it attempts to perform it by randomly succeeding or failing. If a task fails, it should retry up to two additional times before giving up and logging \"Task <taskId> failed after retries.\". Demonstrate the retry mechanism by sending multiple tasks."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.util.Random\n\n// Define messages\ncase class PerformTask(taskId: Int)\ncase class TaskResult(taskId: Int, success: Boolean)\ncase class RetryTask(taskId: Int, attempt: Int)\n\n// Define the RetryingActor\nclass RetryingActor extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case PerformTask(taskId) =>\n      println(s\"RetryingActor: Performing task $taskId (Attempt 1)\")\n      performTask(taskId, attempt = 1)\n    case RetryTask(taskId, attempt) =>\n      println(s\"RetryingActor: Retrying task $taskId (Attempt $attempt)\")\n      performTask(taskId, attempt)\n    case TaskResult(taskId, success) =>\n      if (success) {\n        println(s\"RetryingActor: Task $taskId completed successfully.\")\n      } else {\n        println(s\"RetryingActor: Task $taskId failed.\")\n        if (sender().path.name.startsWith(\"retry\")) {\n          val attempt = sender().path.name.split(\"-\")(1).toInt\n          if (attempt < 3) {\n            // Schedule a retry\n            context.system.scheduler.scheduleOnce(1.second, self, RetryTask(taskId, attempt + 1))\n          } else {\n            println(s\"RetryingActor: Task $taskId failed after retries.\")\n          }\n        }\n      }\n    case _ =>\n      println(\"RetryingActor received unknown message.\")\n  }\n\n  def performTask(taskId: Int, attempt: Int): Unit = {\n    val success = Random.nextBoolean()\n    if (success) {\n      self.tell(TaskResult(taskId, success = true), self)\n    } else {\n      // Create a unique sender name for retries\n      val retrySender = context.actorOf(Props(new Actor {\n        def receive: Receive = {\n          case msg => self.tell(msg, self)\n        }\n      }), name = s\"retry-$attempt\")\n      retrySender ! TaskResult(taskId, success = false)\n    }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject RetryingActorApp extends App {\n  val system = ActorSystem(\"RetryingActorSystem\")\n  val retryingActor = system.actorOf(Props(new RetryingActor()), \"retryingActor\")\n\n  // Send multiple tasks\n  for (i <- 1 to 5) {\n    retryingActor ! PerformTask(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(10000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named DatabaseSimulatorActor that simulates basic database operations. It should handle Insert(record: String), Delete(record: String), and Query(record: String) messages. Maintain an internal Set to store records. Upon Insert, add the record; upon Delete, remove it; and upon Query, respond with RecordFound(record: String) or RecordNotFound(record: String). Demonstrate inserting, deleting, and querying records."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Insert(record: String)\ncase class Delete(record: String)\ncase class Query(record: String)\ncase class RecordFound(record: String)\ncase class RecordNotFound(record: String)\n\n// Define the DatabaseSimulatorActor\nclass DatabaseSimulatorActor extends Actor {\n  var records: Set[String] = Set.empty\n\n  def receive: Receive = {\n    case Insert(record) =>\n      records += record\n      println(s\"DatabaseSimulatorActor: Inserted record '$record'\")\n    case Delete(record) =>\n      if (records.contains(record)) {\n        records -= record\n        println(s\"DatabaseSimulatorActor: Deleted record '$record'\")\n      } else {\n        println(s\"DatabaseSimulatorActor: Record '$record' not found for deletion.\")\n      }\n    case Query(record) =>\n      if (records.contains(record)) {\n        sender() ! RecordFound(record)\n      } else {\n        sender() ! RecordNotFound(record)\n      }\n    case _ =>\n      println(\"DatabaseSimulatorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DatabaseSimulatorApp extends App {\n  val system = ActorSystem(\"DatabaseSimulatorSystem\")\n  val dbSimulator = system.actorOf(Props(new DatabaseSimulatorActor()), \"dbSimulatorActor\")\n\n  // Define a simple responder actor to handle query responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case RecordFound(record) =>\n        println(s\"ResponderActor: Record '$record' found in database.\")\n      case RecordNotFound(record) =>\n        println(s\"ResponderActor: Record '$record' not found in database.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Insert records\n  dbSimulator ! Insert(\"Alice\")\n  dbSimulator ! Insert(\"Bob\")\n\n  // Query existing and non-existing records\n  dbSimulator.tell(Query(\"Alice\"), responder)\n  dbSimulator.tell(Query(\"Charlie\"), responder)\n\n  // Delete a record and query again\n  dbSimulator ! Delete(\"Bob\")\n  dbSimulator.tell(Query(\"Bob\"), responder)\n\n  // Attempt to delete a non-existing record\n  dbSimulator ! Delete(\"Charlie\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TaskSchedulerActor that schedules tasks to be executed after a specified delay. It should handle ScheduleTask(task: String, delay: FiniteDuration) messages by scheduling the task to be executed after the given delay. Upon execution, it should print \"Executed task: <task>\". Demonstrate scheduling multiple tasks with different delays."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport akka.actor.Timers\n\n// Define messages\ncase class ScheduleTask(task: String, delay: FiniteDuration)\n\n// Define the TaskSchedulerActor\nclass TaskSchedulerActor extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case ScheduleTask(task, delay) =>\n      println(s\"TaskSchedulerActor: Scheduling task '$task' to execute in $delay.\")\n      context.system.scheduler.scheduleOnce(delay, self, (\"ExecuteTask\", task))\n    case (\"ExecuteTask\", task: String) =>\n      println(s\"TaskSchedulerActor: Executed task: $task\")\n    case _ =>\n      println(\"TaskSchedulerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TaskSchedulerApp extends App {\n  val system = ActorSystem(\"TaskSchedulerSystem\")\n  val schedulerActor = system.actorOf(Props(new TaskSchedulerActor()), \"schedulerActor\")\n\n  // Schedule multiple tasks with different delays\n  schedulerActor ! ScheduleTask(\"Backup Database\", 2.seconds)\n  schedulerActor ! ScheduleTask(\"Send Report\", 4.seconds)\n  schedulerActor ! ScheduleTask(\"Cleanup Logs\", 6.seconds)\n\n  // Allow some time for task execution before shutdown\n  Thread.sleep(8000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AuthenticationActor that manages user authentication. It should handle Login(username: String, password: String) and Logout(username: String) messages. Maintain an internal Set of authenticated users. Upon successful login (assume any password is valid for simplicity), add the user to the set and respond with LoginSuccess(username: String). Upon logout, remove the user and respond with LogoutSuccess(username: String). Demonstrate logging in and out users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Login(username: String, password: String)\ncase class Logout(username: String)\ncase class LoginSuccess(username: String)\ncase class LogoutSuccess(username: String)\ncase class AuthenticationFailure(username: String, reason: String)\n\n// Define the AuthenticationActor\nclass AuthenticationActor extends Actor {\n  var authenticatedUsers: Set[String] = Set.empty\n\n  def receive: Receive = {\n    case Login(username, password) =>\n      // For simplicity, accept any password\n      if (!authenticatedUsers.contains(username)) {\n        authenticatedUsers += username\n        println(s\"AuthenticationActor: User '$username' logged in.\")\n        sender() ! LoginSuccess(username)\n      } else {\n        sender() ! AuthenticationFailure(username, \"User already logged in.\")\n      }\n\n    case Logout(username) =>\n      if (authenticatedUsers.contains(username)) {\n        authenticatedUsers -= username\n        println(s\"AuthenticationActor: User '$username' logged out.\")\n        sender() ! LogoutSuccess(username)\n      } else {\n        sender() ! AuthenticationFailure(username, \"User not logged in.\")\n      }\n\n    case _ =>\n      println(\"AuthenticationActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject AuthenticationApp extends App {\n  val system = ActorSystem(\"AuthenticationSystem\")\n  val authActor = system.actorOf(Props(new AuthenticationActor()), \"authenticationActor\")\n\n  // Define a simple responder actor to handle authentication responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case LoginSuccess(username) =>\n        println(s\"ResponderActor: User '$username' successfully logged in.\")\n      case LogoutSuccess(username) =>\n        println(s\"ResponderActor: User '$username' successfully logged out.\")\n      case AuthenticationFailure(username, reason) =>\n        println(s\"ResponderActor: Authentication failed for '$username'. Reason: $reason\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Perform login and logout operations\n  authActor.tell(Login(\"Alice\", \"password123\"), responder)\n  authActor.tell(Login(\"Bob\", \"securepass\"), responder)\n  authActor.tell(Login(\"Alice\", \"newpassword\"), responder) // Attempt duplicate login\n  authActor.tell(Logout(\"Alice\"), responder)\n  authActor.tell(Logout(\"Charlie\"), responder) // Attempt logout of non-logged-in user\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TopicPublisherActor that publishes messages to specific topics. It should handle Subscribe(topic: String) and Publish(topic: String, message: String) messages. Maintain a mapping of topics to subscriber actors. Upon publishing, send the message only to subscribers of the specified topic wrapped in TopicMessage(topic: String, message: String). Demonstrate subscribing to different topics and publishing messages accordingly."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(topic: String)\ncase class Publish(topic: String, message: String)\ncase class TopicMessage(topic: String, message: String)\n\n// Define the TopicPublisherActor\nclass TopicPublisherActor extends Actor {\n  var topicSubscribers: Map[String, Set[ActorRef]] = Map.empty.withDefaultValue(Set.empty)\n\n  def receive: Receive = {\n    case Subscribe(topic) =>\n      topicSubscribers += topic -> (topicSubscribers(topic) + sender())\n      println(s\"TopicPublisherActor: ${sender().path.name} subscribed to topic '$topic'\")\n    case Publish(topic, message) =>\n      println(s\"TopicPublisherActor: Publishing message to topic '$topic': $message\")\n      topicSubscribers(topic).foreach(_ ! TopicMessage(topic, message))\n    case _ =>\n      println(\"TopicPublisherActor received unknown message.\")\n  }\n}\n\n// Define the SubscriberActor\nclass SubscriberActor(name: String) extends Actor {\n  def receive: Receive = {\n    case TopicMessage(topic, message) =>\n      println(s\"Subscriber [$name] received on '$topic': $message\")\n    case _ =>\n      println(s\"Subscriber [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TopicPubSubApp extends App {\n  val system = ActorSystem(\"TopicPubSubSystem\")\n  val publisher = system.actorOf(Props(new TopicPublisherActor()), \"publisherActor\")\n\n  // Create subscriber actors\n  val subscriber1 = system.actorOf(Props(new SubscriberActor(\"Subscriber1\")), \"subscriber1\")\n  val subscriber2 = system.actorOf(Props(new SubscriberActor(\"Subscriber2\")), \"subscriber2\")\n  val subscriber3 = system.actorOf(Props(new SubscriberActor(\"Subscriber3\")), \"subscriber3\")\n\n  // Subscribers subscribe to topics\n  subscriber1 ! Subscribe(\"news\")\n  subscriber2 ! Subscribe(\"sports\")\n  subscriber3 ! Subscribe(\"news\")\n  subscriber3 ! Subscribe(\"sports\")\n\n  // Publish messages to topics\n  publisher ! Publish(\"news\", \"Breaking News: Akka Actors are awesome!\")\n  publisher ! Publish(\"sports\", \"Sports Update: Local team wins championship.\")\n  publisher ! Publish(\"entertainment\", \"New movie released this weekend.\") // No subscribers\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TransactionManagerActor that manages simple financial transactions. It should handle Deposit(amount: Double), Withdraw(amount: Double), and GetBalance messages. Maintain an internal balance starting at 0.0. Upon Deposit, add the amount to the balance; upon Withdraw, subtract the amount if sufficient funds exist, otherwise respond with InsufficientFunds(amount: Double). Upon GetBalance, respond with CurrentBalance(balance: Double). Demonstrate performing deposits, withdrawals, and querying the balance."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Deposit(amount: Double)\ncase class Withdraw(amount: Double)\ncase object GetBalance\ncase class CurrentBalance(balance: Double)\ncase class InsufficientFunds(amount: Double)\n\n// Define the TransactionManagerActor\nclass TransactionManagerActor extends Actor {\n  var balance: Double = 0.0\n\n  def receive: Receive = {\n    case Deposit(amount) =>\n      if (amount > 0) {\n        balance += amount\n        println(s\"TransactionManagerActor: Deposited $$${amount}. New balance: $$${balance}.\")\n      } else {\n        println(\"TransactionManagerActor: Deposit amount must be positive.\")\n      }\n    case Withdraw(amount) =>\n      if (amount > 0) {\n        if (balance >= amount) {\n          balance -= amount\n          println(s\"TransactionManagerActor: Withdrew $$${amount}. New balance: $$${balance}.\")\n        } else {\n          println(s\"TransactionManagerActor: Insufficient funds for withdrawal of $$${amount}.\")\n          sender() ! InsufficientFunds(amount)\n        }\n      } else {\n        println(\"TransactionManagerActor: Withdrawal amount must be positive.\")\n      }\n    case GetBalance =>\n      sender() ! CurrentBalance(balance)\n    case _ =>\n      println(\"TransactionManagerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TransactionManagerApp extends App {\n  val system = ActorSystem(\"TransactionManagerSystem\")\n  val transactionManager = system.actorOf(Props(new TransactionManagerActor()), \"transactionManagerActor\")\n\n  // Define a simple responder actor to handle balance queries and errors\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case CurrentBalance(balance) =>\n        println(f\"ResponderActor: Current balance is $$${balance}%.2f\")\n      case InsufficientFunds(amount) =>\n        println(f\"ResponderActor: Cannot withdraw $$${amount}%.2f due to insufficient funds.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Perform transactions\n  transactionManager ! Deposit(500.0)\n  transactionManager ! Withdraw(200.0)\n  transactionManager ! Withdraw(400.0) // Should fail\n  transactionManager.tell(GetBalance, responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named EmailNotificationActor that sends email notifications. It should handle SendEmail(to: String, subject: String, body: String) messages by printing the email details to the console. Implement a UserActor that represents a user and sends SendEmail messages to the EmailNotificationActor. Demonstrate sending emails to multiple users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class SendEmail(to: String, subject: String, body: String)\n\n// Define the EmailNotificationActor\nclass EmailNotificationActor extends Actor {\n  def receive: Receive = {\n    case SendEmail(to, subject, body) =>\n      println(s\"EmailNotificationActor: Sending email to '$to'\")\n      println(s\"Subject: $subject\")\n      println(s\"Body: $body\")\n      println(\"----- Email Sent -----\")\n    case _ =>\n      println(\"EmailNotificationActor received unknown message.\")\n  }\n}\n\n// Define the UserActor\nclass UserActor(name: String, emailNotifier: ActorRef) extends Actor {\n  def receive: Receive = {\n    case (subject: String, body: String) =>\n      val to = s\"$name@example.com\"\n      emailNotifier ! SendEmail(to, subject, body)\n    case _ =>\n      println(s\"UserActor [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EmailNotificationApp extends App {\n  val system = ActorSystem(\"EmailNotificationSystem\")\n  val emailNotifier = system.actorOf(Props(new EmailNotificationActor()), \"emailNotifierActor\")\n\n  // Create user actors\n  val user1 = system.actorOf(Props(new UserActor(\"Alice\", emailNotifier)), \"userAlice\")\n  val user2 = system.actorOf(Props(new UserActor(\"Bob\", emailNotifier)), \"userBob\")\n  val user3 = system.actorOf(Props(new UserActor(\"Charlie\", emailNotifier)), \"userCharlie\")\n\n  // Send emails\n  user1 ! (\"Welcome to our service!\", \"Hello Alice, welcome aboard!\")\n  user2 ! (\"Your account has been updated.\", \"Hi Bob, your account settings have been updated.\")\n  user3 ! (\"Password Reset\", \"Dear Charlie, please reset your password using the link provided.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TaskCompletionListenerActor that listens for TaskCompleted(taskId: Int) messages. Upon receiving such a message, it should print \"Task <taskId> has been completed successfully.\". Implement a WorkerActor that performs tasks and sends TaskCompleted messages to the listener upon completion. Demonstrate task execution and listener notification."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Task(taskId: Int)\ncase class TaskCompleted(taskId: Int)\n\n// Define the TaskCompletionListenerActor\nclass TaskCompletionListenerActor extends Actor {\n  def receive: Receive = {\n    case TaskCompleted(taskId) =>\n      println(s\"TaskCompletionListenerActor: Task $taskId has been completed successfully.\")\n    case _ =>\n      println(\"TaskCompletionListenerActor received unknown message.\")\n  }\n}\n\n// Define the WorkerActor\nclass WorkerActor(listener: ActorRef) extends Actor {\n  def receive: Receive = {\n    case Task(taskId) =>\n      println(s\"WorkerActor: Processing task $taskId.\")\n      // Simulate task processing\n      Thread.sleep(500)\n      println(s\"WorkerActor: Task $taskId completed.\")\n      listener ! TaskCompleted(taskId)\n    case _ =>\n      println(\"WorkerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TaskCompletionApp extends App {\n  val system = ActorSystem(\"TaskCompletionSystem\")\n  \n  val listener = system.actorOf(Props(new TaskCompletionListenerActor()), \"listenerActor\")\n  val worker = system.actorOf(Props(new WorkerActor(listener)), \"workerActor\")\n\n  // Send tasks to the worker\n  worker ! Task(101)\n  worker ! Task(102)\n  worker ! Task(103)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TemperatureMonitorActor that receives temperature readings and alerts if the temperature exceeds a specified threshold. It should handle TemperatureReading(sensorId: String, temperature: Double) messages. If the temperature is above 30.0\u00b0C, respond with Alert(sensorId: String, temperature: Double); otherwise, acknowledge with ReadingAccepted(sensorId: String). Demonstrate monitoring temperatures from multiple sensors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class TemperatureReading(sensorId: String, temperature: Double)\ncase class Alert(sensorId: String, temperature: Double)\ncase class ReadingAccepted(sensorId: String)\n\n// Define the TemperatureMonitorActor\nclass TemperatureMonitorActor extends Actor {\n  val threshold: Double = 30.0\n\n  def receive: Receive = {\n    case TemperatureReading(sensorId, temp) =>\n      if (temp > threshold) {\n        println(s\"TemperatureMonitorActor: Temperature alert from $sensorId: $temp\u00b0C\")\n        sender() ! Alert(sensorId, temp)\n      } else {\n        println(s\"TemperatureMonitorActor: Temperature reading from $sensorId: $temp\u00b0C accepted.\")\n        sender() ! ReadingAccepted(sensorId)\n      }\n    case _ =>\n      println(\"TemperatureMonitorActor received unknown message.\")\n  }\n}\n\n// Define the SensorActor\nclass SensorActor(sensorId: String, monitor: ActorRef) extends Actor {\n  def receive: Receive = {\n    case temp: Double =>\n      println(s\"SensorActor [$sensorId]: Sending temperature reading: $temp\u00b0C\")\n      monitor ! TemperatureReading(sensorId, temp)\n    case _ =>\n      println(s\"SensorActor [$sensorId] received unknown message.\")\n  }\n}\n\n// Define the ResponderActor to handle monitor responses\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Alert(sensorId, temp) =>\n      println(s\"ResponderActor: ALERT! Sensor $sensorId reported high temperature: $temp\u00b0C\")\n    case ReadingAccepted(sensorId) =>\n      println(s\"ResponderActor: Temperature reading from $sensorId accepted.\")\n    case _ =>\n      println(\"ResponderActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TemperatureMonitorApp extends App {\n  val system = ActorSystem(\"TemperatureMonitorSystem\")\n\n  val monitor = system.actorOf(Props(new TemperatureMonitorActor()), \"temperatureMonitorActor\")\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Create sensor actors\n  val sensor1 = system.actorOf(Props(new SensorActor(\"Sensor1\", monitor)), \"sensor1\")\n  val sensor2 = system.actorOf(Props(new SensorActor(\"Sensor2\", monitor)), \"sensor2\")\n  val sensor3 = system.actorOf(Props(new SensorActor(\"Sensor3\", monitor)), \"sensor3\")\n\n  // Send temperature readings\n  sensor1.tell(25.5, responder)\n  sensor2.tell(32.0, responder)\n  sensor3.tell(28.3, responder)\n  sensor1.tell(31.2, responder)\n  sensor2.tell(29.8, responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named OrderProcessorActor that handles online orders. It should handle PlaceOrder(orderId: String, item: String) messages by processing the order and responding with OrderConfirmed(orderId: String) or OrderFailed(orderId: String, reason: String) based on simulated processing logic. Implement a CustomerActor that places orders and handles confirmations or failures. Demonstrate placing multiple orders with varying outcomes."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.util.Random\n\n// Define messages\ncase class PlaceOrder(orderId: String, item: String)\ncase class OrderConfirmed(orderId: String)\ncase class OrderFailed(orderId: String, reason: String)\n\n// Define the OrderProcessorActor\nclass OrderProcessorActor extends Actor {\n  def receive: Receive = {\n    case PlaceOrder(orderId, item) =>\n      println(s\"OrderProcessorActor: Processing order $orderId for item '$item'\")\n      // Simulate order processing with random success/failure\n      if (Random.nextBoolean()) {\n        println(s\"OrderProcessorActor: Order $orderId confirmed.\")\n        sender() ! OrderConfirmed(orderId)\n      } else {\n        println(s\"OrderProcessorActor: Order $orderId failed due to stock unavailability.\")\n        sender() ! OrderFailed(orderId, \"Stock unavailable.\")\n      }\n    case _ =>\n      println(\"OrderProcessorActor received unknown message.\")\n  }\n}\n\n// Define the CustomerActor\nclass CustomerActor(orderProcessor: ActorRef) extends Actor {\n  def receive: Receive = {\n    case PlaceOrder(orderId, item) =>\n      println(s\"CustomerActor: Placing order $orderId for item '$item'\")\n      orderProcessor ! PlaceOrder(orderId, item)\n    case OrderConfirmed(orderId) =>\n      println(s\"CustomerActor: Order $orderId has been confirmed. Thank you!\")\n    case OrderFailed(orderId, reason) =>\n      println(s\"CustomerActor: Order $orderId failed. Reason: $reason\")\n    case _ =>\n      println(\"CustomerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject OrderProcessingApp extends App {\n  val system = ActorSystem(\"OrderProcessingSystem\")\n\n  val orderProcessor = system.actorOf(Props(new OrderProcessorActor()), \"orderProcessorActor\")\n  val customer = system.actorOf(Props(new CustomerActor(orderProcessor)), \"customerActor\")\n\n  // Place multiple orders\n  customer ! PlaceOrder(\"Order001\", \"Laptop\")\n  customer ! PlaceOrder(\"Order002\", \"Smartphone\")\n  customer ! PlaceOrder(\"Order003\", \"Headphones\")\n  customer ! PlaceOrder(\"Order004\", \"Monitor\")\n  customer ! PlaceOrder(\"Order005\", \"Keyboard\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named DataAggregatorActor that collects numerical data from multiple sources and computes the average. It should handle DataPoint(value: Double) messages by adding them to an internal list. Upon receiving a ComputeAverage message, it should calculate and respond with AverageResult(average: Double). Demonstrate collecting data from multiple sources and computing the average."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class DataPoint(value: Double)\ncase object ComputeAverage\ncase class AverageResult(average: Double)\n\n// Define the DataAggregatorActor\nclass DataAggregatorActor extends Actor {\n  var dataPoints: List[Double] = List.empty\n\n  def receive: Receive = {\n    case DataPoint(value) =>\n      dataPoints = value :: dataPoints\n      println(s\"DataAggregatorActor: Received data point $value\")\n    case ComputeAverage =>\n      if (dataPoints.nonEmpty) {\n        val average = dataPoints.sum / dataPoints.size\n        println(f\"DataAggregatorActor: Computed average = $$${average}%.2f\")\n        sender() ! AverageResult(average)\n      } else {\n        println(\"DataAggregatorActor: No data points to compute average.\")\n        sender() ! AverageResult(0.0)\n      }\n    case _ =>\n      println(\"DataAggregatorActor received unknown message.\")\n  }\n}\n\n// Define the DataSourceActor\nclass DataSourceActor(aggregator: ActorRef) extends Actor {\n  def receive: Receive = {\n    case value: Double =>\n      println(s\"DataSourceActor sending data point: $value\")\n      aggregator ! DataPoint(value)\n    case _ =>\n      println(\"DataSourceActor received unknown message.\")\n  }\n}\n\n// Define the ResponderActor to handle average results\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case AverageResult(avg) =>\n      println(f\"ResponderActor: The average of collected data points is $$${avg}%.2f\")\n    case _ =>\n      println(\"ResponderActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DataAggregatorApp extends App {\n  val system = ActorSystem(\"DataAggregatorSystem\")\n\n  val aggregator = system.actorOf(Props(new DataAggregatorActor()), \"aggregatorActor\")\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Create data source actors\n  val source1 = system.actorOf(Props(new DataSourceActor(aggregator)), \"source1\")\n  val source2 = system.actorOf(Props(new DataSourceActor(aggregator)), \"source2\")\n  val source3 = system.actorOf(Props(new DataSourceActor(aggregator)), \"source3\")\n\n  // Send data points from sources\n  source1 ! 10.5\n  source2 ! 20.0\n  source3 ! 30.5\n  source1 ! 25.0\n  source2 ! 15.5\n\n  // Compute average\n  aggregator.tell(ComputeAverage, responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Generate a Scala application using Akka Typed that simulates the Dining Philosophers problem. The application should include:\n\n    Chopstick Actor in the sample package:\n        Handles Take(ref: ActorRef[ChopstickAnswer]) and Put(ref: ActorRef[ChopstickAnswer]) messages.\n        Responds with Taken(chopstick: ActorRef[ChopstickMessage]) when taken successfully or Busy(chopstick: ActorRef[ChopstickMessage]) if already in use.\n        Maintains available and takenBy states to manage chopstick availability.\n\n    Hakker Actor:\n        Handles Think, Eat, and HandleChopstickAnswer(msg: ChopstickAnswer) commands.\n        Transitions through waiting, thinking, hungry, and eating behaviors.\n        Attempts to take left and right chopsticks to eat and handles cases where chopsticks are busy.\n\n    DiningHakkers (Main Application):\n        Initializes five Chopstick actors.\n        Initializes five Hakker actors, each assigned a unique name and two chopsticks (left and right).\n        Starts the simulation by sending the Think message to all hakkers.\n\nEnsure the application uses ConfigFactory for configuration, includes proper logging for tracking states and actions, handles concurrency to avoid deadlocks, and contains comments explaining each component and significant code blocks. Provide the complete Scala code with all necessary imports, package declarations, and actor implementations following best practices."
      },
      {
        "from": "assistant",
        "value": "package sample\n\nimport akka.NotUsed\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.ActorContext\nimport akka.actor.typed.scaladsl.Behaviors\nimport sample.Chopstick.Busy\nimport sample.Chopstick.ChopstickAnswer\nimport sample.Chopstick.ChopstickMessage\nimport sample.Chopstick.Put\nimport sample.Chopstick.Take\nimport sample.Chopstick.Taken\nimport sample.Hakker.Command\n\nimport scala.concurrent.duration._\n\n// Akka adaptation of\n// http://www.dalnefre.com/wp/2010/08/dining-philosophers-in-humus/\n\n/*\n * A Chopstick is an actor, it can be taken, and put back\n */\nobject Chopstick {\n  sealed trait ChopstickMessage\n  final case class Take(ref: ActorRef[ChopstickAnswer]) extends ChopstickMessage\n  final case class Put(ref: ActorRef[ChopstickAnswer]) extends ChopstickMessage\n\n  sealed trait ChopstickAnswer\n  final case class Taken(chopstick: ActorRef[ChopstickMessage])\n      extends ChopstickAnswer\n  final case class Busy(chopstick: ActorRef[ChopstickMessage])\n      extends ChopstickAnswer\n\n  def apply(): Behavior[ChopstickMessage] = available()\n\n  //When a Chopstick is taken by a hakker\n  //It will refuse to be taken by other hakkers\n  //But the owning hakker can put it back\n  private def takenBy(\n    hakker: ActorRef[ChopstickAnswer]\n  ): Behavior[ChopstickMessage] = {\n    Behaviors.receive {\n      case (ctx, Take(otherHakker)) =>\n        otherHakker ! Busy(ctx.self)\n        Behaviors.same\n      case (_, Put(`hakker`)) =>\n        available()\n      case _ =>\n        // here and below it's left to be explicit about partial definition,\n        // but can be omitted when Behaviors.receiveMessagePartial is in use\n        Behaviors.unhandled\n    }\n  }\n\n  //When a Chopstick is available, it can be taken by a hakker\n  private def available(): Behavior[ChopstickMessage] = {\n    Behaviors.receivePartial {\n      case (ctx, Take(hakker)) =>\n        hakker ! Taken(ctx.self)\n        takenBy(hakker)\n    }\n  }\n}\n\n/*\n * A hakker is an awesome dude or dudette who either thinks about hacking or has to eat ;-)\n */\nobject Hakker {\n  sealed trait Command\n  case object Think extends Command\n  case object Eat extends Command\n  final case class HandleChopstickAnswer(msg: ChopstickAnswer)\n      extends Command\n\n  def apply(name: String, left: ActorRef[ChopstickMessage], right: ActorRef[ChopstickMessage]): Behavior[Command] =\n    Behaviors.setup { ctx =>\n      new Hakker(ctx, name, left, right).waiting\n    }\n}\n\nclass Hakker(ctx: ActorContext[Command],\n             name: String,\n             left: ActorRef[ChopstickMessage],\n             right: ActorRef[ChopstickMessage]) {\n\n  import Hakker._\n\n  private val adapter = ctx.messageAdapter(HandleChopstickAnswer)\n\n  val waiting: Behavior[Command] =\n    Behaviors.receiveMessagePartial {\n      case Think =>\n        ctx.log.info(\"{} starts to think\", name)\n        startThinking(ctx, 5.seconds)\n    }\n\n  //When a hakker is thinking it can become hungry\n  //and try to pick up its chopsticks and eat\n  private val thinking: Behavior[Command] = {\n    Behaviors.receiveMessagePartial {\n      case Eat =>\n        left ! Chopstick.Take(adapter)\n        right ! Chopstick.Take(adapter)\n        hungry\n    }\n  }\n\n  //When a hakker is hungry it tries to pick up its chopsticks and eat\n  //When it picks one up, it goes into wait for the other\n  //If the hakkers first attempt at grabbing a chopstick fails,\n  //it starts to wait for the response of the other grab\n  private lazy val hungry: Behavior[Command] =\n    Behaviors.receiveMessagePartial {\n      case HandleChopstickAnswer(Taken(`left`)) =>\n        waitForOtherChopstick(chopstickToWaitFor = right, takenChopstick = left)\n\n      case HandleChopstickAnswer(Taken(`right`)) =>\n        waitForOtherChopstick(chopstickToWaitFor = left, takenChopstick = right)\n\n      case HandleChopstickAnswer(Busy(_)) =>\n        firstChopstickDenied\n    }\n\n  //When a hakker is waiting for the last chopstick it can either obtain it\n  //and start eating, or the other chopstick was busy, and the hakker goes\n  //back to think about how he should obtain his chopsticks :-)\n  private def waitForOtherChopstick(\n    chopstickToWaitFor: ActorRef[ChopstickMessage],\n    takenChopstick: ActorRef[ChopstickMessage]\n  ): Behavior[Command] = {\n    Behaviors.receiveMessagePartial {\n      case HandleChopstickAnswer(Taken(`chopstickToWaitFor`)) =>\n        ctx.log.info(\n          \"{} has picked up {} and {} and starts to eat\",\n          name,\n          left.path.name,\n          right.path.name\n        )\n        startEating(ctx, 5.seconds)\n\n      case HandleChopstickAnswer(Busy(`chopstickToWaitFor`)) =>\n        takenChopstick ! Put(adapter)\n        startThinking(ctx, 10.milliseconds)\n    }\n  }\n\n  //When a hakker is eating, he can decide to start to think,\n  //then he puts down his chopsticks and starts to think\n  private lazy val eating: Behavior[Command] = {\n    Behaviors.receiveMessagePartial {\n      case Think =>\n        ctx.log.info(\"{} puts down his chopsticks and starts to think\", name)\n        left ! Put(adapter)\n        right ! Put(adapter)\n        startThinking(ctx, 5.seconds)\n    }\n  }\n\n  //When the results of the other grab comes back,\n  //he needs to put it back if he got the other one.\n  //Then go back and think and try to grab the chopsticks again\n  private lazy val firstChopstickDenied: Behavior[Command] = {\n    Behaviors.receiveMessagePartial {\n      case HandleChopstickAnswer(Taken(chopstick)) =>\n        chopstick ! Put(adapter)\n        startThinking(ctx, 10.milliseconds)\n      case HandleChopstickAnswer(Busy(_)) =>\n        startThinking(ctx, 10.milliseconds)\n    }\n  }\n\n  private def startThinking(ctx: ActorContext[Command],\n                            duration: FiniteDuration) = {\n    Behaviors.withTimers[Command] { timers =>\n      timers.startSingleTimer(Eat, Eat, duration)\n      thinking\n    }\n  }\n\n  private def startEating(ctx: ActorContext[Command],\n                          duration: FiniteDuration) = {\n    Behaviors.withTimers[Command] { timers =>\n      timers.startSingleTimer(Think, Think, duration)\n      eating\n    }\n  }\n}\n\nobject DiningHakkers {\n\n  def apply(): Behavior[NotUsed] = Behaviors.setup { context =>\n    //Create 5 chopsticks\n    val chopsticks = for (i <- 1 to 5)\n      yield context.spawn(Chopstick(), \"Chopstick\" + i)\n\n    //Create 5 awesome hakkers and assign them their left and right chopstick\n    val hakkers = for {\n      (name, i) <- List(\"Ghosh\", \"Boner\", \"Klang\", \"Krasser\", \"Manie\").zipWithIndex\n    } yield\n      context.spawn(Hakker(name, chopsticks(i), chopsticks((i + 1) % 5)), name)\n\n    //Signal all hakkers that they should start thinking, and watch the show\n    hakkers.foreach(_ ! Hakker.Think)\n\n    Behaviors.empty\n  }\n\n  def main(args: Array[String]): Unit = {\n    ActorSystem(DiningHakkers(), \"DiningHakkers\")\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Write a Scala application using Akka Typed that sets up a simple Akka Cluster. The application should include an `App` object with a `main` method that initializes the Actor System on specified ports and spawns a `ClusterListener` actor to monitor cluster events."
      },
      {
        "from": "assistant",
        "value": "package sample.cluster.simple\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport com.typesafe.config.ConfigFactory\n\nobject App {\n\n  object RootBehavior {\n    def apply(): Behavior[Nothing] = Behaviors.setup[Nothing] { context =>\n      // Create an actor that handles cluster domain events\n      context.spawn(ClusterListener(), \"ClusterListener\")\n\n      Behaviors.empty\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val ports =\n      if (args.isEmpty)\n        Seq(25251, 25252, 0)\n      else\n        args.toSeq.map(_.toInt)\n    ports.foreach(startup)\n  }\n\n  def startup(port: Int): Unit = {\n    // Override the configuration of the port\n    val config = ConfigFactory.parseString(\n      s\"\"\"\n      akka.remote.artery.canonical.port=$port\n      \"\"\"\n    ).withFallback(ConfigFactory.load())\n\n    // Create an Akka system\n    ActorSystem[Nothing](RootBehavior(), \"ClusterSystem\", config)\n  }\n\n  object ClusterListener {\n    import akka.actor.typed.ActorRef\n    import akka.cluster.ClusterEvent\n    import akka.cluster.ClusterEvent.MemberEvent\n    import akka.cluster.ClusterEvent.ReachabilityEvent\n    import akka.actor.typed.scaladsl.LoggerOps\n\n    sealed trait Event\n    final case class WrappedMemberEvent(event: MemberEvent) extends Event\n    final case class WrappedReachabilityEvent(event: ReachabilityEvent) extends Event\n\n    def apply(): Behavior[Event] = {\n      Behaviors.setup { context =>\n        val memberEventAdapter: ActorRef[MemberEvent] =\n          context.messageAdapter(WrappedMemberEvent)\n        val reachabilityEventAdapter: ActorRef[ReachabilityEvent] =\n          context.messageAdapter(WrappedReachabilityEvent)\n\n        val cluster = akka.cluster.typed.Cluster(context.system)\n        cluster.subscriptions ! akka.cluster.typed.Subscribe(memberEventAdapter, classOf[ClusterEvent.MemberEvent])\n        cluster.subscriptions ! akka.cluster.typed.Subscribe(reachabilityEventAdapter, classOf[ClusterEvent.ReachabilityEvent])\n\n        Behaviors.receiveMessage {\n          case WrappedMemberEvent(memberEvent) =>\n            context.log.info2(\"MemberEvent: {}\", memberEvent)\n            Behaviors.same\n          case WrappedReachabilityEvent(reachabilityEvent) =>\n            context.log.info2(\"ReachabilityEvent: {}\", reachabilityEvent)\n            Behaviors.same\n        }\n      }\n    }\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TrafficLightActor that cycles between Red, Green, and Yellow states with timed transitions. Use context.become to manage state transitions and log the current state to the console."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\n\nobject TrafficLightActor {\n  case object Change\n}\n\nclass TrafficLightActor extends Actor {\n  import TrafficLightActor._\n  import context.dispatcher\n\n  def red: Receive = {\n    case Change =>\n      println(\"Transitioning from RED to GREEN\")\n      context.become(green)\n      context.system.scheduler.scheduleOnce(5.seconds, self, Change)\n  }\n\n  def green: Receive = {\n    case Change =>\n      println(\"Transitioning from GREEN to YELLOW\")\n      context.become(yellow)\n      context.system.scheduler.scheduleOnce(2.seconds, self, Change)\n  }\n\n  def yellow: Receive = {\n    case Change =>\n      println(\"Transitioning from YELLOW to RED\")\n      context.become(red)\n      context.system.scheduler.scheduleOnce(3.seconds, self, Change)\n  }\n\n  override def preStart(): Unit = {\n    println(\"Starting Traffic Light in RED state\")\n    context.system.scheduler.scheduleOnce(3.seconds, self, Change)\n  }\n\n  def receive: Receive = red\n}\n\nobject TrafficLightApp extends App {\n  val system = ActorSystem(\"TrafficLightSystem\")\n  val trafficLight = system.actorOf(Props[TrafficLightActor](), \"trafficLight\")\n  Thread.sleep(20000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Cluster Singleton in Scala using Akka Typed. The singleton actor should manage configuration updates by handling UpdateConfig and GetConfig commands. Provide code that initializes the cluster system and spawns the singleton actor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.typed.{ActorSystem, Behavior}\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.cluster.typed.{ClusterSingleton, SingletonActor}\nimport com.typesafe.config.ConfigFactory\n\nobject ConfigManager {\n  sealed trait Command\n  final case class UpdateConfig(config: String) extends Command\n  case object GetConfig extends Command\n\n  def apply(): Behavior[Command] = Behaviors.receive { (context, message) =>\n    message match {\n      case UpdateConfig(config) =>\n        context.log.info(s\"Config updated to: $config\")\n        Behaviors.same\n      case GetConfig =>\n        context.log.info(\"Returning current config\")\n        Behaviors.same\n    }\n  }\n}\n\nobject ClusterSingletonApp extends App {\n  val config = ConfigFactory.load()\n  val system: ActorSystem[Nothing] = ActorSystem(Behaviors.empty, \"ClusterSystem\", config)\n\n  val singletonManager = ClusterSingleton(system)\n  val configManagerProxy = singletonManager.init(\n    SingletonActor(\n      Behaviors.supervise(ConfigManager()).onFailure[Exception](\n        akka.actor.typed.SupervisorStrategy.restart\n      ),\n      \"ConfigManager\"\n    )\n  )\n\n  // Interact with the singleton\n  configManagerProxy ! ConfigManager.UpdateConfig(\"NewConfigValue\")\n\n  Thread.sleep(5000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named StreamProcessingActor that integrates with Akka Streams. The actor should materialize a stream of numbers from 1 to 10 and print each number to the console when it receives a \"start\" message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.stream.ActorMaterializer\nimport akka.stream.scaladsl.{Source, Sink}\n\nclass StreamProcessingActor extends Actor {\n  implicit val materializer: ActorMaterializer = ActorMaterializer()(context.system)\n  def receive: Receive = {\n    case \"start\" =>\n      Source(1 to 10).runWith(Sink.foreach(n => println(s\"StreamProcessingActor received: $n\")))\n  }\n}\n\nobject StreamProcessingApp extends App {\n  val system = ActorSystem(\"StreamProcessingSystem\")\n  val streamActor = system.actorOf(Props[StreamProcessingActor](), \"streamActor\")\n  streamActor ! \"start\"\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named ChatRoomActor that simulates a chat room where users can join, leave, and send messages. Each user is represented as a separate actor that registers with the ChatRoomActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Messages for ChatRoom communication\ncase class Join(userRef: ActorRef, username: String)\ncase class Leave(username: String)\ncase class ChatMessage(username: String, message: String)\ncase class BroadcastMessage(content: String)\n\n// Actor that implements a simple chat room\nclass ChatRoomActor extends Actor {\n  // Map from username to the corresponding ActorRef for the user\n  var participants: Map[String, ActorRef] = Map.empty\n\n  def receive: Receive = {\n    case Join(userRef, username) =>\n      participants += (username -> userRef)\n      println(s\"ChatRoom: $username has joined the chat.\")\n      broadcast(s\"$username has entered the chat.\")\n\n    case Leave(username) =>\n      participants.get(username) match {\n        case Some(_) =>\n          participants -= username\n          println(s\"ChatRoom: $username has left the chat.\")\n          broadcast(s\"$username has left the chat.\")\n        case None =>\n          println(s\"ChatRoom: Unable to remove $username, user not found.\")\n      }\n\n    case ChatMessage(username, message) =>\n      val chatLine = s\"[$username]: $message\"\n      broadcast(chatLine)\n\n    case _ =>\n      println(\"ChatRoomActor: Received unknown message.\")\n  }\n\n  private def broadcast(msg: String): Unit = {\n    participants.values.foreach(_ ! BroadcastMessage(msg))\n  }\n}\n\n// Actor representing an individual user\nclass ChatUserActor(username: String) extends Actor {\n  def receive: Receive = {\n    case BroadcastMessage(content) =>\n      println(s\"($username) Received broadcast message: $content\")\n    case _ =>\n      println(s\"($username) Received an unknown message.\")\n  }\n}\n\nobject ChatRoomApp extends App {\n  val system = ActorSystem(\"ChatRoomSystem\")\n  val chatRoom = system.actorOf(Props[ChatRoomActor](), \"chatRoomActor\")\n\n  // Create two users\n  val userAlice = system.actorOf(Props(new ChatUserActor(\"Alice\")), \"aliceActor\")\n  val userBob   = system.actorOf(Props(new ChatUserActor(\"Bob\")), \"bobActor\")\n\n  // Users join the chat room\n  chatRoom ! Join(userAlice, \"Alice\")\n  chatRoom ! Join(userBob, \"Bob\")\n\n  // Alice sends a message\n  chatRoom ! ChatMessage(\"Alice\", \"Hello everyone!\")\n  // Bob replies\n  chatRoom ! ChatMessage(\"Bob\", \"Hi Alice!\")\n\n  // Bob leaves the chat\n  chatRoom ! Leave(\"Bob\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named RateLimitingActor that processes only one message at a time, queueing any excess messages. The actor should become busy while processing and then free up after a short period."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.collection.mutable\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase class RequestMsg(content: String)\ncase object ProcessNext\n\nclass RateLimitingActor extends Actor {\n  private val queue = mutable.Queue[RequestMsg]()\n  private var isProcessing = false\n  private var schedule: Option[Cancellable] = None\n\n  def receive: Receive = {\n    case req: RequestMsg =>\n      queue.enqueue(req)\n      tryProcessNext()\n\n    case ProcessNext =>\n      if (queue.nonEmpty) {\n        val msg = queue.dequeue()\n        println(s\"RateLimitingActor: Processing -> ${msg.content}\")\n        isProcessing = true\n        // Simulate processing time: after 1 second, the actor becomes free\n        schedule = Some(context.system.scheduler.scheduleOnce(1.second, self, \"done\"))\n      } else {\n        isProcessing = false\n      }\n\n    case \"done\" =>\n      isProcessing = false\n      tryProcessNext()\n\n    case _ =>\n      println(\"RateLimitingActor: Received unknown message.\")\n  }\n\n  private def tryProcessNext(): Unit = {\n    if (!isProcessing && queue.nonEmpty) {\n      self ! ProcessNext\n    }\n  }\n\n  override def postStop(): Unit = {\n    schedule.foreach(_.cancel())\n    super.postStop()\n  }\n}\n\nobject RateLimitingApp extends App {\n  val system = ActorSystem(\"RateLimitingSystem\")\n  val limiter = system.actorOf(Props[RateLimitingActor](), \"rateLimitingActor\")\n\n  // Send multiple messages in quick succession\n  for (i <- 1 to 5) {\n    limiter ! RequestMsg(s\"request-$i\")\n  }\n\n  Thread.sleep(7000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TrafficLightFSMActor that behaves like a traffic light, transitioning between Red, Yellow, and Green states at specific intervals using internal messages for state changes."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nsealed trait TrafficLightState\ncase object Red extends TrafficLightState\ncase object Yellow extends TrafficLightState\ncase object Green extends TrafficLightState\n\ncase object Switch // Internal message to change state\n\nclass TrafficLightFSMActor extends Actor {\n  var currentState: TrafficLightState = Red\n  var schedule: Option[Cancellable] = None\n\n  override def preStart(): Unit = {\n    // On startup, set the initial timer\n    scheduleNextSwitch(2.seconds)\n  }\n\n  def receive: Receive = {\n    case Switch =>\n      currentState match {\n        case Red =>\n          currentState = Green\n          println(\"Traffic Light: Switching from RED to GREEN.\")\n          scheduleNextSwitch(3.seconds)\n        case Green =>\n          currentState = Yellow\n          println(\"Traffic Light: Switching from GREEN to YELLOW.\")\n          scheduleNextSwitch(1.second)\n        case Yellow =>\n          currentState = Red\n          println(\"Traffic Light: Switching from YELLOW to RED.\")\n          scheduleNextSwitch(2.seconds)\n      }\n\n    case _ =>\n      println(\"TrafficLightFSMActor: Received unknown message.\")\n  }\n\n  private def scheduleNextSwitch(after: FiniteDuration): Unit = {\n    schedule.foreach(_.cancel())\n    schedule = Some(context.system.scheduler.scheduleOnce(after, self, Switch))\n  }\n\n  override def postStop(): Unit = {\n    schedule.foreach(_.cancel())\n    super.postStop()\n  }\n}\n\nobject TrafficLightApp extends App {\n  val system = ActorSystem(\"TrafficLightSystem\")\n  val trafficLight = system.actorOf(Props[TrafficLightFSMActor](), \"trafficLightActor\")\n\n  Thread.sleep(10000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named AggregationActor that sends WorkRequest messages to multiple WorkerActors and waits to receive all corresponding WorkResult messages, then aggregates them and returns a combined result to the original sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase class WorkRequest(data: String)\ncase class WorkResult(result: String)\n\n// Worker actor that performs a simple operation\nclass WorkerActor(workerId: Int) extends Actor {\n  def receive: Receive = {\n    case WorkRequest(data) =>\n      val processed = s\"Worker-$workerId processed: $data\"\n      println(processed)\n      sender() ! WorkResult(processed)\n    case _ =>\n      println(s\"Worker-$workerId: Received unknown message.\")\n  }\n}\n\n// Actor that aggregates results from workers\nclass AggregationActor(workers: Seq[ActorRef]) extends Actor {\n  var pendingResults: List[String] = Nil\n  var awaiting: Int = 0\n  var originalSender: Option[ActorRef] = None\n\n  def receive: Receive = {\n    case req: WorkRequest =>\n      println(\"AggregationActor: Sending WorkRequest to all workers.\")\n      awaiting = workers.size\n      pendingResults = Nil\n      originalSender = Some(sender())\n\n      workers.foreach(_ ! req)\n\n    case WorkResult(res) =>\n      pendingResults = res :: pendingResults\n      awaiting -= 1\n      if (awaiting == 0) {\n        val aggregated = pendingResults.reverse.mkString(\" | \")\n        println(s\"AggregationActor: Collected all results:\\n$aggregated\")\n        originalSender.foreach(_ ! WorkResult(s\"Aggregated: $aggregated\"))\n      }\n\n    case _ =>\n      println(\"AggregationActor: Received unknown message.\")\n  }\n}\n\nobject AggregationApp extends App {\n  val system = ActorSystem(\"AggregationSystem\")\n\n  val workers = (1 to 3).map(i => system.actorOf(Props(new WorkerActor(i)), s\"worker-$i\"))\n  val aggregator = system.actorOf(Props(new AggregationActor(workers)), \"aggregatorActor\")\n\n  // Send a WorkRequest through aggregator to all workers\n  aggregator ! WorkRequest(\"Perform calculation\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Show an example in Akka Typed using TimerScheduler by defining a ReminderActor that sends periodic reminder messages, along with a test application that issues Start and Stop commands."
      },
      {
        "from": "assistant",
        "value": "package sample\n\nimport akka.actor.typed.scaladsl.{Behaviors, TimerScheduler, ActorContext}\nimport akka.actor.typed.{ActorRef, ActorSystem, Behavior}\nimport scala.concurrent.duration._\n\nobject ReminderActor {\n  sealed trait Command\n  case object Start extends Command\n  case object Reminder extends Command\n  case object Stop extends Command\n\n  def apply(): Behavior[Command] = Behaviors.withTimers { timers =>\n    Behaviors.setup { context =>\n      new ReminderBehavior(timers, context).idle\n    }\n  }\n}\n\nclass ReminderBehavior(timers: TimerScheduler[ReminderActor.Command],\n                       context: ActorContext[ReminderActor.Command]) {\n  import ReminderActor._\n\n  val Interval: FiniteDuration = 2.seconds\n\n  // Idle state: waiting for the Start command\n  def idle: Behavior[Command] = Behaviors.receiveMessage {\n    case Start =>\n      context.log.info(\"ReminderActor: Starting reminders every 2 seconds...\")\n      timers.startTimerWithFixedDelay(Reminder, Reminder, Interval)\n      active\n    case _ =>\n      Behaviors.same\n  }\n\n  // Active state: sending periodic reminders\n  def active: Behavior[Command] = Behaviors.receiveMessage {\n    case Reminder =>\n      context.log.info(\"Here is your periodic reminder!\")\n      Behaviors.same\n    case Stop =>\n      context.log.info(\"ReminderActor: Received Stop, stopping reminders and returning to idle.\")\n      timers.cancel(Reminder)\n      idle\n    case _ =>\n      Behaviors.same\n  }\n}\n\nobject ReminderApp extends App {\n  // Create the typed actor system\n  val system: ActorSystem[ReminderActor.Command] =\n    ActorSystem(ReminderActor(), \"ReminderSystem\")\n\n  // Start the reminders\n  system ! ReminderActor.Start\n\n  // After a few seconds, stop the reminders\n  Thread.sleep(7000)\n  system ! ReminderActor.Stop\n\n  // Wait a couple more seconds then terminate\n  Thread.sleep(2000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named StockMonitorActor that receives StockPrice messages and sends an Alert to a NotificationActor if the price exceeds a threshold."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Messages for stock monitoring\ncase class StockPrice(ticker: String, price: Double)\ncase class Alert(ticker: String, price: Double)\n\n// Notification actor that logs alerts\nclass NotificationActor extends Actor {\n  def receive: Receive = {\n    case Alert(ticker, price) =>\n      println(s\"ALERT: $ticker has reached a price of $$ $price\")\n    case _ => println(\"NotificationActor: Received unknown message.\")\n  }\n}\n\n// StockMonitorActor checks incoming stock prices\nclass StockMonitorActor(notificationActor: ActorRef) extends Actor {\n  val threshold: Double = 100.0\n  def receive: Receive = {\n    case StockPrice(ticker, price) =>\n      println(s\"StockMonitorActor: Received $$ $price for $ticker\")\n      if (price > threshold) {\n        notificationActor ! Alert(ticker, price)\n      }\n    case _ => println(\"StockMonitorActor: Received unknown message.\")\n  }\n}\n\nobject StockMonitorApp extends App {\n  val system = ActorSystem(\"StockMonitorSystem\")\n  val notification = system.actorOf(Props[NotificationActor](), \"notificationActor\")\n  val monitor = system.actorOf(Props(new StockMonitorActor(notification)), \"stockMonitorActor\")\n\n  monitor ! StockPrice(\"AAPL\", 95.0)\n  monitor ! StockPrice(\"GOOG\", 150.0)\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named VendingMachineActor that simulates a vending machine. It should accept InsertCoin and SelectItem messages, dispense items if sufficient funds are available, and return change if necessary."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Messages for vending machine operations\ncase class InsertCoin(amount: Double)\ncase class SelectItem(item: String)\ncase class DispenseItem(item: String)\ncase class ReturnChange(amount: Double)\n\nclass VendingMachineActor extends Actor {\n  var balance: Double = 0.0\n  // Inventory: item -> (price, stock)\n  var inventory: Map[String, (Double, Int)] = Map(\n    \"Soda\" -> (1.5, 5),\n    \"Chips\" -> (2.0, 3)\n  )\n\n  def receive: Receive = {\n    case InsertCoin(amount) =>\n      balance += amount\n      println(s\"VendingMachine: Inserted $$ $amount, current balance is $$ $balance\")\n\n    case SelectItem(item) =>\n      inventory.get(item) match {\n        case Some((price, stock)) if stock > 0 =>\n          if (balance >= price) {\n            balance -= price\n            inventory += (item -> (price, stock - 1))\n            println(s\"VendingMachine: Dispensing $item\")\n            sender() ! DispenseItem(item)\n            if (balance > 0) {\n              println(s\"VendingMachine: Returning change $$ $balance\")\n              sender() ! ReturnChange(balance)\n              balance = 0.0\n            }\n          } else {\n            println(s\"VendingMachine: Insufficient funds for $item\")\n          }\n        case Some((_, stock)) if stock == 0 =>\n          println(s\"VendingMachine: $item is out of stock\")\n        case None =>\n          println(s\"VendingMachine: Unknown item $item\")\n      }\n\n    case _ => println(\"VendingMachine: Received unknown message\")\n  }\n}\n\nobject VendingMachineApp extends App {\n  val system = ActorSystem(\"VendingMachineSystem\")\n  val vendingMachine = system.actorOf(Props[VendingMachineActor](), \"vendingMachineActor\")\n\n  vendingMachine ! InsertCoin(2.0)\n  vendingMachine ! SelectItem(\"Soda\")\n  vendingMachine ! InsertCoin(1.0)\n  vendingMachine ! SelectItem(\"Chips\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named StashingActor that uses the stash to buffer incoming messages until an Initialize message is received. After initialization, process all stashed messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Messages for stashing\ncase object Initialize\ncase class DataMessage(data: String)\n\nclass StashingActor extends Actor with Stash {\n  def receive: Receive = uninitialized\n\n  def uninitialized: Receive = {\n    case Initialize =>\n      println(\"StashingActor: Initialized. Unstashing messages.\")\n      unstashAll()\n      context.become(initialized)\n    case msg =>\n      println(\"StashingActor: Stashing message until initialization.\")\n      stash()\n  }\n\n  def initialized: Receive = {\n    case DataMessage(data) =>\n      println(s\"StashingActor: Processing data -> $data\")\n    case _ => println(\"StashingActor: Received unknown message in initialized state.\")\n  }\n}\n\nobject StashingActorApp extends App {\n  val system = ActorSystem(\"StashingActorSystem\")\n  val stasher = system.actorOf(Props[StashingActor](), \"stashingActor\")\n\n  stasher ! DataMessage(\"Message 1\")\n  stasher ! DataMessage(\"Message 2\")\n  stasher ! Initialize\n  stasher ! DataMessage(\"Message 3\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named SupervisionDemoActor that spawns a child actor which fails when receiving a specific message. The parent actor should use a custom supervision strategy to restart the child actor upon failure."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy}\nimport akka.actor.SupervisorStrategy.{Restart}\nimport scala.concurrent.duration._\n\ncase object Fail\n\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case Fail =>\n      println(\"ChildActor: Failing as requested.\")\n      throw new RuntimeException(\"Child failure\")\n    case msg => println(s\"ChildActor: Received message $msg\")\n  }\n}\n\nclass SupervisionDemoActor extends Actor {\n  override val supervisorStrategy = OneForOneStrategy(maxNrOfRetries = 3, withinTimeRange = 1.minute) {\n    case _: RuntimeException =>\n      println(\"SupervisionDemoActor: Restarting child actor due to failure.\")\n      Restart\n  }\n\n  val child = context.actorOf(Props[ChildActor](), \"childActor\")\n\n  def receive: Receive = {\n    case msg => child.forward(msg)\n  }\n}\n\nobject SupervisionDemoApp extends App {\n  val system = ActorSystem(\"SupervisionSystem\")\n  val supervisor = system.actorOf(Props[SupervisionDemoActor](), \"supervisorActor\")\n\n  supervisor ! \"Hello\"\n  supervisor ! Fail\n  supervisor ! \"After failure\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CarActor that simulates a car's behavior. It should handle commands such as Accelerate, Brake, and Park, and use context.become to change its behavior based on whether the car is moving or parked."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Car commands\nsealed trait CarCommand\ncase object Accelerate extends CarCommand\ncase object Brake extends CarCommand\ncase object Park extends CarCommand\n\nclass CarActor extends Actor {\n  def parked: Receive = {\n    case Accelerate =>\n      println(\"CarActor: Starting to accelerate from parked state.\")\n      context.become(moving(10))\n    case _ => println(\"CarActor: In parked state, only Accelerate is valid.\")\n  }\n\n  def moving(speed: Int): Receive = {\n    case Accelerate =>\n      val newSpeed = speed + 10\n      println(s\"CarActor: Accelerating to $newSpeed.\")\n      context.become(moving(newSpeed))\n    case Brake =>\n      val newSpeed = math.max(speed - 10, 0)\n      println(s\"CarActor: Braking to $newSpeed.\")\n      if (newSpeed == 0) context.become(parked) else context.become(moving(newSpeed))\n    case Park =>\n      println(\"CarActor: Parking the car.\")\n      context.become(parked)\n    case _ => println(\"CarActor: Received unknown command.\")\n  }\n\n  def receive: Receive = parked\n}\n\nobject CarActorApp extends App {\n  val system = ActorSystem(\"CarSystem\")\n  val car = system.actorOf(Props[CarActor](), \"carActor\")\n\n  car ! Accelerate\n  car ! Accelerate\n  car ! Brake\n  car ! Park\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Develop an Akka Actor in Scala named OrderQueueActor that queues incoming orders (PlaceOrder) and processes them one at a time. It should also handle cancellation of orders (CancelOrder)."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.Queue\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase class PlaceOrder(orderId: String, details: String)\ncase class CancelOrder(orderId: String)\ncase object ProcessOrder\n\nclass OrderQueueActor extends Actor {\n  val orderQueue: Queue[(String, String)] = Queue.empty\n  var processing: Boolean = false\n\n  def receive: Receive = {\n    case PlaceOrder(id, details) =>\n      orderQueue.enqueue((id, details))\n      println(s\"OrderQueueActor: Order $id placed.\")\n      tryProcessNext()\n\n    case CancelOrder(id) =>\n      val initialSize = orderQueue.size\n      orderQueue.dequeueAll(_._1 == id)\n      if (orderQueue.size < initialSize) println(s\"OrderQueueActor: Order $id cancelled.\")\n      else println(s\"OrderQueueActor: Order $id not found.\")\n\n    case ProcessOrder =>\n      if (orderQueue.nonEmpty) {\n        val (id, details) = orderQueue.dequeue()\n        println(s\"OrderQueueActor: Processing order $id with details: $details\")\n        processing = true\n        context.system.scheduler.scheduleOnce(500.milliseconds, self, \"orderDone\")\n      } else {\n        processing = false\n      }\n\n    case \"orderDone\" =>\n      println(\"OrderQueueActor: Finished processing an order.\")\n      processing = false\n      tryProcessNext()\n\n    case _ => println(\"OrderQueueActor: Received unknown message.\")\n  }\n\n  private def tryProcessNext(): Unit = {\n    if (!processing && orderQueue.nonEmpty) {\n      self ! ProcessOrder\n    }\n  }\n}\n\nobject OrderQueueApp extends App {\n  val system = ActorSystem(\"OrderQueueSystem\")\n  val orderQueue = system.actorOf(Props[OrderQueueActor](), \"orderQueueActor\")\n\n  orderQueue ! PlaceOrder(\"Order1\", \"Item A\")\n  orderQueue ! PlaceOrder(\"Order2\", \"Item B\")\n  orderQueue ! CancelOrder(\"Order1\")\n  orderQueue ! PlaceOrder(\"Order3\", \"Item C\")\n\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SystemHealthMonitor that periodically checks the health of system components and sends HealthStatus messages to a LoggerActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase object CheckHealth\ncase class HealthStatus(component: String, status: String)\n\nclass SystemHealthMonitor(logger: ActorRef) extends Actor {\n  val scheduler = context.system.scheduler.scheduleWithFixedDelay(0.seconds, 3.seconds, self, CheckHealth)\n\n  def receive: Receive = {\n    case CheckHealth =>\n      val components = List(\"Database\", \"WebServer\")\n      components.foreach { comp =>\n        val status = if (scala.util.Random.nextBoolean()) \"Healthy\" else \"Unhealthy\"\n        println(s\"SystemHealthMonitor: $comp is $status.\")\n        logger ! HealthStatus(comp, status)\n      }\n    case _ => println(\"SystemHealthMonitor: Received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    scheduler.cancel()\n    super.postStop()\n  }\n}\n\nclass LoggerActor extends Actor {\n  def receive: Receive = {\n    case HealthStatus(comp, status) => println(s\"Logger: $comp status: $status\")\n    case _ => println(\"Logger: Received unknown message.\")\n  }\n}\n\nobject SystemHealthMonitorApp extends App {\n  val system = ActorSystem(\"HealthMonitorSystem\")\n  val logger = system.actorOf(Props[LoggerActor](), \"loggerActor\")\n  val monitor = system.actorOf(Props(new SystemHealthMonitor(logger)), \"healthMonitorActor\")\n\n  Thread.sleep(10000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named RouterDemoActor that uses a RoundRobinPool router to distribute Job messages to a pool of Worker actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\ncase class Job(data: String)\n\nclass Worker extends Actor {\n  def receive: Receive = {\n    case Job(data) => println(s\"${self.path.name} processing job: $data\")\n    case _ => println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\nobject RouterDemoApp extends App {\n  val system = ActorSystem(\"RouterDemoSystem\")\n  \n  // Create a router with 5 workers using RoundRobinPool\n  val router = system.actorOf(RoundRobinPool(5).props(Props[Worker]()), \"workerRouter\")\n  \n  for (i <- 1 to 10) {\n    router ! Job(s\"Job-$i\")\n  }\n  \n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named BankAccountActor that simulates a bank account. It should handle Deposit, Withdraw, and GetBalance messages, ensuring that withdrawals do not exceed the available balance."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Deposit(amount: Double)\ncase class Withdraw(amount: Double)\ncase object GetBalance\ncase class CurrentBalance(balance: Double)\ncase class InsufficientFunds(amount: Double)\n\nclass BankAccountActor extends Actor {\n  var balance: Double = 0.0\n\n  def receive: Receive = {\n    case Deposit(amount) =>\n      if (amount > 0) {\n        balance += amount\n        println(s\"BankAccountActor: Deposited $$ $amount. New balance: $$ $balance.\")\n      } else {\n        println(\"BankAccountActor: Deposit amount must be positive.\")\n      }\n    case Withdraw(amount) =>\n      if (amount > 0) {\n        if (balance >= amount) {\n          balance -= amount\n          println(s\"BankAccountActor: Withdrew $$ $amount. New balance: $$ $balance.\")\n        } else {\n          println(s\"BankAccountActor: Insufficient funds for withdrawal of $$ $amount.\")\n          sender() ! InsufficientFunds(amount)\n        }\n      } else {\n        println(\"BankAccountActor: Withdrawal amount must be positive.\")\n      }\n    case GetBalance =>\n      sender() ! CurrentBalance(balance)\n    case _ => println(\"BankAccountActor: Received unknown message.\")\n  }\n}\n\nobject BankAccountApp extends App {\n  val system = ActorSystem(\"BankAccountSystem\")\n  val account = system.actorOf(Props[BankAccountActor](), \"bankAccountActor\")\n\n  account ! Deposit(1000)\n  account ! Withdraw(300)\n  account ! Withdraw(800) // This should trigger insufficient funds\n  account ! GetBalance\n\n  Thread.sleep(1000)\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AskPatternExampleActor that uses the ask pattern to query a DataActor and prints the response."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase object QueryData\ncase class DataResponse(data: String)\n\nclass DataActor extends Actor {\n  def receive: Receive = {\n    case QueryData =>\n      println(\"DataActor: Received QueryData.\")\n      sender() ! DataResponse(\"Here is your data.\")\n    case _ => println(\"DataActor: Received unknown message.\")\n  }\n}\n\nobject AskPatternExampleApp extends App {\n  val system = ActorSystem(\"AskPatternSystem\")\n  val dataActor = system.actorOf(Props[DataActor](), \"dataActor\")\n\n  implicit val timeout: Timeout = Timeout(3.seconds)\n  val future = dataActor ? QueryData\n  val result = Await.result(future, timeout.duration).asInstanceOf[DataResponse]\n  println(s\"AskPatternExample: Received response -> ${result.data}\")\n\n  system.terminate()\n}\n"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TemperatureSensorActor that periodically sends temperature readings to a TemperatureAggregatorActor, which calculates and prints the average temperature."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, ActorRef, Props}\nimport scala.concurrent.duration._\nimport scala.util.Random\n\n// Messages for temperature readings and aggregation\ncase class TemperatureReading(sensorId: String, temperature: Double)\ncase object ComputeAverage\n\n// Actor that simulates a temperature sensor by sending random readings\nclass TemperatureSensorActor(sensorId: String, aggregator: ActorRef) extends Actor {\n  import context.dispatcher\n  override def preStart(): Unit = {\n    // Schedule a temperature reading every second\n    context.system.scheduler.scheduleWithFixedDelay(0.seconds, 1.second, self, \"read\")\n  }\n\n  def receive: Receive = {\n    case \"read\" =>\n      val temp = 20 + Random.nextDouble() * 15  // Temperature between 20 and 35\n      println(s\"Sensor $sensorId: Reading temperature: $temp\")\n      aggregator ! TemperatureReading(sensorId, temp)\n    case _ => println(s\"Sensor $sensorId: Received unknown message\")\n  }\n}\n\n// Actor that aggregates temperature readings and computes the average\nclass TemperatureAggregatorActor extends Actor {\n  var readings: List[Double] = Nil\n\n  def receive: Receive = {\n    case TemperatureReading(sensorId, temp) =>\n      readings = temp :: readings\n      println(s\"Aggregator: Received reading from $sensorId: $temp\")\n    case ComputeAverage =>\n      if (readings.nonEmpty) {\n        val avg = readings.sum / readings.size\n        println(f\"Aggregator: Average temperature = $avg%.2f\")\n        readings = Nil  // reset after computing average\n      } else {\n        println(\"Aggregator: No readings to compute average.\")\n      }\n    case _ => println(\"Aggregator: Received unknown message.\")\n  }\n}\n\nobject TemperatureSensorApp extends App {\n  val system = ActorSystem(\"TemperatureSensorSystem\")\n  val aggregator = system.actorOf(Props[TemperatureAggregatorActor](), \"tempAggregator\")\n\n  // Create two temperature sensor actors\n  val sensor1 = system.actorOf(Props(new TemperatureSensorActor(\"Sensor1\", aggregator)), \"sensor1\")\n  val sensor2 = system.actorOf(Props(new TemperatureSensorActor(\"Sensor2\", aggregator)), \"sensor2\")\n\n  // Schedule average computation every 5 seconds\n  import system.dispatcher\n  system.scheduler.scheduleWithFixedDelay(5.seconds, 5.seconds)(new Runnable {\n    def run(): Unit = aggregator ! ComputeAverage\n  })\n\n  Thread.sleep(20000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named FileLoggerActor that logs messages to a file named 'app.log'. It should handle LogMessage messages and append them to the file."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport java.io.{File, FileWriter, BufferedWriter}\nimport scala.util.{Try, Success, Failure}\n\ncase class LogMessage(message: String)\n\nclass FileLoggerActor(logFilePath: String) extends Actor {\n  // Open file in append mode\n  val file = new File(logFilePath)\n  val bw = new BufferedWriter(new FileWriter(file, true))\n\n  def receive: Receive = {\n    case LogMessage(msg) =>\n      Try {\n        bw.write(s\"${java.time.LocalDateTime.now()}: $msg\\n\")\n        bw.flush()\n      } match {\n        case Success(_) => println(s\"FileLoggerActor: Logged message -> $msg\")\n        case Failure(ex) => println(s\"FileLoggerActor: Failed to log message: ${ex.getMessage}\")\n      }\n    case _ => println(\"FileLoggerActor: Received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    bw.close()\n    super.postStop()\n  }\n}\n\nobject FileLoggerApp extends App {\n  val system = ActorSystem(\"FileLoggerSystem\")\n  val fileLogger = system.actorOf(Props(new FileLoggerActor(\"app.log\")), \"fileLogger\")\n\n  fileLogger ! LogMessage(\"Application started\")\n  fileLogger ! LogMessage(\"Processing data...\")\n  fileLogger ! LogMessage(\"Application finished successfully\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named ChatbotActor that changes its behavior using context.become. The actor should respond differently based on whether it is in a greeting state or a conversation state."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class UserMessage(message: String)\ncase object Greet\n\nclass ChatbotActor extends Actor {\n  def receive: Receive = greeting\n\n  def greeting: Receive = {\n    case Greet =>\n      println(\"Chatbot: Hello! How can I assist you today?\")\n      context.become(conversation)\n    case _ => println(\"Chatbot: Please start by greeting me.\")\n  }\n\n  def conversation: Receive = {\n    case UserMessage(msg) => println(s\"Chatbot: You said '$msg'. Let me process that.\")\n    case _ => println(\"Chatbot: I don't understand.\")\n  }\n}\n\nobject ChatbotApp extends App {\n  val system = ActorSystem(\"ChatbotSystem\")\n  val chatbot = system.actorOf(Props[ChatbotActor](), \"chatbotActor\")\n\n  chatbot ! Greet\n  chatbot ! UserMessage(\"I need help with my order.\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named InventoryManagerActor that manages stock for items. It should handle AddStock, RemoveStock, and GetStock messages, replying with StockCount."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class AddStock(item: String, count: Int)\ncase class RemoveStock(item: String, count: Int)\ncase class GetStock(item: String)\ncase class StockCount(item: String, count: Int)\n\nclass InventoryManagerActor extends Actor {\n  var inventory: Map[String, Int] = Map.empty.withDefaultValue(0)\n\n  def receive: Receive = {\n    case AddStock(item, count) =>\n      inventory += (item -> (inventory(item) + count))\n      println(s\"InventoryManager: Added $count of $item. New count: ${inventory(item)}\")\n    case RemoveStock(item, count) =>\n      if (inventory(item) >= count) {\n        inventory += (item -> (inventory(item) - count))\n        println(s\"InventoryManager: Removed $count of $item. New count: ${inventory(item)}\")\n      } else {\n        println(s\"InventoryManager: Not enough $item in stock to remove $count.\")\n      }\n    case GetStock(item) => sender() ! StockCount(item, inventory(item))\n    case _ => println(\"InventoryManager: Received unknown message.\")\n  }\n}\n\nobject InventoryManagerApp extends App {\n  val system = ActorSystem(\"InventorySystem\")\n  val inventoryManager = system.actorOf(Props[InventoryManagerActor](), \"inventoryManager\")\n\n  inventoryManager ! AddStock(\"Widget\", 10)\n  inventoryManager ! RemoveStock(\"Widget\", 3)\n  inventoryManager ! GetStock(\"Widget\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named DirectoryWatcherActor that simulates monitoring a directory for new files. It should handle CheckDirectory messages and simulate detecting new files."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.util.Random\nimport scala.concurrent.duration._\n\ncase object CheckDirectory\ncase class NewFileDetected(fileName: String)\n\nclass DirectoryWatcherActor extends Actor {\n  import context.dispatcher\n  override def preStart(): Unit = {\n    // Schedule a directory check every 2 seconds\n    context.system.scheduler.scheduleWithFixedDelay(0.seconds, 2.seconds, self, CheckDirectory)\n  }\n\n  def receive: Receive = {\n    case CheckDirectory =>\n      // Simulate file detection with a random chance\n      if (Random.nextBoolean()) {\n        val fileName = s\"file_${System.currentTimeMillis()}.txt\"\n        println(s\"DirectoryWatcher: Detected new file: $fileName\")\n        context.parent ! NewFileDetected(fileName)\n      } else {\n        println(\"DirectoryWatcher: No new files detected.\")\n      }\n    case _ => println(\"DirectoryWatcher: Received unknown message.\")\n  }\n}\n\nobject DirectoryWatcherApp extends App {\n  val system = ActorSystem(\"DirectoryWatcherSystem\")\n  val watcher = system.actorOf(Props[DirectoryWatcherActor](), \"directoryWatcher\")\n\n  Thread.sleep(8000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named RandomQuoteActor that responds to GetQuote messages by returning a random quote from a predefined list."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.util.Random\n\ncase object GetQuote\ncase class Quote(text: String)\n\nclass RandomQuoteActor extends Actor {\n  val quotes = List(\n    \"The only limit to our realization of tomorrow is our doubts of today.\",\n    \"Life is 10% what happens to us and 90% how we react to it.\",\n    \"Change your thoughts and you change your world.\"\n  )\n\n  def receive: Receive = {\n    case GetQuote =>\n      val randomQuote = quotes(Random.nextInt(quotes.size))\n      println(s\"RandomQuoteActor: Sending quote: $randomQuote\")\n      sender() ! Quote(randomQuote)\n    case _ => println(\"RandomQuoteActor: Received unknown message.\")\n  }\n}\n\nobject RandomQuoteApp extends App {\n  val system = ActorSystem(\"QuoteSystem\")\n  val quoteActor = system.actorOf(Props[RandomQuoteActor](), \"quoteActor\")\n\n  quoteActor ! GetQuote\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named MergeActor that receives messages from two different sources (Source1Message and Source2Message) and, when it has received one message from each source, merges them and sends a MergedResult message to the original sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase class Source1Message(content: String)\ncase class Source2Message(content: String)\ncase class MergedResult(result: String)\n\nclass MergeActor extends Actor {\n  var source1Data: Option[String] = None\n  var source2Data: Option[String] = None\n  var originalSender: Option[ActorRef] = None\n\n  def receive: Receive = {\n    case Source1Message(content) =>\n      source1Data = Some(content)\n      originalSender = Some(sender())\n      attemptMerge()\n    case Source2Message(content) =>\n      source2Data = Some(content)\n      originalSender = Some(sender())\n      attemptMerge()\n    case _ => println(\"MergeActor: Received unknown message.\")\n  }\n\n  def attemptMerge(): Unit = {\n    (source1Data, source2Data) match {\n      case (Some(data1), Some(data2)) =>\n        val merged = s\"$data1 - $data2\"\n        println(s\"MergeActor: Merged result: $merged\")\n        originalSender.foreach(_ ! MergedResult(merged))\n        // Reset state\n        source1Data = None\n        source2Data = None\n      case _ => // Wait for both messages\n    }\n  }\n}\n\nobject MergeActorApp extends App {\n  val system = ActorSystem(\"MergeSystem\")\n  val mergeActor = system.actorOf(Props[MergeActor](), \"mergeActor\")\n\n  mergeActor ! Source1Message(\"Data from source 1\")\n  mergeActor ! Source2Message(\"Data from source 2\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named WorkflowActor that coordinates a multi-step process. It should spawn two StepActor children to perform steps, and once both steps are complete, it should send a ProcessComplete message to the original sender."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\ncase object StartProcess\ncase object ProcessComplete\ncase class StepCompleted(step: String)\n\nclass StepActor(stepName: String) extends Actor {\n  def receive: Receive = {\n    case \"execute\" =>\n      println(s\"StepActor: Executing $stepName\")\n      sender() ! StepCompleted(stepName)\n    case _ => println(s\"StepActor: Unknown message in $stepName\")\n  }\n}\n\nclass WorkflowActor extends Actor {\n  var stepsCompleted: Set[String] = Set.empty\n  var originalSender: Option[ActorRef] = None\n\n  def receive: Receive = {\n    case StartProcess =>\n      originalSender = Some(sender())\n      // Create two step actors\n      val step1 = context.actorOf(Props(new StepActor(\"Step1\")), \"step1\")\n      val step2 = context.actorOf(Props(new StepActor(\"Step2\")), \"step2\")\n      step1 ! \"execute\"\n      step2 ! \"execute\"\n    case StepCompleted(step) =>\n      stepsCompleted += step\n      if (stepsCompleted.size == 2) {\n        println(\"WorkflowActor: Process complete.\")\n        originalSender.foreach(_ ! ProcessComplete)\n        stepsCompleted = Set.empty\n      }\n    case _ => println(\"WorkflowActor: Received unknown message.\")\n  }\n}\n\nobject WorkflowActorApp extends App {\n  val system = ActorSystem(\"WorkflowSystem\")\n  val workflow = system.actorOf(Props[WorkflowActor](), \"workflowActor\")\n\n  workflow ! StartProcess\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named UniqueIdGeneratorActor that generates unique IDs upon receiving a GenerateId message. It should reply with GeneratedId containing a unique string."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object GenerateId\ncase class GeneratedId(id: String)\n\nclass UniqueIdGeneratorActor extends Actor {\n  var counter: Int = 0\n\n  def receive: Receive = {\n    case GenerateId =>\n      counter += 1\n      val id = s\"ID-$counter\"\n      println(s\"UniqueIdGenerator: Generated $id\")\n      sender() ! GeneratedId(id)\n    case _ => println(\"UniqueIdGenerator: Received unknown message.\")\n  }\n}\n\nobject UniqueIdGeneratorApp extends App {\n  val system = ActorSystem(\"UniqueIdSystem\")\n  val generator = system.actorOf(Props[UniqueIdGeneratorActor](), \"uniqueIdGenerator\")\n\n  generator ! GenerateId\n  generator ! GenerateId\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named SessionManagerActor that manages user sessions. It should handle CreateSession, EndSession, and GetSession messages, maintaining a map of session IDs to user information."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class CreateSession(userId: String)\ncase class EndSession(sessionId: String)\ncase class GetSession(sessionId: String)\ncase class SessionInfo(sessionId: String, userId: String)\ncase class SessionNotFound(sessionId: String)\n\nclass SessionManagerActor extends Actor {\n  var sessions: Map[String, String] = Map.empty\n  var sessionCounter: Int = 0\n\n  def receive: Receive = {\n    case CreateSession(userId) =>\n      sessionCounter += 1\n      val sessionId = s\"session-$sessionCounter\"\n      sessions += (sessionId -> userId)\n      println(s\"SessionManager: Created session $sessionId for user $userId\")\n      sender() ! SessionInfo(sessionId, userId)\n    case EndSession(sessionId) =>\n      if (sessions.contains(sessionId)) {\n        sessions -= sessionId\n        println(s\"SessionManager: Ended session $sessionId\")\n      } else {\n        println(s\"SessionManager: Session $sessionId not found\")\n        sender() ! SessionNotFound(sessionId)\n      }\n    case GetSession(sessionId) =>\n      sessions.get(sessionId) match {\n        case Some(userId) => sender() ! SessionInfo(sessionId, userId)\n        case None => sender() ! SessionNotFound(sessionId)\n      }\n    case _ => println(\"SessionManager: Received unknown message.\")\n  }\n}\n\nobject SessionManagerApp extends App {\n  val system = ActorSystem(\"SessionManagerSystem\")\n  val sessionManager = system.actorOf(Props[SessionManagerActor](), \"sessionManager\")\n\n  sessionManager ! CreateSession(\"user123\")\n  sessionManager ! GetSession(\"session-1\")\n  sessionManager ! EndSession(\"session-1\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named PaymentProcessorActor that simulates processing a payment. It should handle PaymentRequest messages and, after a delay, respond with either PaymentConfirmation or PaymentFailure."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase class PaymentRequest(orderId: String, amount: Double)\ncase class PaymentConfirmation(orderId: String)\ncase class PaymentFailure(orderId: String, reason: String)\n\nclass PaymentProcessorActor extends Actor {\n  def receive: Receive = {\n    case PaymentRequest(orderId, amount) =>\n      println(s\"PaymentProcessor: Processing payment for order $orderId, amount $$ $amount\")\n      // Simulate a processing delay\n      context.system.scheduler.scheduleOnce(1.second) {\n        if (amount < 1000) {\n          println(s\"PaymentProcessor: Payment for order $orderId confirmed.\")\n          sender() ! PaymentConfirmation(orderId)\n        } else {\n          println(s\"PaymentProcessor: Payment for order $orderId failed due to insufficient funds.\")\n          sender() ! PaymentFailure(orderId, \"Insufficient funds\")\n        }\n      }\n    case _ => println(\"PaymentProcessor: Received unknown message.\")\n  }\n}\n\nobject PaymentProcessorApp extends App {\n  val system = ActorSystem(\"PaymentProcessorSystem\")\n  val processor = system.actorOf(Props[PaymentProcessorActor](), \"paymentProcessor\")\n\n  processor ! PaymentRequest(\"Order1001\", 500)\n  processor ! PaymentRequest(\"Order1002\", 1500)\n\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named MetricsCollectorActor that collects numerical metrics from various sources. It should handle SubmitMetric messages and periodically print a summary of the metrics collected."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.ListBuffer\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ncase class SubmitMetric(value: Double)\n\nclass MetricsCollectorActor extends Actor {\n  val metrics = ListBuffer[Double]()\n\n  override def preStart(): Unit = {\n    context.system.scheduler.scheduleWithFixedDelay(3.seconds, 3.seconds, self, \"printSummary\")\n  }\n\n  def receive: Receive = {\n    case SubmitMetric(value) =>\n      metrics += value\n      println(s\"MetricsCollector: Received metric: $value\")\n    case \"printSummary\" =>\n      if (metrics.nonEmpty) {\n        val sum = metrics.sum\n        val avg = sum / metrics.size\n        println(f\"MetricsCollector: Collected ${metrics.size} metrics. Sum: $$${sum}%.2f, Average: $$${avg}%.2f\")\n        metrics.clear()\n      } else {\n        println(\"MetricsCollector: No metrics to report.\")\n      }\n    case _ => println(\"MetricsCollector: Received unknown message.\")\n  }\n}\n\nobject MetricsCollectorApp extends App {\n  val system = ActorSystem(\"MetricsCollectorSystem\")\n  val collector = system.actorOf(Props[MetricsCollectorActor](), \"metricsCollector\")\n\n  collector ! SubmitMetric(10.5)\n  collector ! SubmitMetric(20.0)\n  collector ! SubmitMetric(15.5)\n\n  Thread.sleep(10000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an Akka Actor in Scala named NotifierActor that sends a notification when it receives a Notify(user: String, message: String).\nHuman: Add a second message type for group notifications, e.g., NotifyGroup(groupName: String, message: String)."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Notify(user: String, message: String)\n\nclass NotifierActor extends Actor {\n  def receive: Receive = {\n    case Notify(user, msg) =>\n      println(s\"NotifierActor: Sending notification to $user -> $msg\")\n    case _ =>\n      println(\"NotifierActor: Received unknown message.\")\n  }\n}\n\nobject NotifierApp extends App {\n  val system = ActorSystem(\"NotifierSystem\")\n  val notifier = system.actorOf(Props[NotifierActor](), \"notifierActor\")\n\n  notifier ! Notify(\"Alice\", \"You have a new message!\")\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a simple conversation demonstrating a ChatActor that handles Join and Chat messages.\nHuman: Add a Leave(name: String) message and show removing users from the set."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Join(name: String)\ncase class Chat(user: String, message: String)\n\nclass ChatActor extends Actor {\n  var users: Set[String] = Set.empty\n  def receive: Receive = {\n    case Join(name) =>\n      users += name\n      println(s\"ChatActor: $name joined. Current users: $users\")\n    case Chat(user, message) =>\n      println(s\"ChatActor: [$user] $message\")\n    case _ => println(\"ChatActor: Unknown message.\")\n  }\n}\n\nobject ChatApp extends App {\n  val system = ActorSystem(\"ChatSystem\")\n  val chatActor = system.actorOf(Props[ChatActor](), \"chatActor\")\n\n  chatActor ! Join(\"Alice\")\n  chatActor ! Join(\"Bob\")\n  chatActor ! Chat(\"Alice\", \"Hello Bob!\")\n\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a BankAccountActor in Scala that handles Deposit and Withdraw messages, replying with the new balance."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Messages representing bank account actions\ncase class Deposit(amount: Double)\ncase class Withdraw(amount: Double)\n// Reply message containing the updated balance\ncase class UpdatedBalance(balance: Double)\n\n// Actor that manages a simple bank account\nclass BankAccountActor extends Actor {\n  private var balance = 0.0\n\n  def receive: Receive = {\n    case Deposit(amount) =>\n      balance += amount\n      println(s\"BankAccountActor: Deposited $$ $amount, new balance: $$ $balance.\")\n      sender() ! UpdatedBalance(balance)\n\n    case Withdraw(amount) =>\n      if (balance >= amount) {\n        balance -= amount\n        println(s\"BankAccountActor: Withdrew $$ $amount, new balance: $$ $balance.\")\n        sender() ! UpdatedBalance(balance)\n      } else {\n        println(s\"BankAccountActor: Insufficient funds to withdraw $$ $amount.\")\n        sender() ! UpdatedBalance(balance) // Return current balance\n      }\n\n    case _ =>\n      println(\"BankAccountActor: Unknown message.\")\n  }\n}\n\nobject BankAccountApp extends App {\n  val system = ActorSystem(\"BankSystem\")\n  val account = system.actorOf(Props[BankAccountActor](), \"bankAccount\")\n\n  account ! Deposit(100.0)\n  account ! Withdraw(30.0)\n  account ! Withdraw(80.0)\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a BankAccountActor in Scala that handles Deposit and Withdraw messages, replying with the new balance.\nHuman: Add a GetBalance message that returns the current balance."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase class Deposit(amount: Double)\ncase class Withdraw(amount: Double)\ncase object GetBalance\ncase class UpdatedBalance(balance: Double)\n\nclass BankAccountActor extends Actor {\n  private var balance = 0.0\n\n  def receive: Receive = {\n    case Deposit(amount) =>\n      balance += amount\n      println(s\"BankAccountActor: Deposited $$ $amount, new balance: $$ $balance.\")\n      sender() ! UpdatedBalance(balance)\n\n    case Withdraw(amount) =>\n      if (balance >= amount) {\n        balance -= amount\n        println(s\"BankAccountActor: Withdrew $$ $amount, new balance: $$ $balance.\")\n        sender() ! UpdatedBalance(balance)\n      } else {\n        println(s\"BankAccountActor: Insufficient funds to withdraw $$ $amount.\")\n        sender() ! UpdatedBalance(balance) // Return current balance\n      }\n\n    case GetBalance =>\n      println(s\"BankAccountActor: Returning current balance: $$ $balance.\")\n      sender() ! UpdatedBalance(balance)\n\n    case _ =>\n      println(\"BankAccountActor: Unknown message.\")\n  }\n}\n\nobject BankAccountApp extends App {\n  val system = ActorSystem(\"BankSystem\")\n  val account = system.actorOf(Props[BankAccountActor](), \"bankAccount\")\n\n  // Various operations\n  account ! Deposit(100.0)\n  account ! Withdraw(30.0)\n  account ! GetBalance\n  account ! Withdraw(80.0)\n  account ! GetBalance\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ToggleActor in Scala that switches behavior using context.become. Then allow a second conversation to add a new command."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Command to toggle the state\ncase object Toggle\n// Regular string messages\ncase class Msg(content: String)\n\nclass ToggleActor extends Actor {\n  // Start in active state\n  def receive: Receive = active\n\n  def active: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from active to inactive.\")\n      context.become(inactive)\n    case Msg(content) =>\n      println(s\"ToggleActor (active) got -> $content\")\n    case _ =>\n      println(\"ToggleActor (active) received an unknown message.\")\n  }\n\n  def inactive: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from inactive to active.\")\n      context.become(active)\n    case Msg(content) =>\n      println(s\"ToggleActor (inactive) got -> $content\")\n    case _ =>\n      println(\"ToggleActor (inactive) received an unknown message.\")\n  }\n}\n\nobject ToggleApp extends App {\n  val system = ActorSystem(\"ToggleSystem\")\n  val toggler = system.actorOf(Props[ToggleActor](), \"toggleActor\")\n\n  toggler ! Msg(\"Hello in active mode.\")\n  toggler ! Toggle\n  toggler ! Msg(\"Now I'm in inactive mode.\")\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ToggleActor in Scala that switches behavior using context.become. Then allow a second conversation to add a new command.\nHuman: Add a new Reset command that always returns the actor to the active state, regardless of its current state."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Toggle\ncase object Reset\ncase class Msg(content: String)\n\nclass ToggleActor extends Actor {\n  // Start in active state\n  def receive: Receive = active\n\n  def active: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from active to inactive.\")\n      context.become(inactive)\n    case Reset =>\n      println(\"ToggleActor: Already active, staying active.\")\n      // Remain in the same active state\n    case Msg(content) =>\n      println(s\"ToggleActor (active) got -> $content\")\n    case _ =>\n      println(\"ToggleActor (active) received unknown message.\")\n  }\n\n  def inactive: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from inactive to active.\")\n      context.become(active)\n    case Reset =>\n      println(\"ToggleActor: Reset invoked, going to active.\")\n      context.become(active)\n    case Msg(content) =>\n      println(s\"ToggleActor (inactive) got -> $content\")\n    case _ =>\n      println(\"ToggleActor (inactive) received unknown message.\")\n  }\n}\n\nobject ToggleApp extends App {\n  val system = ActorSystem(\"ToggleSystem\")\n  val toggler = system.actorOf(Props[ToggleActor](), \"toggleActor\")\n\n  toggler ! Msg(\"Hello in active mode.\")\n  toggler ! Toggle\n  toggler ! Msg(\"Now I'm in inactive mode.\")\n\n  // Use Reset to go back to active no matter what\n  toggler ! Reset\n  toggler ! Msg(\"Back in active mode.\")\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a HelloActor in Scala that logs a 'Hello, Actor!' message whenever it receives a Greet message. Add detailed comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message to trigger a greeting\ncase object Greet\n\n// Actor that prints a greeting when it receives a Greet message\nclass HelloActor extends Actor {\n  // Define how the actor handles incoming messages\n  def receive: Receive = {\n    // If the message is Greet, log a greeting\n    case Greet =>\n      println(\"HelloActor: Hello, Actor!\")\n    // Otherwise, log unknown messages\n    case _ =>\n      println(\"HelloActor: Unknown message received.\")\n  }\n}\n\nobject HelloActorApp extends App {\n  // Create an ActorSystem named \"HelloSystem\"\n  val system = ActorSystem(\"HelloSystem\")\n  // Create an instance of HelloActor\n  val helloActor = system.actorOf(Props[HelloActor](), \"helloActor\")\n\n  // Send the Greet message\n  helloActor ! Greet\n\n  // Pause briefly, then terminate the system\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a CountingActor in Scala that increments its counter each time it receives Increment, and logs its current count."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Message to increment the counter\ncase object Increment\n\n// Actor that keeps track of how many increments it has seen\nclass CountingActor extends Actor {\n  // Internal counter, starts at zero\n  private var count = 0\n\n  def receive: Receive = {\n    // If we get Increment, increase count and log it\n    case Increment =>\n      count += 1\n      println(s\"CountingActor: Count is now $count\")\n    // If unknown message, log that it's unknown\n    case _ =>\n      println(\"CountingActor: Received unknown message.\")\n  }\n}\n\nobject CountingActorApp extends App {\n  // Create an ActorSystem named \"CountingSystem\"\n  val system = ActorSystem(\"CountingSystem\")\n  // Create an instance of CountingActor\n  val counter = system.actorOf(Props[CountingActor](), \"counter\")\n\n  // Send multiple increments\n  counter ! Increment\n  counter ! Increment\n  counter ! Increment\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create an AggregationActor in Scala that sends tasks to two workers and aggregates their results, with comments explaining each step."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// A task to distribute\ncase class Task(data: String)\n// Workers respond with partial results\ncase class PartialResult(result: String)\n// AggregationActor sends back an aggregated message\ncase class AggregatedResult(content: String)\n\n// WorkerActor that processes a Task and returns PartialResult\nclass WorkerActor(workerId: Int) extends Actor {\n  def receive: Receive = {\n    case Task(data) =>\n      // Process the task in some faked manner\n      val outcome = s\"Worker-$workerId processed: $data\"\n      println(outcome)\n      sender() ! PartialResult(outcome)\n    case _ => println(s\"Worker-$workerId: Unknown message.\")\n  }\n}\n\n// AggregationActor that coordinates two workers and combines their results\nclass AggregationActor(worker1: ActorRef, worker2: ActorRef) extends Actor {\n  private var responses = List.empty[String]\n  private var pendingCount = 0\n  private var originalSender: Option[ActorRef] = None\n\n  def receive: Receive = {\n    case task: Task =>\n      responses = Nil\n      pendingCount = 2\n      originalSender = Some(sender())\n      // Send the same task to both workers\n      worker1 ! task\n      worker2 ! task\n\n    case PartialResult(res) =>\n      responses = res :: responses\n      pendingCount -= 1\n      if (pendingCount == 0) {\n        val aggregated = responses.reverse.mkString(\" | \")\n        println(s\"AggregationActor: Aggregated -> $aggregated\")\n        originalSender.foreach(_ ! AggregatedResult(aggregated))\n      }\n\n    case _ => println(\"AggregationActor: Unknown message.\")\n  }\n}\n\nobject AggregationApp extends App {\n  val system = ActorSystem(\"AggregationSystem\")\n\n  val w1 = system.actorOf(Props(new WorkerActor(1)), \"worker1\")\n  val w2 = system.actorOf(Props(new WorkerActor(2)), \"worker2\")\n\n  val aggregator = system.actorOf(Props(new AggregationActor(w1, w2)), \"aggregator\")\n\n  aggregator ! Task(\"Compute something.\")\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a StashingActor that stashes messages until it receives an Initialize message, with clarity in the code comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\ncase object Initialize\ncase class DataMsg(content: String)\n\n// StashingActor that buffers DataMsg until initialization\nclass StashingActor extends Actor with Stash {\n  def receive: Receive = uninitialized\n\n  def uninitialized: Receive = {\n    case Initialize =>\n      println(\"StashingActor: Actor initialized, unstashing.\")\n      unstashAll() // Process all stashed messages\n      context.become(initialized)\n\n    case otherMsg =>\n      // Stash everything before we are initialized\n      println(s\"StashingActor: Stashing -> $otherMsg\")\n      stash()\n  }\n\n  def initialized: Receive = {\n    case DataMsg(content) =>\n      println(s\"StashingActor: Processing -> $content\")\n    case _ =>\n      println(\"StashingActor (initialized): Unknown message.\")\n  }\n}\n\nobject StashingActorApp extends App {\n  val system = ActorSystem(\"StashingSystem\")\n  val stasher = system.actorOf(Props[StashingActor](), \"stasher\")\n\n  // Send some data before initialization\n  stasher ! DataMsg(\"data1\")\n  stasher ! DataMsg(\"data2\")\n\n  // Now initialize\n  stasher ! Initialize\n\n  // Send data after initialization\n  stasher ! DataMsg(\"data3\")\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a SupervisorActor in Scala that restarts a child on runtime exceptions, with detailed comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, OneForOneStrategy, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy.{Restart, Stop}\nimport scala.concurrent.duration._\n\ncase object FailNow\n\n// A child that throws an error on FailNow\nclass PotentiallyFailingChild extends Actor {\n  def receive: Receive = {\n    case FailNow =>\n      println(s\"PotentiallyFailingChild [${self.path.name}] is failing now!\")\n      throw new RuntimeException(\"Forced child failure.\")\n    case msg =>\n      println(s\"PotentiallyFailingChild [${self.path.name}] received -> $msg\")\n  }\n}\n\n// SupervisorActor with a custom supervision strategy\nclass SupervisorActor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(maxNrOfRetries = 2, withinTimeRange = 1.minute) {\n    case _: RuntimeException =>\n      println(\"SupervisorActor: Restarting child after runtime exception.\")\n      Restart\n    case _ => Stop\n  }\n\n  // Create the child\n  val child = context.actorOf(Props[PotentiallyFailingChild](), \"failingChild\")\n\n  def receive: Receive = {\n    // Forward all messages to the child\n    case msg => child.forward(msg)\n  }\n}\n\nobject SupervisorApp extends App {\n  val system = ActorSystem(\"SupervisorSystem\")\n  val supervisor = system.actorOf(Props[SupervisorActor](), \"supervisor\")\n\n  supervisor ! \"Normal message\"\n  supervisor ! FailNow\n  supervisor ! \"Check if child restarted\"\n\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ToggleActor in Scala that uses context.become to switch between active and inactive, with a short explanation."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\ncase object Toggle\ncase class Message(text: String)\n\nclass ToggleActor extends Actor {\n  // Begin in active state\n  def receive: Receive = active\n\n  def active: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from active to inactive.\")\n      context.become(inactive)\n    case Message(text) =>\n      println(s\"ToggleActor (active) got -> $text\")\n    case _ => println(\"ToggleActor (active): Unknown message.\")\n  }\n\n  def inactive: Receive = {\n    case Toggle =>\n      println(\"ToggleActor: Switching from inactive to active.\")\n      context.become(active)\n    case Message(text) =>\n      println(s\"ToggleActor (inactive) got -> $text\")\n    case _ => println(\"ToggleActor (inactive): Unknown message.\")\n  }\n}\n\nobject ToggleActorApp extends App {\n  val system = ActorSystem(\"ToggleActorSystem\")\n  val toggle = system.actorOf(Props[ToggleActor](), \"toggleActor\")\n\n  toggle ! Message(\"Hello in active.\")\n  toggle ! Toggle\n  toggle ! Message(\"Now I'm inactive.\")\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a ForwardingActor that preserves the original sender, using forward. Keep comments clear and concise."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// DestinationActor logs any message with its sender\nclass DestinationActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"DestinationActor: Received '$msg' from ${sender().path.name}\")\n  }\n}\n\n// ForwardingActor forwards messages to the destination using 'forward'\nclass ForwardingActor(dest: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ForwardingActor: Forwarding '$msg'\")\n      dest.forward(msg)\n  }\n}\n\nobject ForwardingApp extends App {\n  val system = ActorSystem(\"ForwardingSystem\")\n\n  // Create the destination actor\n  val destination = system.actorOf(Props[DestinationActor](), \"destinationActor\")\n\n  // Create the forwarding actor\n  val forwarder = system.actorOf(Props(new ForwardingActor(destination)), \"forwarder\")\n\n  // Create a test sender to see if original sender is preserved\n  val testSender = system.actorOf(Props(new Actor {\n    def receive: Receive = {\n      case response =>\n        println(s\"TestSender: Got response -> $response\")\n    }\n  }), \"testSender\")\n\n  // Send a message from testSender\n  forwarder.tell(\"Hello, destination!\", testSender)\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a PriorityActor that always processes PriorityMessage before NormalMessage, even if NormalMessage was enqueued first."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\ncase object PriorityMessage\ncase object NormalMessage\n\n// PriorityActor uses stashing to ensure priority messages are processed first\nclass PriorityActor extends Actor with Stash {\n  def receive: Receive = {\n    case PriorityMessage =>\n      // Process priority immediately\n      println(\"PriorityActor: Processing PRIORITY message.\")\n      unstashAll()\n    case NormalMessage =>\n      // Stash normal messages until a priority is handled\n      println(\"PriorityActor: Stashing NORMAL message.\")\n      stash()\n    case _ =>\n      println(\"PriorityActor: Unknown message.\")\n  }\n}\n\nobject PriorityActorApp extends App {\n  val system = ActorSystem(\"PrioritySystem\")\n  val actor = system.actorOf(Props[PriorityActor](), \"priorityActor\")\n\n  // Send normal messages first\n  actor ! NormalMessage\n  actor ! NormalMessage\n  // Then send a priority message\n  actor ! PriorityMessage\n  // Then another normal message\n  actor ! NormalMessage\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Human: Create a RouterActor that uses RoundRobinPool with 3 WorkerActor instances. Provide a moderate number of comments."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\ncase class Work(job: String)\n\nclass WorkerActor extends Actor {\n  def receive: Receive = {\n    case Work(job) =>\n      println(s\"${self.path.name} working on: $job\")\n    case _ =>\n      println(s\"${self.path.name} received an unknown message.\")\n  }\n}\n\nobject RouterActorApp extends App {\n  val system = ActorSystem(\"RouterSystem\")\n\n  // Create a router with 3 workers\n  val router = system.actorOf(\n    RoundRobinPool(3).props(Props[WorkerActor]()),\n    \"workerRouter\"\n  )\n\n  // Send multiple tasks\n  for (i <- 1 to 5) {\n    router ! Work(s\"Task-$i\")\n  }\n\n  Thread.sleep(500)\n  system.terminate()\n}"
      }
    ]
  }
]