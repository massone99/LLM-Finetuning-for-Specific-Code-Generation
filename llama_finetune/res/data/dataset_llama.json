[
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that can handle different types of messages, such as strings, integers, and custom case classes, performing different actions based on the message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define custom messages\ncase class Greet(name: String)\ncase class Calculate(a: Int, b: Int)\n\n// Define the MultiMessageActor\nclass MultiMessageActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"Received string message: $msg\")\n    case Greet(name) =>\n      println(s\"Hello, $name!\")\n    case Calculate(a, b) =>\n      println(s\"The sum of $a and $b is ${a + b}\")\n    case _ =>\n      println(\"Unknown message received.\")\n  }\n}\n\n// Usage Example\nobject MultiMessageApp extends App {\n  val system = ActorSystem(\"MultiMessageSystem\")\n  val multiActor = system.actorOf(Props[MultiMessageActor](), \"multiActor\")\n\n  multiActor ! \"A simple string\"\n  multiActor ! Greet(\"Alice\")\n  multiActor ! Calculate(5, 7)\n  multiActor ! 42 // This will trigger the unknown message case\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that maintains a counter. It should handle two messages: one to increment the counter and another to retrieve its current value."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Messages\ncase object Increment\ncase object GetCount\n\n// Define the CounterActor\nclass CounterActor extends Actor {\n  var count = 0\n\n  def receive: Receive = {\n    case Increment =>\n      count += 1\n    case GetCount =>\n      sender() ! count\n  }\n}\n\n// Usage Example\nobject CounterApp extends App {\n  val system = ActorSystem(\"CounterSystem\")\n  val counter = system.actorOf(Props[CounterActor](), \"counter\")\n\n  counter ! Increment\n  counter ! Increment\n  counter ! GetCount\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Supervisor Actor in Scala that supervises a child actor. The supervisor should restart the child in case of any failure"
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy, Terminated}\nimport akka.actor.SupervisorStrategy._\n\nimport scala.concurrent.duration._\n\n// Define the ChildActor\nclass ChildActor extends Actor {\n  def receive: Receive = {\n    case \"fail\" => throw new Exception(\"Child failed!\")\n    case msg    => println(s\"Child received: $msg\")\n  }\n}\n\n// Define the SupervisorActor\nclass SupervisorActor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy(\n    maxNrOfRetries = 3,\n    withinTimeRange = 1.minute\n  ) {\n    case _: Exception => Restart\n  }\n\n  val child: ActorRef = context.actorOf(Props[ChildActor](), \"childActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example\nobject SupervisorApp extends App {\n  val system = ActorSystem(\"SupervisorSystem\")\n  val supervisor = system.actorOf(Props[SupervisorActor](), \"supervisor\")\n\n  supervisor ! \"Hello\"\n  supervisor ! \"fail\"\n  supervisor ! \"Are you there?\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Develop an Akka Router Actor in Scala that distributes incoming messages to a pool of worker actors using a round-robin strategy."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.routing.RoundRobinPool\n\n// Define the WorkerActor\nclass WorkerActor extends Actor {\n  def receive: Receive = {\n    case msg => println(s\"${self.path.name} processed message: $msg\")\n  }\n}\n\n// Usage Example\nobject RouterApp extends App {\n  val system = ActorSystem(\"RouterSystem\")\n  \n  // Create a router with 5 worker actors\n  val router: ActorRef = system.actorOf(\n    RoundRobinPool(5).props(Props[WorkerActor]()),\n    \"workerRouter\"\n  )\n\n  // Send messages to the router\n  for (i <- 1 to 10) {\n    router ! s\"Message $i\"\n  }\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that communicates with multiple other actors, sending messages and aggregating responses."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define worker actors\nclass Worker(id: Int) extends Actor {\n  def receive: Receive = {\n    case \"work\" =>\n      sender() ! s\"Worker $id completed work.\"\n  }\n}\n\n// Define the ManagerActor\nclass Manager(numWorkers: Int) extends Actor {\n  // Create worker actors\n  val workers: IndexedSeq[ActorRef] = for (i <- 1 to numWorkers) yield {\n    context.actorOf(Props(new Worker(i)), s\"worker$i\")\n  }\n\n  def receive: Receive = {\n    case \"start\" =>\n      workers.foreach(_ ! \"work\")\n    case msg =>\n      println(s\"Manager received: $msg\")\n  }\n}\n\n// Usage Example\nobject ManagerApp extends App {\n  val system = ActorSystem(\"ManagerSystem\")\n  val manager = system.actorOf(Props(new Manager(3)), \"manager\")\n\n  manager ! \"start\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala that changes its behavior based on the messages it receives using context.become"
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the ToggleActor\nclass ToggleActor extends Actor {\n  def active: Receive = {\n    case \"toggle\" =>\n      println(\"Switching to inactive state.\")\n      context.become(inactive)\n    case msg =>\n      println(s\"Active state received: $msg\")\n  }\n\n  def inactive: Receive = {\n    case \"toggle\" =>\n      println(\"Switching to active state.\")\n      context.become(active)\n    case msg =>\n      println(s\"Inactive state received: $msg\")\n  }\n\n  def receive: Receive = active\n}\n\n// Usage Example\nobject ToggleApp extends App {\n  val system = ActorSystem(\"ToggleSystem\")\n  val toggleActor = system.actorOf(Props[ToggleActor](), \"toggleActor\")\n\n  toggleActor ! \"Hello\"\n  toggleActor ! \"toggle\"\n  toggleActor ! \"World\"\n  toggleActor ! \"toggle\"\n  toggleActor ! \"Back to active\"\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala that uses the ask pattern to send a message and wait for a response asynchronously."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\n\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      sender() ! s\"Received your message: $msg\"\n  }\n}\n\n// Usage Example\nobject AskPatternApp extends App {\n  val system = ActorSystem(\"AskPatternSystem\")\n  val responder = system.actorOf(Props[ResponderActor](), \"responder\")\n\n  implicit val timeout: Timeout = Timeout(5.seconds)\n  val future = responder ? \"Hello via ask pattern\"\n\n  val result = Await.result(future, timeout.duration).asInstanceOf[String]\n  println(result)\n\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named DynamicParentActor that can dynamically create child actors upon receiving a CreateChild(name: String) message. Each child actor should be named according to the provided name and simply print any message it receives. Demonstrate creating multiple children and sending messages to them through the parent."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class CreateChild(name: String)\ncase class SendMessageToChild(childName: String, message: String)\n\n// Define the ChildActor\nclass ChildActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ChildActor [$name] received message: $msg\")\n  }\n}\n\n// Define the DynamicParentActor\nclass DynamicParentActor extends Actor {\n  var children: Map[String, ActorRef] = Map.empty\n\n  def receive: Receive = {\n    case CreateChild(name) =>\n      if (!children.contains(name)) {\n        val child = context.actorOf(Props(new ChildActor(name)), name)\n        children += (name -> child)\n        println(s\"ParentActor created child actor with name: $name\")\n      } else {\n        println(s\"Child actor with name '$name' already exists.\")\n      }\n\n    case SendMessageToChild(childName, message) =>\n      children.get(childName) match {\n        case Some(child) =>\n          child ! message\n        case None =>\n          println(s\"No child actor found with name: $childName\")\n      }\n\n    case msg =>\n      println(s\"ParentActor received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DynamicParentApp extends App {\n  val system = ActorSystem(\"DynamicParentSystem\")\n  val parent = system.actorOf(Props[DynamicParentActor](), \"parentActor\")\n\n  // Create child actors\n  parent ! CreateChild(\"child1\")\n  parent ! CreateChild(\"child2\")\n  parent ! CreateChild(\"child1\") // Attempt to create an existing child\n\n  // Send messages to child actors\n  parent ! SendMessageToChild(\"child1\", \"Hello Child 1!\")\n  parent ! SendMessageToChild(\"child2\", \"Hello Child 2!\")\n  parent ! SendMessageToChild(\"child3\", \"Hello Child 3!\") // Non-existent child\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named BufferedActor that buffers incoming messages and processes them at a controlled rate of one message every 500 milliseconds. Implement buffering such that incoming messages are stored in a queue if the actor is busy processing. Demonstrate sending multiple messages rapidly and observing the controlled processing rate."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport scala.collection.mutable.Queue\nimport scala.concurrent.duration._\nimport akka.actor.Cancellable\nimport scala.concurrent.ExecutionContext\n\n// Define the BufferedActor\nclass BufferedActor extends Actor {\n  import context.dispatcher\n\n  // Internal message queue\n  val messageQueue: Queue[String] = Queue.empty\n\n  // Processing state\n  var isProcessing: Boolean = false\n  var timer: Option[Cancellable] = None\n\n  def receive: Receive = {\n    case msg: String =>\n      messageQueue.enqueue(msg)\n      processNext()\n\n    case \"process\" =>\n      if (messageQueue.nonEmpty) {\n        val msg = messageQueue.dequeue()\n        println(s\"BufferedActor processing message: $msg\")\n        // Simulate processing delay\n        timer = Some(context.system.scheduler.scheduleOnce(500.milliseconds, self, \"process\"))\n      } else {\n        isProcessing = false\n      }\n  }\n\n  def processNext(): Unit = {\n    if (!isProcessing && messageQueue.nonEmpty) {\n      isProcessing = true\n      self ! \"process\"\n    }\n  }\n\n  override def postStop(): Unit = {\n    timer.foreach(_.cancel())\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BufferedActorApp extends App {\n  val system = ActorSystem(\"BufferedActorSystem\")\n  val bufferedActor = system.actorOf(Props[BufferedActor](), \"bufferedActor\")\n\n  // Send multiple messages rapidly\n  for (i <- 1 to 5) {\n    bufferedActor ! s\"Message $i\"\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(4000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SelfTerminator that monitors the number of messages it has processed. After processing 10 messages, it should gracefully stop itself by sending a \"shutdown\" message to itself. Demonstrate the actor processing messages and terminating after the threshold is reached."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the SelfTerminator Actor\nclass SelfTerminator extends Actor {\n  var messageCount: Int = 0\n\n  def receive: Receive = {\n    case msg: String =>\n      messageCount += 1\n      println(s\"SelfTerminator processed message: $msg (Count: $messageCount)\")\n      if (messageCount >= 10) {\n        println(\"SelfTerminator reached message limit. Shutting down.\")\n        self ! \"shutdown\"\n      }\n    case \"shutdown\" =>\n      println(\"SelfTerminator is shutting itself down.\")\n      context.stop(self)\n    case _ =>\n      println(\"SelfTerminator received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelfTerminatorApp extends App {\n  val system = ActorSystem(\"SelfTerminatorSystem\")\n  val terminator = system.actorOf(Props[SelfTerminator](), \"terminatorActor\")\n\n  // Send 12 messages to demonstrate termination after 10\n  for (i <- 1 to 12) {\n    terminator ! s\"Message $i\"\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named PriorityHandlerActor that handles high-priority and low-priority messages differently. Without using a custom mailbox, implement the actor such that it always processes high-priority messages (\"HighPriority\") before any pending low-priority messages (\"LowPriority\"), regardless of the order they were received."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Stash}\n\n// Define the PriorityHandlerActor\nclass PriorityHandlerActor extends Actor with Stash {\n  def receive: Receive = {\n    case \"HighPriority\" =>\n      println(\"Processing High Priority message.\")\n      unstashAll()\n      context.become(normal)\n    case \"LowPriority\" =>\n      println(\"Stashing Low Priority message.\")\n      stash()\n    case msg =>\n      println(s\"Received unknown message: $msg\")\n  }\n\n  def normal: Receive = {\n    case \"HighPriority\" =>\n      println(\"Processing High Priority message.\")\n    case \"LowPriority\" =>\n      println(\"Processing Low Priority message.\")\n    case msg =>\n      println(s\"Received unknown message: $msg\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PriorityHandlerApp extends App {\n  val system = ActorSystem(\"PriorityHandlerSystem\")\n  val priorityHandler = system.actorOf(Props[PriorityHandlerActor](), \"priorityHandler\")\n\n  // Send messages in mixed order\n  priorityHandler ! \"LowPriority\"   // Should be stashed\n  priorityHandler ! \"LowPriority\"   // Should be stashed\n  priorityHandler ! \"HighPriority\"  // Should process immediately and unstash\n  priorityHandler ! \"HighPriority\"  // Should process immediately\n  priorityHandler ! \"LowPriority\"   // Should process now\n  priorityHandler ! \"LowPriority\"   // Should process now\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named ForwardingActor that forwards any received message to another actor named DestinationActor using the forward method. Ensure that the original sender is preserved when forwarding messages. Demonstrate the forwarding behavior by sending messages through the ForwardingActor and verifying that DestinationActor receives them with the correct sender reference."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the DestinationActor\nclass DestinationActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"DestinationActor received message: $msg from ${sender().path.name}\")\n  }\n}\n\n// Define the ForwardingActor\nclass ForwardingActor(destination: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"ForwardingActor forwarding message: $msg\")\n      destination.forward(msg) // Preserves the original sender\n  }\n}\n\n// Define a Simple Sender Actor for demonstration\nclass SenderActor(forwarding: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"SenderActor sending message: $msg\")\n      forwarding ! msg\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ForwardingApp extends App {\n  val system = ActorSystem(\"ForwardingSystem\")\n  \n  val destination = system.actorOf(Props[DestinationActor](), \"destinationActor\")\n  val forwarding = system.actorOf(Props(new ForwardingActor(destination)), \"forwardingActor\")\n  val senderActor = system.actorOf(Props(new SenderActor(forwarding)), \"senderActor\")\n  \n  // Send messages through the SenderActor\n  senderActor ! \"Hello via Forwarding!\"\n  senderActor ! \"Another forwarded message.\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TerminatorActor that performs a simple task upon receiving any message. Demonstrate the use of Akka's PoisonPill to forcefully terminate the actor after it processes a few messages. Verify that the actor stops receiving messages post-termination."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, PoisonPill}\n\n// Define the TerminatorActor\nclass TerminatorActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"TerminatorActor received message: $msg\")\n    case _ =>\n      println(\"TerminatorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TerminatorApp extends App {\n  val system = ActorSystem(\"TerminatorSystem\")\n  val terminator = system.actorOf(Props[TerminatorActor](), \"terminatorActor\")\n\n  // Send messages to the actor\n  terminator ! \"Message 1\"\n  terminator ! \"Message 2\"\n  terminator ! \"Message 3\"\n\n  // Send PoisonPill to terminate the actor\n  terminator ! PoisonPill\n\n  // Attempt to send more messages after termination\n  terminator ! \"Message after PoisonPill\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named BatchingActor that collects incoming integer messages and processes them in batches of three. Upon receiving the third message, it should calculate and print the sum of the batch and then reset to collect the next batch. Demonstrate the batching behavior by sending multiple messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define the BatchingActor\nclass BatchingActor extends Actor {\n  var buffer: List[Int] = List.empty\n\n  def receive: Receive = {\n    case num: Int =>\n      buffer = num :: buffer\n      println(s\"BatchingActor received: $num (Buffer size: ${buffer.size})\")\n      if (buffer.size >= 3) {\n        val sum = buffer.sum\n        println(s\"BatchingActor processing batch: ${buffer.reverse} with sum: $sum\")\n        buffer = List.empty\n      }\n    case _ =>\n      println(\"BatchingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BatchingActorApp extends App {\n  val system = ActorSystem(\"BatchingActorSystem\")\n  val batchingActor = system.actorOf(Props[BatchingActor](), \"batchingActor\")\n\n  // Send multiple integer messages\n  batchingActor ! 5\n  batchingActor ! 10\n  batchingActor ! 15  // This should trigger batch processing\n  batchingActor ! 20\n  batchingActor ! 25\n  batchingActor ! 30  // Another batch processing\n  batchingActor ! 35  // Partial batch\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Supervisor Actor in Scala named ResumeSupervisor that supervises a child actor named ResumeChildActor. The child actor should throw a RuntimeException when it receives a \"runtime\" message and an IllegalArgumentException when it receives an \"illegal\" message. Configure the supervisor's strategy to resume the child actor on RuntimeException and stop it on IllegalArgumentException. Demonstrate the different outcomes by sending both types of messages."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, OneForOneStrategy, Props, SupervisorStrategy}\nimport akka.actor.SupervisorStrategy._\nimport scala.concurrent.duration._\n\n// Define the ResumeChildActor\nclass ResumeChildActor extends Actor {\n  def receive: Receive = {\n    case \"runtime\" =>\n      println(s\"${self.path.name} received 'runtime' and will throw RuntimeException.\")\n      throw new RuntimeException(\"Simulated RuntimeException.\")\n    case \"illegal\" =>\n      println(s\"${self.path.name} received 'illegal' and will throw IllegalArgumentException.\")\n      throw new IllegalArgumentException(\"Simulated IllegalArgumentException.\")\n    case msg =>\n      println(s\"${self.path.name} received message: $msg\")\n  }\n}\n\n// Define the ResumeSupervisor Actor\nclass ResumeSupervisor extends Actor {\n  override val supervisorStrategy: SupervisorStrategy = OneForOneStrategy() {\n    case _: RuntimeException =>\n      println(\"ResumeSupervisor: Resuming child actor after RuntimeException.\")\n      Resume\n    case _: IllegalArgumentException =>\n      println(\"ResumeSupervisor: Stopping child actor after IllegalArgumentException.\")\n      Stop\n    case _: Exception =>\n      println(\"ResumeSupervisor: Escalating unknown exception.\")\n      Escalate\n  }\n\n  // Create the child actor\n  val child: ActorRef = context.actorOf(Props[ResumeChildActor](), \"resumeChildActor\")\n\n  def receive: Receive = {\n    case msg =>\n      child.forward(msg)\n  }\n}\n\n// Usage Example (for testing purposes)\nobject ResumeSupervisorApp extends App {\n  val system = ActorSystem(\"ResumeSupervisorSystem\")\n  val supervisor = system.actorOf(Props[ResumeSupervisor](), \"resumeSupervisor\")\n\n  // Send a message that causes RuntimeException (should resume)\n  supervisor ! \"runtime\"\n  supervisor ! \"Post-runtime message\"\n\n  // Send a message that causes IllegalArgumentException (should stop)\n  supervisor ! \"illegal\"\n  supervisor ! \"Post-illegal message\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor system in Scala with three actors: InitiatorActor, ResponderActor, and LoggerActor. The InitiatorActor sends a Request message to the ResponderActor. Upon receiving a Request, the ResponderActor replies with a Response message. The InitiatorActor then forwards this Response to the LoggerActor for logging. Demonstrate the message flow between these actors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase object Request\ncase class Response(content: String)\ncase class LogMessage(message: String)\n\n// Define the ResponderActor\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Request =>\n      println(s\"${self.path.name} received Request.\")\n      sender() ! Response(\"Here is your response!\")\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the LoggerActor\nclass LoggerActor extends Actor {\n  def receive: Receive = {\n    case LogMessage(msg) =>\n      println(s\"LoggerActor logging message: $msg\")\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the InitiatorActor\nclass InitiatorActor(responder: ActorRef, logger: ActorRef) extends Actor {\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"${self.path.name} sending Request to ResponderActor.\")\n      responder ! Request\n    case Response(content) =>\n      println(s\"${self.path.name} received Response: $content\")\n      logger ! LogMessage(content)\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject MultipleActorsApp extends App {\n  val system = ActorSystem(\"MultipleActorsSystem\")\n\n  val logger = system.actorOf(Props[LoggerActor](), \"loggerActor\")\n  val responder = system.actorOf(Props[ResponderActor](), \"responderActor\")\n  val initiator = system.actorOf(Props(new InitiatorActor(responder, logger)), \"initiatorActor\")\n\n  // Start the message flow\n  initiator ! \"start\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named MultiTypeActor that handles three different message types: TextMessage(content: String), NumberMessage(value: Int), and Shutdown. For TextMessage, it should print the content. For NumberMessage, it should calculate and print the square of the value. Upon receiving Shutdown, it should gracefully stop itself. Demonstrate handling each message type."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\n\n// Define messages\ncase class TextMessage(content: String)\ncase class NumberMessage(value: Int)\ncase object Shutdown\n\n// Define the MultiTypeActor\nclass MultiTypeActor extends Actor {\n  def receive: Receive = {\n    case TextMessage(content) =>\n      println(s\"MultiTypeActor received TextMessage: $content\")\n    case NumberMessage(value) =>\n      val square = value * value\n      println(s\"MultiTypeActor received NumberMessage: $value, square: $square\")\n    case Shutdown =>\n      println(\"MultiTypeActor received Shutdown. Stopping...\")\n      context.stop(self)\n    case _ =>\n      println(\"MultiTypeActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject MultiTypeActorApp extends App {\n  val system = ActorSystem(\"MultiTypeActorSystem\")\n  val multiTypeActor = system.actorOf(Props[MultiTypeActor](), \"multiTypeActor\")\n\n  // Send different types of messages\n  multiTypeActor ! TextMessage(\"Hello, Akka!\")\n  multiTypeActor ! NumberMessage(7)\n  multiTypeActor ! \"Unknown Message\" // Should trigger unknown message handler\n  multiTypeActor ! Shutdown\n  multiTypeActor ! TextMessage(\"This should not be processed.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CalculatorActor that performs basic arithmetic operations. It should handle messages in the form of Calculate(operation: String, a: Int, b: Int), where operation can be \"add\", \"subtract\", \"multiply\", or \"divide\". The actor should perform the requested operation on the integers a and b and reply with the result. Handle division by zero by replying with an error message."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\n\n// Define the Calculate message\ncase class Calculate(operation: String, a: Int, b: Int)\n\n// Define the CalculatorActor\nclass CalculatorActor extends Actor {\n  def receive: Receive = {\n    case Calculate(op, a, b) =>\n      val result = op.toLowerCase match {\n        case \"add\"      => a + b\n        case \"subtract\" => a - b\n        case \"multiply\" => a * b\n        case \"divide\" =>\n          if (b != 0) a.toDouble / b else \"Error: Division by zero\"\n        case _ => \"Error: Unknown operation\"\n      }\n      sender() ! result\n    case _ =>\n      sender() ! \"Error: Unknown message type.\"\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CalculatorActorApp extends App {\n  val system = ActorSystem(\"CalculatorSystem\")\n  val calculator = system.actorOf(Props[CalculatorActor](), \"calculatorActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to perform calculation and print result\n  def performCalculation(op: String, a: Int, b: Int): Unit = {\n    val future = calculator ? Calculate(op, a, b)\n    val result = Await.result(future, timeout.duration)\n    println(s\"Calculate($op, $a, $b) = $result\")\n  }\n\n  // Perform various calculations\n  performCalculation(\"add\", 10, 5)        // 15\n  performCalculation(\"subtract\", 10, 5)   // 5\n  performCalculation(\"multiply\", 10, 5)   // 50\n  performCalculation(\"divide\", 10, 5)     // 2.0\n  performCalculation(\"divide\", 10, 0)     // Error: Division by zero\n  performCalculation(\"modulo\", 10, 5)     // Error: Unknown operation\n\n  // Shutdown the system\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named BroadcasterActor that maintains a list of subscriber actors. It should handle Subscribe(subscriber: ActorRef) and Broadcast(message: String) messages. Upon receiving a Subscribe message, it should add the actor to its subscriber list. When a Broadcast message is received, it should send the message to all subscribed actors. Demonstrate subscribing multiple actors and broadcasting messages to them."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(subscriber: ActorRef)\ncase class Broadcast(message: String)\n\n// Define the BroadcasterActor\nclass BroadcasterActor extends Actor {\n  var subscribers: Set[ActorRef] = Set.empty\n\n  def receive: Receive = {\n    case Subscribe(subscriber) =>\n      subscribers += subscriber\n      println(s\"BroadcasterActor added subscriber: ${subscriber.path.name}\")\n    case Broadcast(msg) =>\n      println(s\"BroadcasterActor broadcasting message: $msg to ${subscribers.size} subscribers.\")\n      subscribers.foreach(_ ! msg)\n    case _ =>\n      println(\"BroadcasterActor received unknown message.\")\n  }\n}\n\n// Define a Subscriber Actor\nclass SubscriberActor(name: String) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"Subscriber [$name] received broadcast message: $msg\")\n    case _ =>\n      println(s\"Subscriber [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject BroadcasterApp extends App {\n  val system = ActorSystem(\"BroadcasterSystem\")\n  val broadcaster = system.actorOf(Props[BroadcasterActor](), \"broadcasterActor\")\n\n  // Create subscriber actors\n  val subscriber1 = system.actorOf(Props(new SubscriberActor(\"Alice\")), \"subscriber1\")\n  val subscriber2 = system.actorOf(Props(new SubscriberActor(\"Bob\")), \"subscriber2\")\n  val subscriber3 = system.actorOf(Props(new SubscriberActor(\"Charlie\")), \"subscriber3\")\n\n  // Subscribers subscribe to the broadcaster\n  broadcaster ! Subscribe(subscriber1)\n  broadcaster ! Subscribe(subscriber2)\n  broadcaster ! Subscribe(subscriber3)\n\n  // Broadcast messages\n  broadcaster ! Broadcast(\"Welcome to the broadcast system!\")\n  broadcaster ! Broadcast(\"This is the second broadcast message.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named SelectorActor that uses actor selection to send a message to another actor named TargetActor located at a specific path within the same actor system. Demonstrate selecting the TargetActor and sending a \"Hello Target!\" message using actor selection."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the TargetActor\nclass TargetActor extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"TargetActor received message: $msg from ${sender().path.name}\")\n    case _ =>\n      println(\"TargetActor received unknown message.\")\n  }\n}\n\n// Define the SelectorActor\nclass SelectorActor extends Actor {\n  def receive: Receive = {\n    case \"sendHello\" =>\n      // Actor selection path\n      val targetPath = \"/user/targetActor\"\n      val target = context.actorSelection(targetPath)\n      println(s\"SelectorActor sending 'Hello Target!' to $targetPath\")\n      target ! \"Hello Target!\"\n    case _ =>\n      println(\"SelectorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject SelectorApp extends App {\n  val system = ActorSystem(\"SelectorSystem\")\n  \n  // Create TargetActor\n  val target = system.actorOf(Props[TargetActor](), \"targetActor\")\n  \n  // Create SelectorActor\n  val selector = system.actorOf(Props[SelectorActor](), \"selectorActor\")\n  \n  // Send a message to SelectorActor to send message to TargetActor\n  selector ! \"sendHello\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AcknowledgingActor that acknowledges each received message by replying with \"Ack\". Implement a sender actor named RequesterActor that sends multiple messages to AcknowledgingActor and waits for acknowledgments before sending the next message. Demonstrate the acknowledgment mechanism."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define the AcknowledgingActor\nclass AcknowledgingActor extends Actor {\n  def receive: Receive = {\n    case msg =>\n      println(s\"AcknowledgingActor received message: $msg from ${sender().path.name}\")\n      sender() ! \"Ack\"\n  }\n}\n\n// Define the RequesterActor\nclass RequesterActor(ackActor: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(3.seconds)\n\n  def receive: Receive = {\n    case msg: String =>\n      println(s\"RequesterActor sending message: $msg\")\n      val future = ackActor ? msg\n      future.map {\n        case \"Ack\" =>\n          println(s\"RequesterActor received Ack for message: $msg\")\n          // Optionally, send next message or perform other actions\n      }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject AcknowledgmentApp extends App {\n  val system = ActorSystem(\"AcknowledgmentSystem\")\n  \n  val acknowledgingActor = system.actorOf(Props[AcknowledgingActor](), \"acknowledgingActor\")\n  val requesterActor = system.actorOf(Props(new RequesterActor(acknowledgingActor)), \"requesterActor\")\n  \n  // Send multiple messages\n  requesterActor ! \"Message 1\"\n  requesterActor ! \"Message 2\"\n  requesterActor ! \"Message 3\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Implement an Akka Actor in Scala named TransformerActor that receives messages containing integers, multiplies each integer by 2, and forwards the transformed message to another actor named ReceiverActor. Demonstrate the transformation and forwarding behavior by sending integer messages to the TransformerActor."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define the TransformerActor\nclass TransformerActor(receiver: ActorRef) extends Actor {\n  def receive: Receive = {\n    case num: Int =>\n      val transformed = num * 2\n      println(s\"TransformerActor received: $num, transformed to: $transformed\")\n      receiver ! transformed\n    case _ =>\n      println(\"TransformerActor received unknown message.\")\n  }\n}\n\n// Define the ReceiverActor\nclass ReceiverActor extends Actor {\n  def receive: Receive = {\n    case msg: Int =>\n      println(s\"ReceiverActor received transformed message: $msg\")\n    case _ =>\n      println(\"ReceiverActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TransformerApp extends App {\n  val system = ActorSystem(\"TransformerSystem\")\n  \n  val receiver = system.actorOf(Props[ReceiverActor](), \"receiverActor\")\n  val transformer = system.actorOf(Props(new TransformerActor(receiver)), \"transformerActor\")\n  \n  // Send integer messages to TransformerActor\n  transformer ! 5\n  transformer ! 10\n  transformer ! 15\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named ResponderWithTimeout that replies to any Ping message with a Pong after a delay of 2 seconds. Implement a RequesterWithTimeout actor that sends a Ping message to ResponderWithTimeout and waits for a Pong reply with a timeout of 1 second. Handle the timeout scenario by printing \"Request timed out\" if no reply is received in time."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\nimport scala.concurrent.Await\nimport scala.util.{Success, Failure}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// Define messages\ncase object Ping\ncase object Pong\n\n// Define the ResponderWithTimeout Actor\nclass ResponderWithTimeout extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case Ping =>\n      println(s\"${self.path.name} received Ping. Will respond with Pong after delay.\")\n      context.system.scheduler.scheduleOnce(2.seconds, sender(), Pong)\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Define the RequesterWithTimeout Actor\nclass RequesterWithTimeout(responder: ActorRef) extends Actor {\n  implicit val timeout: Timeout = Timeout(1.second)\n\n  def receive: Receive = {\n    case \"start\" =>\n      println(s\"${self.path.name} sending Ping to ${responder.path.name}\")\n      val future = responder ? Ping\n      future.onComplete {\n        case Success(Pong) =>\n          println(s\"${self.path.name} received Pong.\")\n        case Failure(_) =>\n          println(s\"${self.path.name} Request timed out.\")\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TimeoutApp extends App {\n  val system = ActorSystem(\"TimeoutSystem\")\n  \n  val responder = system.actorOf(Props[ResponderWithTimeout](), \"responderWithTimeout\")\n  val requester = system.actorOf(Props(new RequesterWithTimeout(responder)), \"requesterWithTimeout\")\n  \n  // Start the request\n  requester ! \"start\"\n  \n  // Allow some time for processing before shutdown\n  Thread.sleep(3000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named FileReaderActor that reads the contents of a specified text file upon receiving a ReadFile(path: String) message. After reading the file, it should send the file contents back to the sender wrapped in a FileContents(contents: String) message. Demonstrate reading a sample file and handling the response."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.io.Source\nimport scala.util.{Try, Success, Failure}\n\n// Define messages\ncase class ReadFile(path: String)\ncase class FileContents(contents: String)\ncase class FileReadError(error: String)\n\n// Define the FileReaderActor\nclass FileReaderActor extends Actor {\n  def receive: Receive = {\n    case ReadFile(path) =>\n      println(s\"${self.path.name} received request to read file: $path\")\n      val senderRef = sender()\n      val fileContentTry: Try[String] = Try {\n        Source.fromFile(path).mkString\n      }\n      fileContentTry match {\n        case Success(contents) =>\n          senderRef ! FileContents(contents)\n        case Failure(exception) =>\n          senderRef ! FileReadError(exception.getMessage)\n      }\n    case _ =>\n      println(s\"${self.path.name} received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject FileReaderApp extends App {\n  val system = ActorSystem(\"FileReaderSystem\")\n  val fileReader = system.actorOf(Props(new FileReaderActor()), \"fileReaderActor\")\n\n  // Define a simple responder actor to handle responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case FileContents(contents) =>\n        println(s\"ResponderActor received file contents:\\n$contents\")\n      case FileReadError(error) =>\n        println(s\"ResponderActor encountered an error: $error\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Send a ReadFile message\n  fileReader.tell(ReadFile(\"sample.txt\"), responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named PeriodicReporterActor that sends a Report message to itself every 3 seconds. Upon receiving the Report message, it should print the current timestamp to the console. Demonstrate the periodic reporting behavior and ensure the actor stops reporting after five reports."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport java.time.LocalDateTime\n\n// Define the Report message\ncase object Report\n\n// Define the PeriodicReporterActor\nclass PeriodicReporterActor extends Actor {\n  import context.dispatcher\n\n  var reportCount: Int = 0\n  val maxReports: Int = 5\n\n  // Schedule periodic Report messages\n  val cancellable: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = 0.seconds,\n    delay = 3.seconds,\n    receiver = self,\n    message = Report\n  )\n\n  def receive: Receive = {\n    case Report =>\n      reportCount += 1\n      val timestamp = LocalDateTime.now()\n      println(s\"PeriodicReporterActor Report #$reportCount at $timestamp\")\n      if (reportCount >= maxReports) {\n        println(\"PeriodicReporterActor reached maximum reports. Stopping.\")\n        cancellable.cancel()\n        context.stop(self)\n      }\n    case _ =>\n      println(\"PeriodicReporterActor received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    cancellable.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject PeriodicReporterApp extends App {\n  val system = ActorSystem(\"PeriodicReporterSystem\")\n  val reporter = system.actorOf(Props(new PeriodicReporterActor()), \"reporterActor\")\n\n  // Allow some time for reports before shutdown\n  Thread.sleep(16000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named CacheActor that acts as an in-memory cache. It should handle Put(key: String, value: String) messages to store key-value pairs and Get(key: String) messages to retrieve values. Upon receiving a Get message, it should respond with ValueFound(key: String, value: String) if the key exists or ValueNotFound(key: String) if it doesn't. Demonstrate storing and retrieving values from the cache."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Put(key: String, value: String)\ncase class Get(key: String)\ncase class ValueFound(key: String, value: String)\ncase class ValueNotFound(key: String)\n\n// Define the CacheActor\nclass CacheActor extends Actor {\n  var cache: Map[String, String] = Map.empty\n\n  def receive: Receive = {\n    case Put(key, value) =>\n      cache += (key -> value)\n      println(s\"CacheActor stored: [$key -> $value]\")\n    case Get(key) =>\n      cache.get(key) match {\n        case Some(value) =>\n          sender() ! ValueFound(key, value)\n        case None =>\n          sender() ! ValueNotFound(key)\n      }\n    case _ =>\n      println(\"CacheActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject CacheApp extends App {\n  val system = ActorSystem(\"CacheSystem\")\n  val cacheActor = system.actorOf(Props(new CacheActor()), \"cacheActor\")\n\n  // Define a simple responder actor to handle cache responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case ValueFound(key, value) =>\n        println(s\"ResponderActor: Found [$key -> $value] in cache.\")\n      case ValueNotFound(key) =>\n        println(s\"ResponderActor: No entry found for key '$key'.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Store some key-value pairs\n  cacheActor ! Put(\"name\", \"Alice\")\n  cacheActor ! Put(\"city\", \"Wonderland\")\n\n  // Retrieve existing and non-existing keys\n  cacheActor.tell(Get(\"name\"), responder)\n  cacheActor.tell(Get(\"country\"), responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named LoggingActor that logs incoming messages to a file. It should handle Log(message: String) messages by appending them to a specified log file. Ensure that the actor handles file I/O exceptions gracefully by logging errors to the console. Demonstrate logging multiple messages to a file."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport java.io.{File, FileWriter, BufferedWriter}\nimport scala.util.{Try, Success, Failure}\n\n// Define messages\ncase class Log(message: String)\n\n// Define the LoggingActor\nclass LoggingActor(logFilePath: String) extends Actor {\n  // Initialize the log file\n  val logFile: File = new File(logFilePath)\n  val bw: BufferedWriter = new BufferedWriter(new FileWriter(logFile, true)) // Append mode\n\n  override def postStop(): Unit = {\n    bw.close()\n    super.postStop()\n  }\n\n  def receive: Receive = {\n    case Log(msg) =>\n      Try {\n        bw.write(s\"${java.time.LocalDateTime.now()}: $msg\\n\")\n        bw.flush()\n      } match {\n        case Success(_) =>\n          println(s\"LoggingActor: Logged message to $logFilePath\")\n        case Failure(exception) =>\n          println(s\"LoggingActor encountered an error: ${exception.getMessage}\")\n      }\n    case _ =>\n      println(\"LoggingActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject LoggingApp extends App {\n  val system = ActorSystem(\"LoggingSystem\")\n  val loggingActor = system.actorOf(Props(new LoggingActor(\"application.log\")), \"loggingActor\")\n\n  // Define a simple logger to send Log messages\n  class Logger extends Actor {\n    def receive: Receive = {\n      case msg: String =>\n        loggingActor ! Log(msg)\n      case _ =>\n        println(\"Logger received unknown message.\")\n    }\n  }\n\n  val logger = system.actorOf(Props[Logger](), \"logger\")\n\n  // Send log messages\n  logger ! \"Application started.\"\n  logger ! \"Performing some operations.\"\n  logger ! \"Application finished successfully.\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named NotificationActor that sends notifications to users. It should handle Notify(user: String, message: String) messages by printing a personalized notification to the console. Implement a UserActor that represents a user and sends Notify messages to the NotificationActor. Demonstrate sending notifications to multiple users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Notify(user: String, message: String)\n\n// Define the NotificationActor\nclass NotificationActor extends Actor {\n  def receive: Receive = {\n    case Notify(user, message) =>\n      println(s\"Notification to $user: $message\")\n    case _ =>\n      println(\"NotificationActor received unknown message.\")\n  }\n}\n\n// Define the UserActor\nclass UserActor(name: String, notifier: ActorRef) extends Actor {\n  def receive: Receive = {\n    case msg: String =>\n      notifier ! Notify(name, msg)\n    case _ =>\n      println(s\"UserActor [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject NotificationApp extends App {\n  val system = ActorSystem(\"NotificationSystem\")\n  val notificationActor = system.actorOf(Props(new NotificationActor()), \"notificationActor\")\n\n  // Create user actors\n  val user1 = system.actorOf(Props(new UserActor(\"Alice\", notificationActor)), \"userAlice\")\n  val user2 = system.actorOf(Props(new UserActor(\"Bob\", notificationActor)), \"userBob\")\n  val user3 = system.actorOf(Props(new UserActor(\"Charlie\", notificationActor)), \"userCharlie\")\n\n  // Send notifications\n  user1 ! \"Your order has been shipped.\"\n  user2 ! \"You have a new message.\"\n  user3 ! \"Your subscription is about to expire.\"\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named EventEmitterActor that emits events to subscribed listeners. It should handle Subscribe(listener: ActorRef) and EmitEvent(event: String) messages. Upon receiving EmitEvent, it should send the event to all subscribed listeners wrapped in an Event(event: String) message. Demonstrate subscribing multiple listeners and emitting events."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(listener: ActorRef)\ncase class EmitEvent(event: String)\ncase class Event(event: String)\n\n// Define the EventEmitterActor\nclass EventEmitterActor extends Actor {\n  var listeners: Set[ActorRef] = Set.empty\n\n  def receive: Receive = {\n    case Subscribe(listener) =>\n      listeners += listener\n      println(s\"EventEmitterActor: ${listener.path.name} subscribed.\")\n    case EmitEvent(event) =>\n      println(s\"EventEmitterActor: Emitting event: $event to ${listeners.size} listeners.\")\n      listeners.foreach(_ ! Event(event))\n    case _ =>\n      println(\"EventEmitterActor received unknown message.\")\n  }\n}\n\n// Define the ListenerActor\nclass ListenerActor(name: String) extends Actor {\n  def receive: Receive = {\n    case Event(event) =>\n      println(s\"Listener [$name] received event: $event\")\n    case _ =>\n      println(s\"Listener [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EventEmitterApp extends App {\n  val system = ActorSystem(\"EventEmitterSystem\")\n  val eventEmitter = system.actorOf(Props(new EventEmitterActor()), \"eventEmitterActor\")\n\n  // Create listener actors\n  val listener1 = system.actorOf(Props(new ListenerActor(\"Listener1\")), \"listener1\")\n  val listener2 = system.actorOf(Props(new ListenerActor(\"Listener2\")), \"listener2\")\n  val listener3 = system.actorOf(Props(new ListenerActor(\"Listener3\")), \"listener3\")\n\n  // Subscribe listeners\n  eventEmitter ! Subscribe(listener1)\n  eventEmitter ! Subscribe(listener2)\n  eventEmitter ! Subscribe(listener3)\n\n  // Emit events\n  eventEmitter ! EmitEvent(\"UserLoggedIn\")\n  eventEmitter ! EmitEvent(\"FileUploaded\")\n  eventEmitter ! EmitEvent(\"ErrorOccurred\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named RateLimiterActor that restricts the number of incoming Request messages to 3 per second using the token bucket algorithm. Each Request(id: Int) consumes a token. If tokens are available, process the request by printing \"Processed request <id>\"; otherwise, respond with \"Rate limit exceeded for request <id>\". Refill the bucket with 3 tokens every second. Demonstrate sending multiple requests rapidly and observing the rate limiter in action."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.collection.mutable.Queue\nimport akka.actor.Timers\n\n// Define messages\ncase class Request(id: Int)\ncase class Response(message: String)\n\n// Define the RateLimiterActor\nclass RateLimiterActor extends Actor {\n  import context.dispatcher\n\n  val maxTokens: Int = 3\n  var tokens: Int = maxTokens\n  val requestQueue: Queue[(ActorRef, Request)] = Queue.empty\n\n  // Schedule token refill every second\n  val refillInterval: FiniteDuration = 1.second\n  val refillTask: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = refillInterval,\n    delay = refillInterval,\n    receiver = self,\n    message = \"Refill\"\n  )\n\n  def receive: Receive = {\n    case \"Refill\" =>\n      tokens = maxTokens\n      println(s\"RateLimiterActor: Tokens refilled to $tokens\")\n      processQueue()\n\n    case req @ Request(id) =>\n      if (tokens > 0) {\n        tokens -= 1\n        println(s\"RateLimiterActor: Processed request $id (Tokens left: $tokens)\")\n        sender() ! Response(s\"Processed request $id\")\n      } else {\n        println(s\"RateLimiterActor: Rate limit exceeded for request $id. Queuing request.\")\n        requestQueue.enqueue((sender(), req))\n      }\n\n    case _ =>\n      println(\"RateLimiterActor received unknown message.\")\n  }\n\n  def processQueue(): Unit = {\n    while (tokens > 0 && requestQueue.nonEmpty) {\n      val (senderRef, Request(id)) = requestQueue.dequeue()\n      tokens -= 1\n      println(s\"RateLimiterActor: Processed queued request $id (Tokens left: $tokens)\")\n      senderRef ! Response(s\"Processed request $id\")\n    }\n  }\n\n  override def postStop(): Unit = {\n    refillTask.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject RateLimiterApp extends App {\n  import akka.pattern.ask\n  import akka.util.Timeout\n  import scala.concurrent.Await\n\n  val system = ActorSystem(\"RateLimiterSystem\")\n  val rateLimiter = system.actorOf(Props[RateLimiterActor](), \"rateLimiterActor\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n\n  // Function to send a request and print the response\n  def sendRequest(id: Int): Unit = {\n    val future = rateLimiter ? Request(id)\n    val result = Await.result(future, timeout.duration).asInstanceOf[Response]\n    println(s\"Request $id: ${result.message}\")\n  }\n\n  // Send 5 requests rapidly\n  for (i <- 1 to 5) {\n    sendRequest(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named WorkerPoolActor that manages a pool of worker actors. It should handle Task(taskId: Int) messages by forwarding them to workers in a round-robin fashion. Each WorkerActor processes the task by printing \"Worker <name> processing task <taskId>\". Demonstrate the worker pool handling multiple tasks efficiently."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Task(taskId: Int)\n\n// Define the WorkerActor\nclass WorkerActor(name: String) extends Actor {\n  def receive: Receive = {\n    case Task(id) =>\n      println(s\"Worker [$name] processing task $id\")\n    case _ =>\n      println(s\"Worker [$name] received unknown message.\")\n  }\n}\n\n// Define the WorkerPoolActor\nclass WorkerPoolActor(workers: Seq[ActorRef]) extends Actor {\n  var nextWorkerIndex: Int = 0\n  val numberOfWorkers: Int = workers.size\n\n  def receive: Receive = {\n    case task: Task =>\n      val worker = workers(nextWorkerIndex)\n      println(s\"WorkerPoolActor delegating Task ${task.taskId} to Worker ${worker.path.name}\")\n      worker ! task\n      nextWorkerIndex = (nextWorkerIndex + 1) % numberOfWorkers\n    case _ =>\n      println(\"WorkerPoolActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject WorkerPoolApp extends App {\n  val system = ActorSystem(\"WorkerPoolSystem\")\n\n  // Create worker actors\n  val worker1 = system.actorOf(Props(new WorkerActor(\"worker1\")), \"worker1\")\n  val worker2 = system.actorOf(Props(new WorkerActor(\"worker2\")), \"worker2\")\n  val worker3 = system.actorOf(Props(new WorkerActor(\"worker3\")), \"worker3\")\n\n  // Create WorkerPoolActor with the workers\n  val workerPool = system.actorOf(Props(new WorkerPoolActor(Seq(worker1, worker2, worker3))), \"workerPoolActor\")\n\n  // Send multiple tasks to the pool\n  for (i <- 1 to 9) {\n    workerPool ! Task(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named HealthCheckerActor that performs periodic health checks of a simulated service. It should send a CheckHealth message to itself every 4 seconds. Upon receiving CheckHealth, it should randomly determine if the service is healthy or unhealthy and respond accordingly with Healthy or Unhealthy. Demonstrate the health checking mechanism."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.util.Random\n\n// Define messages\ncase object CheckHealth\ncase object Healthy\ncase object Unhealthy\n\n// Define the HealthCheckerActor\nclass HealthCheckerActor extends Actor {\n  import context.dispatcher\n\n  // Schedule periodic health checks\n  val checkInterval: FiniteDuration = 4.seconds\n  val scheduler: Cancellable = context.system.scheduler.scheduleWithFixedDelay(\n    initialDelay = 0.seconds,\n    delay = checkInterval,\n    receiver = self,\n    message = CheckHealth\n  )\n\n  def receive: Receive = {\n    case CheckHealth =>\n      val status = if (Random.nextBoolean()) Healthy else Unhealthy\n      println(s\"HealthCheckerActor: Service status is $status\")\n    case _ =>\n      println(\"HealthCheckerActor received unknown message.\")\n  }\n\n  override def postStop(): Unit = {\n    scheduler.cancel()\n    super.postStop()\n  }\n}\n\n// Usage Example (for testing purposes)\nobject HealthCheckerApp extends App {\n  val system = ActorSystem(\"HealthCheckerSystem\")\n  val healthChecker = system.actorOf(Props(new HealthCheckerActor()), \"healthCheckerActor\")\n\n  // Let the health checker run for 20 seconds before shutdown\n  Thread.sleep(20000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named RetryingActor that handles PerformTask(taskId: Int) messages. Upon receiving a task, it attempts to perform it by randomly succeeding or failing. If a task fails, it should retry up to two additional times before giving up and logging \"Task <taskId> failed after retries.\". Demonstrate the retry mechanism by sending multiple tasks."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport scala.util.Random\n\n// Define messages\ncase class PerformTask(taskId: Int)\ncase class TaskResult(taskId: Int, success: Boolean)\ncase class RetryTask(taskId: Int, attempt: Int)\n\n// Define the RetryingActor\nclass RetryingActor extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case PerformTask(taskId) =>\n      println(s\"RetryingActor: Performing task $taskId (Attempt 1)\")\n      performTask(taskId, attempt = 1)\n    case RetryTask(taskId, attempt) =>\n      println(s\"RetryingActor: Retrying task $taskId (Attempt $attempt)\")\n      performTask(taskId, attempt)\n    case TaskResult(taskId, success) =>\n      if (success) {\n        println(s\"RetryingActor: Task $taskId completed successfully.\")\n      } else {\n        println(s\"RetryingActor: Task $taskId failed.\")\n        if (sender().path.name.startsWith(\"retry\")) {\n          val attempt = sender().path.name.split(\"-\")(1).toInt\n          if (attempt < 3) {\n            // Schedule a retry\n            context.system.scheduler.scheduleOnce(1.second, self, RetryTask(taskId, attempt + 1))\n          } else {\n            println(s\"RetryingActor: Task $taskId failed after retries.\")\n          }\n        }\n      }\n    case _ =>\n      println(\"RetryingActor received unknown message.\")\n  }\n\n  def performTask(taskId: Int, attempt: Int): Unit = {\n    val success = Random.nextBoolean()\n    if (success) {\n      self.tell(TaskResult(taskId, success = true), self)\n    } else {\n      // Create a unique sender name for retries\n      val retrySender = context.actorOf(Props(new Actor {\n        def receive: Receive = {\n          case msg => self.tell(msg, self)\n        }\n      }), name = s\"retry-$attempt\")\n      retrySender ! TaskResult(taskId, success = false)\n    }\n  }\n}\n\n// Usage Example (for testing purposes)\nobject RetryingActorApp extends App {\n  val system = ActorSystem(\"RetryingActorSystem\")\n  val retryingActor = system.actorOf(Props(new RetryingActor()), \"retryingActor\")\n\n  // Send multiple tasks\n  for (i <- 1 to 5) {\n    retryingActor ! PerformTask(i)\n  }\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(10000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named DatabaseSimulatorActor that simulates basic database operations. It should handle Insert(record: String), Delete(record: String), and Query(record: String) messages. Maintain an internal Set to store records. Upon Insert, add the record; upon Delete, remove it; and upon Query, respond with RecordFound(record: String) or RecordNotFound(record: String). Demonstrate inserting, deleting, and querying records."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Insert(record: String)\ncase class Delete(record: String)\ncase class Query(record: String)\ncase class RecordFound(record: String)\ncase class RecordNotFound(record: String)\n\n// Define the DatabaseSimulatorActor\nclass DatabaseSimulatorActor extends Actor {\n  var records: Set[String] = Set.empty\n\n  def receive: Receive = {\n    case Insert(record) =>\n      records += record\n      println(s\"DatabaseSimulatorActor: Inserted record '$record'\")\n    case Delete(record) =>\n      if (records.contains(record)) {\n        records -= record\n        println(s\"DatabaseSimulatorActor: Deleted record '$record'\")\n      } else {\n        println(s\"DatabaseSimulatorActor: Record '$record' not found for deletion.\")\n      }\n    case Query(record) =>\n      if (records.contains(record)) {\n        sender() ! RecordFound(record)\n      } else {\n        sender() ! RecordNotFound(record)\n      }\n    case _ =>\n      println(\"DatabaseSimulatorActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DatabaseSimulatorApp extends App {\n  val system = ActorSystem(\"DatabaseSimulatorSystem\")\n  val dbSimulator = system.actorOf(Props(new DatabaseSimulatorActor()), \"dbSimulatorActor\")\n\n  // Define a simple responder actor to handle query responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case RecordFound(record) =>\n        println(s\"ResponderActor: Record '$record' found in database.\")\n      case RecordNotFound(record) =>\n        println(s\"ResponderActor: Record '$record' not found in database.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Insert records\n  dbSimulator ! Insert(\"Alice\")\n  dbSimulator ! Insert(\"Bob\")\n\n  // Query existing and non-existing records\n  dbSimulator.tell(Query(\"Alice\"), responder)\n  dbSimulator.tell(Query(\"Charlie\"), responder)\n\n  // Delete a record and query again\n  dbSimulator ! Delete(\"Bob\")\n  dbSimulator.tell(Query(\"Bob\"), responder)\n\n  // Attempt to delete a non-existing record\n  dbSimulator ! Delete(\"Charlie\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TaskSchedulerActor that schedules tasks to be executed after a specified delay. It should handle ScheduleTask(task: String, delay: FiniteDuration) messages by scheduling the task to be executed after the given delay. Upon execution, it should print \"Executed task: <task>\". Demonstrate scheduling multiple tasks with different delays."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorSystem, Props, Cancellable}\nimport scala.concurrent.duration._\nimport akka.actor.Timers\n\n// Define messages\ncase class ScheduleTask(task: String, delay: FiniteDuration)\n\n// Define the TaskSchedulerActor\nclass TaskSchedulerActor extends Actor {\n  import context.dispatcher\n\n  def receive: Receive = {\n    case ScheduleTask(task, delay) =>\n      println(s\"TaskSchedulerActor: Scheduling task '$task' to execute in $delay.\")\n      context.system.scheduler.scheduleOnce(delay, self, (\"ExecuteTask\", task))\n    case (\"ExecuteTask\", task: String) =>\n      println(s\"TaskSchedulerActor: Executed task: $task\")\n    case _ =>\n      println(\"TaskSchedulerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TaskSchedulerApp extends App {\n  val system = ActorSystem(\"TaskSchedulerSystem\")\n  val schedulerActor = system.actorOf(Props(new TaskSchedulerActor()), \"schedulerActor\")\n\n  // Schedule multiple tasks with different delays\n  schedulerActor ! ScheduleTask(\"Backup Database\", 2.seconds)\n  schedulerActor ! ScheduleTask(\"Send Report\", 4.seconds)\n  schedulerActor ! ScheduleTask(\"Cleanup Logs\", 6.seconds)\n\n  // Allow some time for task execution before shutdown\n  Thread.sleep(8000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named AuthenticationActor that manages user authentication. It should handle Login(username: String, password: String) and Logout(username: String) messages. Maintain an internal Set of authenticated users. Upon successful login (assume any password is valid for simplicity), add the user to the set and respond with LoginSuccess(username: String). Upon logout, remove the user and respond with LogoutSuccess(username: String). Demonstrate logging in and out users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Login(username: String, password: String)\ncase class Logout(username: String)\ncase class LoginSuccess(username: String)\ncase class LogoutSuccess(username: String)\ncase class AuthenticationFailure(username: String, reason: String)\n\n// Define the AuthenticationActor\nclass AuthenticationActor extends Actor {\n  var authenticatedUsers: Set[String] = Set.empty\n\n  def receive: Receive = {\n    case Login(username, password) =>\n      // For simplicity, accept any password\n      if (!authenticatedUsers.contains(username)) {\n        authenticatedUsers += username\n        println(s\"AuthenticationActor: User '$username' logged in.\")\n        sender() ! LoginSuccess(username)\n      } else {\n        sender() ! AuthenticationFailure(username, \"User already logged in.\")\n      }\n\n    case Logout(username) =>\n      if (authenticatedUsers.contains(username)) {\n        authenticatedUsers -= username\n        println(s\"AuthenticationActor: User '$username' logged out.\")\n        sender() ! LogoutSuccess(username)\n      } else {\n        sender() ! AuthenticationFailure(username, \"User not logged in.\")\n      }\n\n    case _ =>\n      println(\"AuthenticationActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject AuthenticationApp extends App {\n  val system = ActorSystem(\"AuthenticationSystem\")\n  val authActor = system.actorOf(Props(new AuthenticationActor()), \"authenticationActor\")\n\n  // Define a simple responder actor to handle authentication responses\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case LoginSuccess(username) =>\n        println(s\"ResponderActor: User '$username' successfully logged in.\")\n      case LogoutSuccess(username) =>\n        println(s\"ResponderActor: User '$username' successfully logged out.\")\n      case AuthenticationFailure(username, reason) =>\n        println(s\"ResponderActor: Authentication failed for '$username'. Reason: $reason\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Perform login and logout operations\n  authActor.tell(Login(\"Alice\", \"password123\"), responder)\n  authActor.tell(Login(\"Bob\", \"securepass\"), responder)\n  authActor.tell(Login(\"Alice\", \"newpassword\"), responder) // Attempt duplicate login\n  authActor.tell(Logout(\"Alice\"), responder)\n  authActor.tell(Logout(\"Charlie\"), responder) // Attempt logout of non-logged-in user\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TopicPublisherActor that publishes messages to specific topics. It should handle Subscribe(topic: String) and Publish(topic: String, message: String) messages. Maintain a mapping of topics to subscriber actors. Upon publishing, send the message only to subscribers of the specified topic wrapped in TopicMessage(topic: String, message: String). Demonstrate subscribing to different topics and publishing messages accordingly."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Subscribe(topic: String)\ncase class Publish(topic: String, message: String)\ncase class TopicMessage(topic: String, message: String)\n\n// Define the TopicPublisherActor\nclass TopicPublisherActor extends Actor {\n  var topicSubscribers: Map[String, Set[ActorRef]] = Map.empty.withDefaultValue(Set.empty)\n\n  def receive: Receive = {\n    case Subscribe(topic) =>\n      topicSubscribers += topic -> (topicSubscribers(topic) + sender())\n      println(s\"TopicPublisherActor: ${sender().path.name} subscribed to topic '$topic'\")\n    case Publish(topic, message) =>\n      println(s\"TopicPublisherActor: Publishing message to topic '$topic': $message\")\n      topicSubscribers(topic).foreach(_ ! TopicMessage(topic, message))\n    case _ =>\n      println(\"TopicPublisherActor received unknown message.\")\n  }\n}\n\n// Define the SubscriberActor\nclass SubscriberActor(name: String) extends Actor {\n  def receive: Receive = {\n    case TopicMessage(topic, message) =>\n      println(s\"Subscriber [$name] received on '$topic': $message\")\n    case _ =>\n      println(s\"Subscriber [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TopicPubSubApp extends App {\n  val system = ActorSystem(\"TopicPubSubSystem\")\n  val publisher = system.actorOf(Props(new TopicPublisherActor()), \"publisherActor\")\n\n  // Create subscriber actors\n  val subscriber1 = system.actorOf(Props(new SubscriberActor(\"Subscriber1\")), \"subscriber1\")\n  val subscriber2 = system.actorOf(Props(new SubscriberActor(\"Subscriber2\")), \"subscriber2\")\n  val subscriber3 = system.actorOf(Props(new SubscriberActor(\"Subscriber3\")), \"subscriber3\")\n\n  // Subscribers subscribe to topics\n  subscriber1 ! Subscribe(\"news\")\n  subscriber2 ! Subscribe(\"sports\")\n  subscriber3 ! Subscribe(\"news\")\n  subscriber3 ! Subscribe(\"sports\")\n\n  // Publish messages to topics\n  publisher ! Publish(\"news\", \"Breaking News: Akka Actors are awesome!\")\n  publisher ! Publish(\"sports\", \"Sports Update: Local team wins championship.\")\n  publisher ! Publish(\"entertainment\", \"New movie released this weekend.\") // No subscribers\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TransactionManagerActor that manages simple financial transactions. It should handle Deposit(amount: Double), Withdraw(amount: Double), and GetBalance messages. Maintain an internal balance starting at 0.0. Upon Deposit, add the amount to the balance; upon Withdraw, subtract the amount if sufficient funds exist, otherwise respond with InsufficientFunds(amount: Double). Upon GetBalance, respond with CurrentBalance(balance: Double). Demonstrate performing deposits, withdrawals, and querying the balance."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Deposit(amount: Double)\ncase class Withdraw(amount: Double)\ncase object GetBalance\ncase class CurrentBalance(balance: Double)\ncase class InsufficientFunds(amount: Double)\n\n// Define the TransactionManagerActor\nclass TransactionManagerActor extends Actor {\n  var balance: Double = 0.0\n\n  def receive: Receive = {\n    case Deposit(amount) =>\n      if (amount > 0) {\n        balance += amount\n        println(s\"TransactionManagerActor: Deposited $$${amount}. New balance: $$${balance}.\")\n      } else {\n        println(\"TransactionManagerActor: Deposit amount must be positive.\")\n      }\n    case Withdraw(amount) =>\n      if (amount > 0) {\n        if (balance >= amount) {\n          balance -= amount\n          println(s\"TransactionManagerActor: Withdrew $$${amount}. New balance: $$${balance}.\")\n        } else {\n          println(s\"TransactionManagerActor: Insufficient funds for withdrawal of $$${amount}.\")\n          sender() ! InsufficientFunds(amount)\n        }\n      } else {\n        println(\"TransactionManagerActor: Withdrawal amount must be positive.\")\n      }\n    case GetBalance =>\n      sender() ! CurrentBalance(balance)\n    case _ =>\n      println(\"TransactionManagerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TransactionManagerApp extends App {\n  val system = ActorSystem(\"TransactionManagerSystem\")\n  val transactionManager = system.actorOf(Props(new TransactionManagerActor()), \"transactionManagerActor\")\n\n  // Define a simple responder actor to handle balance queries and errors\n  class ResponderActor extends Actor {\n    def receive: Receive = {\n      case CurrentBalance(balance) =>\n        println(f\"ResponderActor: Current balance is $$${balance}%.2f\")\n      case InsufficientFunds(amount) =>\n        println(f\"ResponderActor: Cannot withdraw $$${amount}%.2f due to insufficient funds.\")\n      case _ =>\n        println(\"ResponderActor received unknown message.\")\n    }\n  }\n\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Perform transactions\n  transactionManager ! Deposit(500.0)\n  transactionManager ! Withdraw(200.0)\n  transactionManager ! Withdraw(400.0) // Should fail\n  transactionManager.tell(GetBalance, responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named EmailNotificationActor that sends email notifications. It should handle SendEmail(to: String, subject: String, body: String) messages by printing the email details to the console. Implement a UserActor that represents a user and sends SendEmail messages to the EmailNotificationActor. Demonstrate sending emails to multiple users."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class SendEmail(to: String, subject: String, body: String)\n\n// Define the EmailNotificationActor\nclass EmailNotificationActor extends Actor {\n  def receive: Receive = {\n    case SendEmail(to, subject, body) =>\n      println(s\"EmailNotificationActor: Sending email to '$to'\")\n      println(s\"Subject: $subject\")\n      println(s\"Body: $body\")\n      println(\"----- Email Sent -----\")\n    case _ =>\n      println(\"EmailNotificationActor received unknown message.\")\n  }\n}\n\n// Define the UserActor\nclass UserActor(name: String, emailNotifier: ActorRef) extends Actor {\n  def receive: Receive = {\n    case (subject: String, body: String) =>\n      val to = s\"$name@example.com\"\n      emailNotifier ! SendEmail(to, subject, body)\n    case _ =>\n      println(s\"UserActor [$name] received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject EmailNotificationApp extends App {\n  val system = ActorSystem(\"EmailNotificationSystem\")\n  val emailNotifier = system.actorOf(Props(new EmailNotificationActor()), \"emailNotifierActor\")\n\n  // Create user actors\n  val user1 = system.actorOf(Props(new UserActor(\"Alice\", emailNotifier)), \"userAlice\")\n  val user2 = system.actorOf(Props(new UserActor(\"Bob\", emailNotifier)), \"userBob\")\n  val user3 = system.actorOf(Props(new UserActor(\"Charlie\", emailNotifier)), \"userCharlie\")\n\n  // Send emails\n  user1 ! (\"Welcome to our service!\", \"Hello Alice, welcome aboard!\")\n  user2 ! (\"Your account has been updated.\", \"Hi Bob, your account settings have been updated.\")\n  user3 ! (\"Password Reset\", \"Dear Charlie, please reset your password using the link provided.\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named TaskCompletionListenerActor that listens for TaskCompleted(taskId: Int) messages. Upon receiving such a message, it should print \"Task <taskId> has been completed successfully.\". Implement a WorkerActor that performs tasks and sends TaskCompleted messages to the listener upon completion. Demonstrate task execution and listener notification."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class Task(taskId: Int)\ncase class TaskCompleted(taskId: Int)\n\n// Define the TaskCompletionListenerActor\nclass TaskCompletionListenerActor extends Actor {\n  def receive: Receive = {\n    case TaskCompleted(taskId) =>\n      println(s\"TaskCompletionListenerActor: Task $taskId has been completed successfully.\")\n    case _ =>\n      println(\"TaskCompletionListenerActor received unknown message.\")\n  }\n}\n\n// Define the WorkerActor\nclass WorkerActor(listener: ActorRef) extends Actor {\n  def receive: Receive = {\n    case Task(taskId) =>\n      println(s\"WorkerActor: Processing task $taskId.\")\n      // Simulate task processing\n      Thread.sleep(500)\n      println(s\"WorkerActor: Task $taskId completed.\")\n      listener ! TaskCompleted(taskId)\n    case _ =>\n      println(\"WorkerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TaskCompletionApp extends App {\n  val system = ActorSystem(\"TaskCompletionSystem\")\n  \n  val listener = system.actorOf(Props(new TaskCompletionListenerActor()), \"listenerActor\")\n  val worker = system.actorOf(Props(new WorkerActor(listener)), \"workerActor\")\n\n  // Send tasks to the worker\n  worker ! Task(101)\n  worker ! Task(102)\n  worker ! Task(103)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named TemperatureMonitorActor that receives temperature readings and alerts if the temperature exceeds a specified threshold. It should handle TemperatureReading(sensorId: String, temperature: Double) messages. If the temperature is above 30.0\u00b0C, respond with Alert(sensorId: String, temperature: Double); otherwise, acknowledge with ReadingAccepted(sensorId: String). Demonstrate monitoring temperatures from multiple sensors."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class TemperatureReading(sensorId: String, temperature: Double)\ncase class Alert(sensorId: String, temperature: Double)\ncase class ReadingAccepted(sensorId: String)\n\n// Define the TemperatureMonitorActor\nclass TemperatureMonitorActor extends Actor {\n  val threshold: Double = 30.0\n\n  def receive: Receive = {\n    case TemperatureReading(sensorId, temp) =>\n      if (temp > threshold) {\n        println(s\"TemperatureMonitorActor: Temperature alert from $sensorId: $temp\u00b0C\")\n        sender() ! Alert(sensorId, temp)\n      } else {\n        println(s\"TemperatureMonitorActor: Temperature reading from $sensorId: $temp\u00b0C accepted.\")\n        sender() ! ReadingAccepted(sensorId)\n      }\n    case _ =>\n      println(\"TemperatureMonitorActor received unknown message.\")\n  }\n}\n\n// Define the SensorActor\nclass SensorActor(sensorId: String, monitor: ActorRef) extends Actor {\n  def receive: Receive = {\n    case temp: Double =>\n      println(s\"SensorActor [$sensorId]: Sending temperature reading: $temp\u00b0C\")\n      monitor ! TemperatureReading(sensorId, temp)\n    case _ =>\n      println(s\"SensorActor [$sensorId] received unknown message.\")\n  }\n}\n\n// Define the ResponderActor to handle monitor responses\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case Alert(sensorId, temp) =>\n      println(s\"ResponderActor: ALERT! Sensor $sensorId reported high temperature: $temp\u00b0C\")\n    case ReadingAccepted(sensorId) =>\n      println(s\"ResponderActor: Temperature reading from $sensorId accepted.\")\n    case _ =>\n      println(\"ResponderActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject TemperatureMonitorApp extends App {\n  val system = ActorSystem(\"TemperatureMonitorSystem\")\n\n  val monitor = system.actorOf(Props(new TemperatureMonitorActor()), \"temperatureMonitorActor\")\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Create sensor actors\n  val sensor1 = system.actorOf(Props(new SensorActor(\"Sensor1\", monitor)), \"sensor1\")\n  val sensor2 = system.actorOf(Props(new SensorActor(\"Sensor2\", monitor)), \"sensor2\")\n  val sensor3 = system.actorOf(Props(new SensorActor(\"Sensor3\", monitor)), \"sensor3\")\n\n  // Send temperature readings\n  sensor1.tell(25.5, responder)\n  sensor2.tell(32.0, responder)\n  sensor3.tell(28.3, responder)\n  sensor1.tell(31.2, responder)\n  sensor2.tell(29.8, responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Create an Akka Actor in Scala named OrderProcessorActor that handles online orders. It should handle PlaceOrder(orderId: String, item: String) messages by processing the order and responding with OrderConfirmed(orderId: String) or OrderFailed(orderId: String, reason: String) based on simulated processing logic. Implement a CustomerActor that places orders and handles confirmations or failures. Demonstrate placing multiple orders with varying outcomes."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\nimport scala.util.Random\n\n// Define messages\ncase class PlaceOrder(orderId: String, item: String)\ncase class OrderConfirmed(orderId: String)\ncase class OrderFailed(orderId: String, reason: String)\n\n// Define the OrderProcessorActor\nclass OrderProcessorActor extends Actor {\n  def receive: Receive = {\n    case PlaceOrder(orderId, item) =>\n      println(s\"OrderProcessorActor: Processing order $orderId for item '$item'\")\n      // Simulate order processing with random success/failure\n      if (Random.nextBoolean()) {\n        println(s\"OrderProcessorActor: Order $orderId confirmed.\")\n        sender() ! OrderConfirmed(orderId)\n      } else {\n        println(s\"OrderProcessorActor: Order $orderId failed due to stock unavailability.\")\n        sender() ! OrderFailed(orderId, \"Stock unavailable.\")\n      }\n    case _ =>\n      println(\"OrderProcessorActor received unknown message.\")\n  }\n}\n\n// Define the CustomerActor\nclass CustomerActor(orderProcessor: ActorRef) extends Actor {\n  def receive: Receive = {\n    case PlaceOrder(orderId, item) =>\n      println(s\"CustomerActor: Placing order $orderId for item '$item'\")\n      orderProcessor ! PlaceOrder(orderId, item)\n    case OrderConfirmed(orderId) =>\n      println(s\"CustomerActor: Order $orderId has been confirmed. Thank you!\")\n    case OrderFailed(orderId, reason) =>\n      println(s\"CustomerActor: Order $orderId failed. Reason: $reason\")\n    case _ =>\n      println(\"CustomerActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject OrderProcessingApp extends App {\n  val system = ActorSystem(\"OrderProcessingSystem\")\n\n  val orderProcessor = system.actorOf(Props(new OrderProcessorActor()), \"orderProcessorActor\")\n  val customer = system.actorOf(Props(new CustomerActor(orderProcessor)), \"customerActor\")\n\n  // Place multiple orders\n  customer ! PlaceOrder(\"Order001\", \"Laptop\")\n  customer ! PlaceOrder(\"Order002\", \"Smartphone\")\n  customer ! PlaceOrder(\"Order003\", \"Headphones\")\n  customer ! PlaceOrder(\"Order004\", \"Monitor\")\n  customer ! PlaceOrder(\"Order005\", \"Keyboard\")\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(2000)\n  system.terminate()\n}"
      }
    ]
  },
  {
    "conversations": [
      {
        "from": "human",
        "value": "Design an Akka Actor in Scala named DataAggregatorActor that collects numerical data from multiple sources and computes the average. It should handle DataPoint(value: Double) messages by adding them to an internal list. Upon receiving a ComputeAverage message, it should calculate and respond with AverageResult(average: Double). Demonstrate collecting data from multiple sources and computing the average."
      },
      {
        "from": "assistant",
        "value": "import akka.actor.{Actor, ActorRef, ActorSystem, Props}\n\n// Define messages\ncase class DataPoint(value: Double)\ncase object ComputeAverage\ncase class AverageResult(average: Double)\n\n// Define the DataAggregatorActor\nclass DataAggregatorActor extends Actor {\n  var dataPoints: List[Double] = List.empty\n\n  def receive: Receive = {\n    case DataPoint(value) =>\n      dataPoints = value :: dataPoints\n      println(s\"DataAggregatorActor: Received data point $value\")\n    case ComputeAverage =>\n      if (dataPoints.nonEmpty) {\n        val average = dataPoints.sum / dataPoints.size\n        println(f\"DataAggregatorActor: Computed average = $$${average}%.2f\")\n        sender() ! AverageResult(average)\n      } else {\n        println(\"DataAggregatorActor: No data points to compute average.\")\n        sender() ! AverageResult(0.0)\n      }\n    case _ =>\n      println(\"DataAggregatorActor received unknown message.\")\n  }\n}\n\n// Define the DataSourceActor\nclass DataSourceActor(aggregator: ActorRef) extends Actor {\n  def receive: Receive = {\n    case value: Double =>\n      println(s\"DataSourceActor sending data point: $value\")\n      aggregator ! DataPoint(value)\n    case _ =>\n      println(\"DataSourceActor received unknown message.\")\n  }\n}\n\n// Define the ResponderActor to handle average results\nclass ResponderActor extends Actor {\n  def receive: Receive = {\n    case AverageResult(avg) =>\n      println(f\"ResponderActor: The average of collected data points is $$${avg}%.2f\")\n    case _ =>\n      println(\"ResponderActor received unknown message.\")\n  }\n}\n\n// Usage Example (for testing purposes)\nobject DataAggregatorApp extends App {\n  val system = ActorSystem(\"DataAggregatorSystem\")\n\n  val aggregator = system.actorOf(Props(new DataAggregatorActor()), \"aggregatorActor\")\n  val responder = system.actorOf(Props(new ResponderActor()), \"responderActor\")\n\n  // Create data source actors\n  val source1 = system.actorOf(Props(new DataSourceActor(aggregator)), \"source1\")\n  val source2 = system.actorOf(Props(new DataSourceActor(aggregator)), \"source2\")\n  val source3 = system.actorOf(Props(new DataSourceActor(aggregator)), \"source3\")\n\n  // Send data points from sources\n  source1 ! 10.5\n  source2 ! 20.0\n  source3 ! 30.5\n  source1 ! 25.0\n  source2 ! 15.5\n\n  // Compute average\n  aggregator.tell(ComputeAverage, responder)\n\n  // Allow some time for processing before shutdown\n  Thread.sleep(1000)\n  system.terminate()\n}"
      }
    ]
  }
]